{
  "files": [
    {
      "path": ".github/workflows/ci.yml -> .github/workflows-backup/ci.yml",
      "status": "renamed",
      "diff": ""
    },
    {
      "path": ".github/workflows-backup/nightly.yml",
      "status": "added",
      "diff": "diff --git a/.github/workflows-backup/nightly.yml b/.github/workflows-backup/nightly.yml\nnew file mode 100644\nindex 0000000..2618595\n--- /dev/null\n+++ b/.github/workflows-backup/nightly.yml\n@@ -0,0 +1,196 @@\n+name: Nightly Builds\n+\n+on:\n+  schedule:\n+    # Ejecutar cada día a las 3:00 AM UTC\n+    - cron: '0 3 * * *'\n+  workflow_dispatch:\n+    inputs:\n+      force_build:\n+        description: 'Forzar build aunque no haya cambios'\n+        required: false\n+        default: false\n+        type: boolean\n+\n+env:\n+  NODE_VERSION: '20'\n+  REGISTRY_URL: 'https://registry.npmjs.org'\n+\n+jobs:\n+  check-changes:\n+    runs-on: ubuntu-latest\n+    outputs:\n+      has_changes: ${{ steps.changes.outputs.has_changes }}\n+      last_commit: ${{ steps.changes.outputs.last_commit }}\n+      commit_count: ${{ steps.changes.outputs.commit_count }}\n+    \n+    steps:\n+      - name: 📥 Checkout code\n+        uses: actions/checkout@v4\n+        with:\n+          fetch-depth: 0\n+\n+      - name: 🔍 Check for changes since last nightly\n+        id: changes\n+        run: |\n+          # Buscar último tag nightly\n+          LAST_NIGHTLY=$(git tag -l \"nightly-*\" | sort -V | tail -1 || echo \"\")\n+          \n+          if [ -z \"$LAST_NIGHTLY\" ]; then\n+            # No hay nightlies previos, verificar desde hace 24 horas\n+            SINCE_DATE=$(date -d '24 hours ago' --iso-8601)\n+            COMMITS_COUNT=$(git log --since=\"$SINCE_DATE\" --oneline | wc -l)\n+          else\n+            # Verificar desde último nightly\n+            COMMITS_COUNT=$(git log $LAST_NIGHTLY..HEAD --oneline | wc -l)\n+          fi\n+          \n+          LAST_COMMIT=$(git rev-parse --short HEAD)\n+          \n+          echo \"commit_count=$COMMITS_COUNT\" >> $GITHUB_OUTPUT\n+          echo \"last_commit=$LAST_COMMIT\" >> $GITHUB_OUTPUT\n+          \n+          if [ \"$COMMITS_COUNT\" -gt 0 ] || [ \"${{ inputs.force_build }}\" == \"true\" ]; then\n+            echo \"has_changes=true\" >> $GITHUB_OUTPUT\n+            echo \"✅ Cambios detectados: $COMMITS_COUNT commits\"\n+          else\n+            echo \"has_changes=false\" >> $GITHUB_OUTPUT  \n+            echo \"ℹ️ No hay cambios desde último nightly\"\n+          fi\n+\n+  nightly-build:\n+    runs-on: ubuntu-latest\n+    needs: check-changes\n+    if: needs.check-changes.outputs.has_changes == 'true'\n+    \n+    permissions:\n+      contents: write\n+      packages: write\n+      id-token: write\n+    \n+    steps:\n+      - name: 📥 Checkout code\n+        uses: actions/checkout@v4\n+        with:\n+          fetch-depth: 0\n+          token: ${{ secrets.GITHUB_TOKEN }}\n+\n+      - name: 📦 Setup Node.js\n+        uses: actions/setup-node@v4\n+        with:\n+          node-version: ${{ env.NODE_VERSION }}\n+          cache: 'npm'\n+          registry-url: ${{ env.REGISTRY_URL }}\n+\n+      - name: 🔧 Install dependencies\n+        run: npm ci\n+\n+      - name: 🏗️ Build library\n+        run: npm run build\n+\n+      - name: 🧪 Run tests\n+        run: |\n+          npm run type-check\n+          npm run test\n+          npm run size-limit\n+\n+      - name: 🏷️ Generate nightly version\n+        id: version\n+        run: |\n+          # Generar versión nightly usando commit y fecha\n+          DATE=$(date +%Y%m%d)\n+          SHORT_SHA=\"${{ needs.check-changes.outputs.last_commit }}\"\n+          BASE_VERSION=$(node -p \"require('./package.json').version\")\n+          \n+          # Remover cualquier sufijo existente del base version\n+          CLEAN_VERSION=$(echo $BASE_VERSION | sed 's/-.*//')\n+          NIGHTLY_VERSION=\"${CLEAN_VERSION}-nightly.${DATE}.${SHORT_SHA}\"\n+          \n+          echo \"version=$NIGHTLY_VERSION\" >> $GITHUB_OUTPUT\n+          echo \"tag=nightly-$DATE-$SHORT_SHA\" >> $GITHUB_OUTPUT\n+          echo \"🌙 Nightly version: $NIGHTLY_VERSION\"\n+\n+      - name: 📝 Update package.json for nightly\n+        run: |\n+          npm version ${{ steps.version.outputs.version }} --no-git-tag-version\n+\n+      - name: 📦 Create nightly archives  \n+        run: |\n+          mkdir -p nightly-dist\n+          \n+          # Crear archivos de distribución nightly\n+          tar -czf nightly-dist/better-logger-nightly-${{ steps.version.outputs.tag }}.tar.gz dist/ README.md package.json\n+          zip -r nightly-dist/better-logger-nightly-${{ steps.version.outputs.tag }}.zip dist/ README.md package.json\n+\n+      - name: 🚀 Publish nightly to NPM\n+        run: |\n+          npm publish --tag nightly --access public\n+        env:\n+          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}\n+\n+      - name: 📦 Publish nightly to GitHub Packages  \n+        run: |\n+          echo \"//npm.pkg.github.com/:_authToken=${{ secrets.GITHUB_TOKEN }}\" >> ~/.npmrc\n+          echo \"@mks2508:registry=https://npm.pkg.github.com\" >> ~/.npmrc\n+          npm publish --registry=https://npm.pkg.github.com --tag nightly --access public\n+\n+      - name: 🏷️ Create nightly tag\n+        run: |\n+          git config user.name \"github-actions[bot]\"\n+          git config user.email \"github-actions[bot]@users.noreply.github.com\" \n+          git tag -a \"${{ steps.version.outputs.tag }}\" -m \"Nightly build ${{ steps.version.outputs.version }}\"\n+          git push origin \"${{ steps.version.outputs.tag }}\"\n+\n+      - name: 🌙 Create nightly release\n+        uses: softprops/action-gh-release@v1\n+        with:\n+          tag_name: ${{ steps.version.outputs.tag }}\n+          name: \"Nightly Build ${{ steps.version.outputs.version }}\"\n+          body: |\n+            🌙 **Nightly Build** - Experimental version for testing\n+            \n+            **⚠️ This is a development build - not recommended for production use**\n+            \n+            ## 📋 Changes since last nightly\n+            ${{ needs.check-changes.outputs.commit_count }} commits included in this build.\n+            \n+            ## 📦 Installation\n+            ```bash\n+            npm install @mks2508/better-logger@nightly\n+            ```\n+            \n+            ## 🔗 Links\n+            - **Commit**: https://github.com/MKS2508/advanced-logger/commit/${{ needs.check-changes.outputs.last_commit }}\n+            - **NPM**: https://www.npmjs.com/package/@mks2508/better-logger/v/${{ steps.version.outputs.version }}\n+          draft: false\n+          prerelease: true\n+          files: |\n+            nightly-dist/better-logger-nightly-${{ steps.version.outputs.tag }}.tar.gz  \n+            nightly-dist/better-logger-nightly-${{ steps.version.outputs.tag }}.zip\n+        env:\n+          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n+\n+      - name: 📊 Nightly build summary\n+        run: |\n+          echo \"## 🌙 Nightly Build Complete!\" >> $GITHUB_STEP_SUMMARY\n+          echo \"- **Version**: ${{ steps.version.outputs.version }}\" >> $GITHUB_STEP_SUMMARY\n+          echo \"- **Commits**: ${{ needs.check-changes.outputs.commit_count }}\" >> $GITHUB_STEP_SUMMARY  \n+          echo \"- **NPM**: https://www.npmjs.com/package/@mks2508/better-logger/v/${{ steps.version.outputs.version }}\" >> $GITHUB_STEP_SUMMARY\n+          echo \"- **GitHub**: https://github.com/MKS2508/advanced-logger/releases/tag/${{ steps.version.outputs.tag }}\" >> $GITHUB_STEP_SUMMARY\n+          echo \"\" >> $GITHUB_STEP_SUMMARY\n+          echo \"### 📦 Installation\" >> $GITHUB_STEP_SUMMARY\n+          echo \"\\`\\`\\`bash\" >> $GITHUB_STEP_SUMMARY  \n+          echo \"npm install @mks2508/better-logger@nightly\" >> $GITHUB_STEP_SUMMARY\n+          echo \"\\`\\`\\`\" >> $GITHUB_STEP_SUMMARY\n+\n+  no-changes:\n+    runs-on: ubuntu-latest\n+    needs: check-changes\n+    if: needs.check-changes.outputs.has_changes == 'false'\n+    \n+    steps:\n+      - name: ℹ️ No changes detected\n+        run: |\n+          echo \"## ℹ️ No Nightly Build Required\" >> $GITHUB_STEP_SUMMARY\n+          echo \"No changes detected since last nightly build.\" >> $GITHUB_STEP_SUMMARY\n+          echo \"Use \\`workflow_dispatch\\` with \\`force_build: true\\` to force a build.\" >> $GITHUB_STEP_SUMMARY\n\\ No newline at end of file",
      "lines_added": 196,
      "lines_removed": 0,
      "is_binary": false
    },
    {
      "path": ".github/workflows-backup/release-optimized.yml",
      "status": "added",
      "diff": "diff --git a/.github/workflows-backup/release-optimized.yml b/.github/workflows-backup/release-optimized.yml\nnew file mode 100644\nindex 0000000..846bd9b\n--- /dev/null\n+++ b/.github/workflows-backup/release-optimized.yml\n@@ -0,0 +1,373 @@\n+name: Optimized Release Pipeline\n+\n+on:\n+  workflow_dispatch:\n+    inputs:\n+      release_type:\n+        description: 'Tipo de release'\n+        required: true\n+        default: 'auto'\n+        type: choice\n+        options:\n+          - auto\n+          - patch\n+          - minor\n+          - major\n+          - alpha\n+          - beta\n+          - stable\n+      use_gemini:\n+        description: 'Usar Gemini AI para versionado'\n+        required: false\n+        default: true\n+        type: boolean\n+      skip_tests:\n+        description: 'Saltar tests (no recomendado)'\n+        required: false\n+        default: false\n+        type: boolean\n+      target_registry:\n+        description: 'Registro objetivo'\n+        required: false\n+        default: 'both'\n+        type: choice\n+        options:\n+          - npm\n+          - github\n+          - both\n+\n+env:\n+  NODE_VERSION: '20'\n+\n+jobs:\n+  # ===== VALIDATION & VERSIONING =====\n+  prepare-release:\n+    runs-on: ubuntu-latest\n+    \n+    outputs:\n+      version: ${{ steps.version.outputs.version }}\n+      tag: ${{ steps.version.outputs.tag }}\n+      is_prerelease: ${{ steps.version.outputs.is_prerelease }}\n+      changelog: ${{ steps.version.outputs.changelog }}\n+      release_channel: ${{ steps.version.outputs.release_channel }}\n+    \n+    steps:\n+      - name: 📥 Checkout code\n+        uses: actions/checkout@v4\n+        with:\n+          fetch-depth: 0\n+          token: ${{ secrets.GITHUB_TOKEN }}\n+\n+      - name: 📦 Setup Node.js\n+        uses: actions/setup-node@v4\n+        with:\n+          node-version: ${{ env.NODE_VERSION }}\n+          cache: 'npm'\n+\n+      - name: 🔧 Install dependencies\n+        run: npm ci\n+\n+      - name: 🧪 Run tests (unless skipped)\n+        if: ${{ !inputs.skip_tests }}\n+        run: |\n+          npm run type-check\n+          npm run lint  \n+          npm run test\n+          npm run build\n+\n+      - name: 🏷️ Generate version with project-utils\n+        id: version\n+        run: |\n+          if [ \"${{ inputs.use_gemini }}\" == \"true\" ] && [ \"${{ inputs.release_type }}\" == \"auto\" ]; then\n+            # Usar auto-release con Gemini para detección inteligente\n+            echo \"🤖 Usando Gemini AI para versionado automático...\"\n+            npm run version:auto\n+          elif [ \"${{ inputs.release_type }}\" == \"auto\" ]; then\n+            # Auto-detección sin Gemini  \n+            echo \"🔍 Auto-detectando tipo de versión...\"\n+            npm run version:auto\n+          else\n+            # Tipo específico forzado\n+            echo \"🎯 Usando tipo de versión forzado: ${{ inputs.release_type }}\"\n+            case \"${{ inputs.release_type }}\" in\n+              \"patch\") npm run version:patch ;;\n+              \"minor\") npm run version:minor ;;  \n+              \"major\") npm run version:major ;;\n+              \"alpha\") npm run version:alpha ;;\n+              \"beta\") npm run version:beta ;;\n+              \"stable\") npm run version:stable ;;\n+            esac\n+          fi\n+          \n+          # Obtener nueva versión del package.json\n+          NEW_VERSION=$(node -p \"require('./package.json').version\")\n+          echo \"version=$NEW_VERSION\" >> $GITHUB_OUTPUT\n+          echo \"tag=v$NEW_VERSION\" >> $GITHUB_OUTPUT\n+          \n+          # Determinar si es prerelease y canal\n+          if [[ \"$NEW_VERSION\" == *\"alpha\"* ]]; then\n+            echo \"is_prerelease=true\" >> $GITHUB_OUTPUT\n+            echo \"release_channel=alpha\" >> $GITHUB_OUTPUT\n+          elif [[ \"$NEW_VERSION\" == *\"beta\"* ]]; then\n+            echo \"is_prerelease=true\" >> $GITHUB_OUTPUT  \n+            echo \"release_channel=beta\" >> $GITHUB_OUTPUT\n+          else\n+            echo \"is_prerelease=false\" >> $GITHUB_OUTPUT\n+            echo \"release_channel=latest\" >> $GITHUB_OUTPUT\n+          fi\n+          \n+          echo \"📦 Nueva versión: $NEW_VERSION\"\n+\n+      - name: 📝 Generate changelog \n+        id: changelog\n+        run: |\n+          # Usar project-utils para generar changelog si existe\n+          if [ -f \"project-utils/.temp/commit-proposal\"*\".md\" ]; then\n+            echo \"📋 Usando changelog de project-utils...\"\n+            CHANGELOG=$(cat project-utils/.temp/commit-proposal*.md | head -n 20)\n+          else\n+            # Fallback a changelog tradicional\n+            LAST_TAG=$(git describe --tags --abbrev=0 HEAD~1 2>/dev/null || echo \"\")\n+            if [ -n \"$LAST_TAG\" ]; then\n+              echo \"📋 Generando changelog desde $LAST_TAG...\"\n+              CHANGELOG=$(git log $LAST_TAG..HEAD --pretty=format:\"- %s (%h)\")\n+            else\n+              echo \"📋 Changelog de release inicial...\"\n+              CHANGELOG=\"- Initial release with complete Better Logger functionality\"\n+            fi\n+          fi\n+          \n+          # Guardar changelog en archivo para uso posterior\n+          echo \"$CHANGELOG\" > RELEASE_CHANGELOG.md\n+          echo \"changelog=$(echo \"$CHANGELOG\" | base64 -w 0)\" >> $GITHUB_OUTPUT\n+\n+      - name: 🏗️ Build optimized\n+        run: |\n+          npm run build\n+          \n+          # Verificar que todos los archivos esperados existen\n+          echo \"📊 Verificando build outputs...\"\n+          ls -la dist/\n+          \n+          # Guardar información de bundle sizes  \n+          echo \"## 📦 Bundle Sizes\" > BUNDLE_SIZES.md\n+          echo \"\\`\\`\\`\" >> BUNDLE_SIZES.md\n+          ls -lh dist/*.js dist/*.cjs | grep -E '\\.(js|cjs)$' >> BUNDLE_SIZES.md\n+          echo \"\\`\\`\\`\" >> BUNDLE_SIZES.md\n+\n+      - name: 📤 Upload build artifacts\n+        uses: actions/upload-artifact@v4\n+        with:\n+          name: release-build-${{ steps.version.outputs.version }}\n+          path: |\n+            dist/\n+            RELEASE_CHANGELOG.md\n+            BUNDLE_SIZES.md\n+          retention-days: 30\n+\n+  # ===== SMART PUBLISHING =====\n+  publish-packages:\n+    runs-on: ubuntu-latest\n+    needs: prepare-release\n+    if: ${{ inputs.target_registry == 'npm' || inputs.target_registry == 'both' }}\n+    \n+    steps:\n+      - name: 📥 Checkout code\n+        uses: actions/checkout@v4\n+\n+      - name: 📦 Setup Node.js for NPM\n+        uses: actions/setup-node@v4\n+        with:\n+          node-version: ${{ env.NODE_VERSION }}\n+          cache: 'npm'\n+          registry-url: 'https://registry.npmjs.org'\n+\n+      - name: 📥 Download build artifacts\n+        uses: actions/download-artifact@v4\n+        with:\n+          name: release-build-${{ needs.prepare-release.outputs.version }}\n+\n+      - name: 🔄 Update package version\n+        run: npm version ${{ needs.prepare-release.outputs.version }} --no-git-tag-version\n+\n+      - name: 🚀 Publish to NPM\n+        run: |\n+          if [ \"${{ needs.prepare-release.outputs.is_prerelease }}\" == \"true\" ]; then\n+            echo \"📦 Publishing prerelease to NPM with tag: ${{ needs.prepare-release.outputs.release_channel }}\"\n+            npm publish --access public --tag ${{ needs.prepare-release.outputs.release_channel }}\n+          else\n+            echo \"📦 Publishing stable release to NPM\"\n+            npm publish --access public\n+          fi\n+        env:\n+          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}\n+\n+  publish-github:\n+    runs-on: ubuntu-latest\n+    needs: prepare-release\n+    if: ${{ inputs.target_registry == 'github' || inputs.target_registry == 'both' }}\n+    \n+    steps:\n+      - name: 📥 Checkout code\n+        uses: actions/checkout@v4\n+\n+      - name: 📦 Setup Node.js for GitHub Packages\n+        uses: actions/setup-node@v4\n+        with:\n+          node-version: ${{ env.NODE_VERSION }}\n+          cache: 'npm'\n+          registry-url: 'https://npm.pkg.github.com'\n+\n+      - name: 📥 Download build artifacts\n+        uses: actions/download-artifact@v4\n+        with:\n+          name: release-build-${{ needs.prepare-release.outputs.version }}\n+\n+      - name: 🔄 Update package version\n+        run: npm version ${{ needs.prepare-release.outputs.version }} --no-git-tag-version\n+\n+      - name: 📦 Publish to GitHub Packages\n+        run: |\n+          if [ \"${{ needs.prepare-release.outputs.is_prerelease }}\" == \"true\" ]; then\n+            echo \"📦 Publishing prerelease to GitHub Packages with tag: ${{ needs.prepare-release.outputs.release_channel }}\"\n+            npm publish --access public --tag ${{ needs.prepare-release.outputs.release_channel }}\n+          else\n+            echo \"📦 Publishing stable release to GitHub Packages\" \n+            npm publish --access public\n+          fi\n+        env:\n+          NODE_AUTH_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n+\n+  # ===== GITHUB RELEASE =====\n+  create-github-release:\n+    runs-on: ubuntu-latest\n+    needs: [prepare-release, publish-packages, publish-github]\n+    if: always() && needs.prepare-release.result == 'success'\n+    \n+    permissions:\n+      contents: write\n+      id-token: write\n+    \n+    steps:\n+      - name: 📥 Checkout code  \n+        uses: actions/checkout@v4\n+        with:\n+          fetch-depth: 0\n+          token: ${{ secrets.GITHUB_TOKEN }}\n+\n+      - name: 📥 Download build artifacts\n+        uses: actions/download-artifact@v4\n+        with:\n+          name: release-build-${{ needs.prepare-release.outputs.version }}\n+\n+      - name: 📦 Create release archives\n+        run: |\n+          VERSION=${{ needs.prepare-release.outputs.version }}\n+          \n+          # Crear archivos de distribución\n+          tar -czf better-logger-${VERSION}.tar.gz dist/ docs/ README.md package.json\n+          zip -r better-logger-${VERSION}.zip dist/ docs/ README.md package.json\n+          \n+          # Crear paquetes modulares\n+          cd dist\n+          tar -czf ../better-logger-core-${VERSION}.tar.gz core.* types/core.d.ts 2>/dev/null || true\n+          tar -czf ../better-logger-styling-${VERSION}.tar.gz styling.* types/styling.d.ts 2>/dev/null || true\n+          tar -czf ../better-logger-exports-${VERSION}.tar.gz exports.* types/exports.d.ts 2>/dev/null || true\n+          cd ..\n+\n+      - name: 🏷️ Commit and tag\n+        run: |\n+          git config user.name \"github-actions[bot]\"\n+          git config user.email \"github-actions[bot]@users.noreply.github.com\"\n+          git add package.json\n+          git commit -m \"chore: release ${{ needs.prepare-release.outputs.version }}\" || true\n+          git tag -a \"${{ needs.prepare-release.outputs.tag }}\" -m \"Release ${{ needs.prepare-release.outputs.version }}\"\n+          git push origin main --tags\n+\n+      - name: 📝 Prepare release notes\n+        run: |\n+          VERSION=${{ needs.prepare-release.outputs.version }}\n+          CHANGELOG=$(echo \"${{ needs.prepare-release.outputs.changelog }}\" | base64 -d)\n+          \n+          echo \"# Better Logger ${VERSION}\" > FINAL_RELEASE_NOTES.md\n+          echo \"\" >> FINAL_RELEASE_NOTES.md\n+          \n+          if [ \"${{ needs.prepare-release.outputs.is_prerelease }}\" == \"true\" ]; then\n+            echo \"⚠️ **This is a pre-release version** - Not recommended for production use.\" >> FINAL_RELEASE_NOTES.md\n+            echo \"\" >> FINAL_RELEASE_NOTES.md\n+          fi\n+          \n+          echo \"## 🔄 Changes\" >> FINAL_RELEASE_NOTES.md\n+          echo \"$CHANGELOG\" >> FINAL_RELEASE_NOTES.md\n+          echo \"\" >> FINAL_RELEASE_NOTES.md\n+          \n+          cat BUNDLE_SIZES.md >> FINAL_RELEASE_NOTES.md\n+          echo \"\" >> FINAL_RELEASE_NOTES.md\n+          \n+          echo \"## 📦 Installation\" >> FINAL_RELEASE_NOTES.md\n+          if [ \"${{ needs.prepare-release.outputs.is_prerelease }}\" == \"true\" ]; then\n+            echo \"\\`\\`\\`bash\" >> FINAL_RELEASE_NOTES.md\n+            echo \"npm install @mks2508/better-logger@${{ needs.prepare-release.outputs.release_channel }}\" >> FINAL_RELEASE_NOTES.md\n+            echo \"\\`\\`\\`\" >> FINAL_RELEASE_NOTES.md\n+          else\n+            echo \"\\`\\`\\`bash\" >> FINAL_RELEASE_NOTES.md  \n+            echo \"npm install @mks2508/better-logger\" >> FINAL_RELEASE_NOTES.md\n+            echo \"\\`\\`\\`\" >> FINAL_RELEASE_NOTES.md\n+          fi\n+\n+      - name: 🚀 Create GitHub Release\n+        uses: softprops/action-gh-release@v1\n+        with:\n+          tag_name: ${{ needs.prepare-release.outputs.tag }}\n+          name: Better Logger ${{ needs.prepare-release.outputs.version }}\n+          body_path: FINAL_RELEASE_NOTES.md\n+          draft: false\n+          prerelease: ${{ needs.prepare-release.outputs.is_prerelease == 'true' }}\n+          files: |\n+            better-logger-${{ needs.prepare-release.outputs.version }}.tar.gz\n+            better-logger-${{ needs.prepare-release.outputs.version }}.zip\n+            better-logger-core-${{ needs.prepare-release.outputs.version }}.tar.gz\n+            better-logger-styling-${{ needs.prepare-release.outputs.version }}.tar.gz  \n+            better-logger-exports-${{ needs.prepare-release.outputs.version }}.tar.gz\n+        env:\n+          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n+\n+  # ===== POST-RELEASE SUMMARY =====\n+  release-summary:\n+    runs-on: ubuntu-latest\n+    needs: [prepare-release, publish-packages, publish-github, create-github-release]\n+    if: always() && needs.prepare-release.result == 'success'\n+    \n+    steps:\n+      - name: 📊 Release Summary  \n+        run: |\n+          VERSION=\"${{ needs.prepare-release.outputs.version }}\"\n+          TAG=\"${{ needs.prepare-release.outputs.tag }}\"\n+          CHANNEL=\"${{ needs.prepare-release.outputs.release_channel }}\"\n+          IS_PRERELEASE=\"${{ needs.prepare-release.outputs.is_prerelease }}\"\n+          \n+          echo \"## 🎉 Release Complete!\" >> $GITHUB_STEP_SUMMARY\n+          echo \"- **Version**: $VERSION\" >> $GITHUB_STEP_SUMMARY\n+          echo \"- **Channel**: $CHANNEL\" >> $GITHUB_STEP_SUMMARY\n+          echo \"- **Prerelease**: $IS_PRERELEASE\" >> $GITHUB_STEP_SUMMARY\n+          echo \"\" >> $GITHUB_STEP_SUMMARY\n+          \n+          echo \"### 🔗 Links\" >> $GITHUB_STEP_SUMMARY\n+          if [ \"${{ inputs.target_registry == 'npm' || inputs.target_registry == 'both' }}\" ]; then\n+            echo \"- **NPM**: https://www.npmjs.com/package/@mks2508/better-logger\" >> $GITHUB_STEP_SUMMARY\n+          fi\n+          if [ \"${{ inputs.target_registry == 'github' || inputs.target_registry == 'both' }}\" ]; then\n+            echo \"- **GitHub Packages**: https://github.com/MKS2508/advanced-logger/packages/\" >> $GITHUB_STEP_SUMMARY  \n+          fi\n+          echo \"- **GitHub Release**: https://github.com/MKS2508/advanced-logger/releases/tag/$TAG\" >> $GITHUB_STEP_SUMMARY\n+          echo \"- **Documentation**: https://mks2508.github.io/advanced-logger/\" >> $GITHUB_STEP_SUMMARY\n+          echo \"\" >> $GITHUB_STEP_SUMMARY\n+          \n+          echo \"### 📦 Installation\" >> $GITHUB_STEP_SUMMARY\n+          echo \"\\`\\`\\`bash\" >> $GITHUB_STEP_SUMMARY\n+          if [ \"$IS_PRERELEASE\" == \"true\" ]; then\n+            echo \"npm install @mks2508/better-logger@$CHANNEL\" >> $GITHUB_STEP_SUMMARY\n+          else  \n+            echo \"npm install @mks2508/better-logger\" >> $GITHUB_STEP_SUMMARY\n+          fi\n+          echo \"\\`\\`\\`\" >> $GITHUB_STEP_SUMMARY\n\\ No newline at end of file",
      "lines_added": 373,
      "lines_removed": 0,
      "is_binary": false
    },
    {
      "path": ".github/workflows/release.yml -> .github/workflows-backup/release.yml",
      "status": "renamed",
      "diff": ""
    },
    {
      "path": ".github/workflows/ci-quality.yml",
      "status": "added",
      "diff": "diff --git a/.github/workflows/ci-quality.yml b/.github/workflows/ci-quality.yml\nnew file mode 100644\nindex 0000000..5974ff0\n--- /dev/null\n+++ b/.github/workflows/ci-quality.yml\n@@ -0,0 +1,357 @@\n+name: CI Quality & Testing\n+\n+on:\n+  push:\n+    branches: [ main, develop ]\n+  pull_request:\n+    branches: [ main, develop ]\n+  workflow_dispatch:\n+    inputs:\n+      run_performance:\n+        description: 'Ejecutar tests de performance'\n+        required: false\n+        default: true\n+        type: boolean\n+      run_visual:\n+        description: 'Ejecutar tests visuales'\n+        required: false\n+        default: false\n+        type: boolean\n+\n+env:\n+  NODE_VERSION: '20'\n+\n+jobs:\n+  # ===== MATRIX TESTING =====\n+  test-matrix:\n+    runs-on: ubuntu-latest\n+    \n+    strategy:\n+      fail-fast: false\n+      matrix:\n+        node-version: [18, 20, 21]\n+        build-mode: [full, core, styling, exports]\n+    \n+    name: Test Node ${{ matrix.node-version }} - ${{ matrix.build-mode }}\n+    \n+    steps:\n+      - name: 📥 Checkout code\n+        uses: actions/checkout@v4\n+        with:\n+          fetch-depth: 0\n+\n+      - name: 📦 Setup Node.js ${{ matrix.node-version }}\n+        uses: actions/setup-node@v4\n+        with:\n+          node-version: ${{ matrix.node-version }}\n+          cache: 'npm'\n+\n+      - name: 🔧 Install dependencies\n+        run: npm run ci:install\n+\n+      - name: 🔍 Type checking\n+        run: npm run type-check\n+\n+      - name: 🏗️ Build ${{ matrix.build-mode }}\n+        run: |\n+          if [ \"${{ matrix.build-mode }}\" = \"full\" ]; then\n+            npm run build:all\n+          else\n+            npm run build:${{ matrix.build-mode }}\n+          fi\n+\n+      - name: 🧪 Run tests\n+        run: npm run ci:test\n+\n+      - name: 📊 Check bundle sizes\n+        run: npm run size-limit\n+\n+      - name: 📤 Upload build artifacts (Node 20 only)\n+        uses: actions/upload-artifact@v4\n+        if: matrix.node-version == 20\n+        with:\n+          name: build-${{ matrix.build-mode }}-node${{ matrix.node-version }}\n+          path: dist/\n+          retention-days: 7\n+\n+  # ===== PERFORMANCE TESTING =====\n+  performance-tests:\n+    runs-on: ubuntu-latest\n+    needs: test-matrix\n+    if: ${{ inputs.run_performance != false }}\n+    \n+    steps:\n+      - name: 📥 Checkout code\n+        uses: actions/checkout@v4\n+\n+      - name: 📦 Setup Node.js\n+        uses: actions/setup-node@v4\n+        with:\n+          node-version: ${{ env.NODE_VERSION }}\n+          cache: 'npm'\n+\n+      - name: 🔧 Install dependencies\n+        run: npm run ci:install\n+\n+      - name: 📥 Download build artifacts\n+        uses: actions/download-artifact@v4\n+        with:\n+          name: build-full-node20\n+          path: dist/\n+\n+      - name: ⚡ Performance benchmarks\n+        run: npm run test:performance\n+\n+      - name: 📊 Bundle analysis\n+        run: |\n+          echo \"## 📦 Bundle Analysis Report\" > performance-report.md\n+          echo \"### Size Breakdown\" >> performance-report.md\n+          echo \"\\`\\`\\`\" >> performance-report.md\n+          ls -la dist/ >> performance-report.md\n+          echo \"\\`\\`\\`\" >> performance-report.md\n+          \n+          echo \"### File Sizes by Module\" >> performance-report.md\n+          for module in core styling exports; do\n+            if [ -d \"dist/modular/$module\" ]; then\n+              echo \"#### $module Module\" >> performance-report.md\n+              echo \"\\`\\`\\`\" >> performance-report.md\n+              ls -la dist/modular/$module/ >> performance-report.md\n+              echo \"\\`\\`\\`\" >> performance-report.md\n+            fi\n+          done\n+          \n+          echo \"### Performance Metrics\" >> performance-report.md\n+          echo \"- **Build Time**: $(date)\" >> performance-report.md\n+          echo \"- **Node Version**: ${{ env.NODE_VERSION }}\" >> performance-report.md\n+\n+      - name: 📤 Upload performance report\n+        uses: actions/upload-artifact@v4\n+        with:\n+          name: performance-report\n+          path: performance-report.md\n+          retention-days: 30\n+\n+  # ===== VISUAL TESTING =====\n+  visual-tests:\n+    runs-on: ubuntu-latest\n+    needs: test-matrix\n+    if: ${{ inputs.run_visual == true }}\n+    \n+    steps:\n+      - name: 📥 Checkout code\n+        uses: actions/checkout@v4\n+\n+      - name: 📦 Setup Node.js\n+        uses: actions/setup-node@v4\n+        with:\n+          node-version: ${{ env.NODE_VERSION }}\n+          cache: 'npm'\n+\n+      - name: 🔧 Install dependencies\n+        run: npm run ci:install\n+\n+      - name: 📥 Download build artifacts\n+        uses: actions/download-artifact@v4\n+        with:\n+          name: build-full-node20\n+          path: dist/\n+\n+      - name: 🎭 Install Playwright\n+        run: npx playwright install --with-deps chromium\n+\n+      - name: 🖼️ Run visual tests\n+        run: npm run test:visual\n+\n+      - name: 📤 Upload test results\n+        uses: actions/upload-artifact@v4\n+        if: always()\n+        with:\n+          name: visual-test-results\n+          path: test-results/\n+          retention-days: 30\n+\n+      - name: 📤 Upload screenshots\n+        uses: actions/upload-artifact@v4\n+        if: failure()\n+        with:\n+          name: visual-test-failures\n+          path: test-results/\n+          retention-days: 30\n+\n+  # ===== SECURITY AUDIT =====\n+  security-audit:\n+    runs-on: ubuntu-latest\n+    \n+    steps:\n+      - name: 📥 Checkout code\n+        uses: actions/checkout@v4\n+\n+      - name: 📦 Setup Node.js\n+        uses: actions/setup-node@v4\n+        with:\n+          node-version: ${{ env.NODE_VERSION }}\n+          cache: 'npm'\n+\n+      - name: 🔒 Security audit\n+        run: |\n+          echo \"🔒 Running security audit...\"\n+          npm audit --audit-level=high || echo \"Security issues detected, review required\"\n+\n+      - name: 📊 Check for outdated packages\n+        run: |\n+          echo \"📊 Checking for outdated packages...\"\n+          npm outdated || true\n+\n+      - name: 🔍 Vulnerability report\n+        run: |\n+          echo \"## 🔒 Security Audit Report\" > security-report.md\n+          echo \"### NPM Audit Results\" >> security-report.md\n+          echo \"\\`\\`\\`\" >> security-report.md\n+          npm audit --audit-level=moderate >> security-report.md || echo \"No critical vulnerabilities\" >> security-report.md\n+          echo \"\\`\\`\\`\" >> security-report.md\n+          \n+          echo \"### Outdated Packages\" >> security-report.md\n+          echo \"\\`\\`\\`\" >> security-report.md\n+          npm outdated >> security-report.md || echo \"All packages up to date\" >> security-report.md\n+          echo \"\\`\\`\\`\" >> security-report.md\n+\n+      - name: 📤 Upload security report\n+        uses: actions/upload-artifact@v4\n+        with:\n+          name: security-report\n+          path: security-report.md\n+          retention-days: 30\n+\n+  # ===== CODE QUALITY ANALYSIS =====\n+  code-quality:\n+    runs-on: ubuntu-latest\n+    needs: test-matrix\n+    \n+    steps:\n+      - name: 📥 Checkout code\n+        uses: actions/checkout@v4\n+\n+      - name: 📦 Setup Node.js\n+        uses: actions/setup-node@v4\n+        with:\n+          node-version: ${{ env.NODE_VERSION }}\n+          cache: 'npm'\n+\n+      - name: 🔧 Install dependencies\n+        run: npm run ci:install\n+\n+      - name: 🔍 Code analysis\n+        run: |\n+          echo \"🔍 Analyzing code quality...\"\n+          \n+          # Análisis básico de código\n+          echo \"## 📊 Code Quality Report\" > quality-report.md\n+          echo \"### TypeScript Analysis\" >> quality-report.md\n+          echo \"\\`\\`\\`\" >> quality-report.md\n+          npm run type-check >> quality-report.md 2>&1 || echo \"TypeScript issues detected\" >> quality-report.md\n+          echo \"\\`\\`\\`\" >> quality-report.md\n+          \n+          echo \"### File Statistics\" >> quality-report.md\n+          echo \"- **Total TypeScript files**: $(find src/ -name '*.ts' | wc -l)\" >> quality-report.md\n+          echo \"- **Total lines of code**: $(find src/ -name '*.ts' -exec wc -l {} + | tail -1 | awk '{print $1}')\" >> quality-report.md\n+          echo \"- **Build date**: $(date)\" >> quality-report.md\n+\n+      - name: 📤 Upload quality report\n+        uses: actions/upload-artifact@v4\n+        with:\n+          name: code-quality-report\n+          path: quality-report.md\n+          retention-days: 30\n+\n+  # ===== PROJECT UTILS VALIDATION =====\n+  validate-project-utils:\n+    runs-on: ubuntu-latest\n+    \n+    steps:\n+      - name: 📥 Checkout code\n+        uses: actions/checkout@v4\n+\n+      - name: 📦 Setup Node.js\n+        uses: actions/setup-node@v4\n+        with:\n+          node-version: ${{ env.NODE_VERSION }}\n+          cache: 'npm'\n+\n+      - name: 🔧 Install dependencies\n+        run: npm run ci:install\n+\n+      - name: 🧪 Test project-utils scripts\n+        run: |\n+          echo \"🧪 Validating project-utils scripts...\"\n+          \n+          # Verificar que los scripts existan y sean ejecutables\n+          SCRIPTS=(\"commit-generator.ts\" \"version-manager.ts\" \"github-release-manager.ts\" \"auto-release-gemini.ts\")\n+          \n+          for script in \"${SCRIPTS[@]}\"; do\n+            if [ -f \"project-utils/$script\" ]; then\n+              echo \"✅ $script exists\"\n+              # Verificar sintaxis básica\n+              node --check \"project-utils/$script\" && echo \"✅ $script syntax OK\" || echo \"❌ $script syntax error\"\n+            else\n+              echo \"❌ $script missing\"\n+            fi\n+          done\n+\n+      - name: 📊 Validate package.json scripts\n+        run: |\n+          echo \"📊 Validating package.json scripts...\"\n+          \n+          # Verificar scripts críticos\n+          CRITICAL_SCRIPTS=(\"build\" \"build:all\" \"commit:auto\" \"version:auto\" \"workflow:full\")\n+          \n+          for script in \"${CRITICAL_SCRIPTS[@]}\"; do\n+            if npm run --silent \"$script\" --help >/dev/null 2>&1; then\n+              echo \"✅ Script '$script' is valid\"\n+            else\n+              echo \"❌ Script '$script' has issues\"\n+            fi\n+          done\n+\n+  # ===== COMPREHENSIVE SUMMARY =====\n+  ci-summary:\n+    runs-on: ubuntu-latest\n+    needs: [test-matrix, performance-tests, visual-tests, security-audit, code-quality, validate-project-utils]\n+    if: always()\n+    \n+    steps:\n+      - name: 📊 CI Quality Summary\n+        run: |\n+          echo \"## 📊 CI Quality & Testing Summary\" >> $GITHUB_STEP_SUMMARY\n+          echo \"\" >> $GITHUB_STEP_SUMMARY\n+          \n+          # Status de cada job\n+          echo \"### 🧪 Test Results\" >> $GITHUB_STEP_SUMMARY\n+          echo \"- **Matrix Testing**: ${{ needs.test-matrix.result }}\" >> $GITHUB_STEP_SUMMARY\n+          echo \"- **Performance Tests**: ${{ needs.performance-tests.result }}\" >> $GITHUB_STEP_SUMMARY\n+          echo \"- **Visual Tests**: ${{ needs.visual-tests.result }}\" >> $GITHUB_STEP_SUMMARY\n+          echo \"- **Security Audit**: ${{ needs.security-audit.result }}\" >> $GITHUB_STEP_SUMMARY\n+          echo \"- **Code Quality**: ${{ needs.code-quality.result }}\" >> $GITHUB_STEP_SUMMARY\n+          echo \"- **Project Utils**: ${{ needs.validate-project-utils.result }}\" >> $GITHUB_STEP_SUMMARY\n+          echo \"\" >> $GITHUB_STEP_SUMMARY\n+          \n+          echo \"### 📋 Coverage Matrix\" >> $GITHUB_STEP_SUMMARY\n+          echo \"- **Node Versions**: 18, 20, 21\" >> $GITHUB_STEP_SUMMARY\n+          echo \"- **Build Modes**: full, core, styling, exports\" >> $GITHUB_STEP_SUMMARY\n+          echo \"- **Test Types**: unit, performance, visual, security\" >> $GITHUB_STEP_SUMMARY\n+          echo \"\" >> $GITHUB_STEP_SUMMARY\n+          \n+          # Determinar estado general\n+          if [ \"${{ needs.test-matrix.result }}\" = \"success\" ] && [ \"${{ needs.security-audit.result }}\" = \"success\" ] && [ \"${{ needs.code-quality.result }}\" = \"success\" ]; then\n+            echo \"### ✅ Overall Status: PASSED\" >> $GITHUB_STEP_SUMMARY\n+            echo \"All critical quality checks passed successfully.\" >> $GITHUB_STEP_SUMMARY\n+          else\n+            echo \"### ⚠️ Overall Status: ATTENTION REQUIRED\" >> $GITHUB_STEP_SUMMARY\n+            echo \"Some quality checks require attention. Review individual job results.\" >> $GITHUB_STEP_SUMMARY\n+          fi\n+          \n+          echo \"\" >> $GITHUB_STEP_SUMMARY\n+          echo \"### 📎 Artifacts Generated\" >> $GITHUB_STEP_SUMMARY\n+          echo \"- Build artifacts for all modules\" >> $GITHUB_STEP_SUMMARY\n+          echo \"- Performance analysis report\" >> $GITHUB_STEP_SUMMARY\n+          echo \"- Security audit report\" >> $GITHUB_STEP_SUMMARY\n+          echo \"- Code quality metrics\" >> $GITHUB_STEP_SUMMARY\n\\ No newline at end of file",
      "lines_added": 357,
      "lines_removed": 0,
      "is_binary": false
    },
    {
      "path": ".github/workflows/docs-demo.yml",
      "status": "added",
      "diff": "diff --git a/.github/workflows/docs-demo.yml b/.github/workflows/docs-demo.yml\nnew file mode 100644\nindex 0000000..f7c4cd3\n--- /dev/null\n+++ b/.github/workflows/docs-demo.yml\n@@ -0,0 +1,125 @@\n+name: Docs & Demo Deployment\n+\n+on:\n+  push:\n+    branches: [ main ]\n+    paths: \n+      - 'docs/**'\n+      - 'demo.html'\n+      - 'index.html'\n+      - 'src/**'\n+  workflow_dispatch:\n+\n+env:\n+  NODE_VERSION: '20'\n+\n+jobs:\n+  # ===== BUILD DEMO =====\n+  build-demo:\n+    runs-on: ubuntu-latest\n+    \n+    steps:\n+      - name: 📥 Checkout code\n+        uses: actions/checkout@v4\n+\n+      - name: 📦 Setup Node.js\n+        uses: actions/setup-node@v4\n+        with:\n+          node-version: ${{ env.NODE_VERSION }}\n+          cache: 'npm'\n+\n+      - name: 🔧 Install dependencies\n+        run: npm run ci:install\n+\n+      - name: 🏗️ Build library for demo\n+        run: npm run build:full\n+\n+      - name: 🏗️ Setup demo structure\n+        run: |\n+          mkdir -p _site/docs\n+          # Copy demo as root\n+          cp demo.html _site/index.html\n+          cp index.html _site/dev.html\n+          cp -r dist/ _site/dist/\n+          \n+          # Create demo metadata\n+          echo \"## 📦 Demo Build Info\" > _site/build-info.md\n+          echo \"- **Build Date**: $(date)\" >> _site/build-info.md\n+          echo \"- **Commit**: ${{ github.sha }}\" >> _site/build-info.md\n+          echo \"- **Version**: $(node -p 'require(\"./package.json\").version')\" >> _site/build-info.md\n+\n+      - name: 📤 Upload demo artifacts\n+        uses: actions/upload-artifact@v4\n+        with:\n+          name: demo-site\n+          path: _site/\n+          retention-days: 30\n+\n+  # ===== BUILD DOCS =====\n+  build-docs:\n+    runs-on: ubuntu-latest\n+    \n+    steps:\n+      - name: 📥 Checkout code\n+        uses: actions/checkout@v4\n+\n+      - name: 📤 Build Jekyll documentation\n+        uses: actions/jekyll-build-pages@v1\n+        with:\n+          source: ./docs\n+          destination: ./_site/docs\n+\n+      - name: 📤 Upload docs artifacts\n+        uses: actions/upload-artifact@v4\n+        with:\n+          name: docs-site\n+          path: _site/docs/\n+          retention-days: 30\n+\n+  # ===== DEPLOY TO GITHUB PAGES =====\n+  deploy-pages:\n+    runs-on: ubuntu-latest\n+    needs: [build-demo, build-docs]\n+    if: github.ref == 'refs/heads/main'\n+    \n+    permissions:\n+      contents: read\n+      pages: write\n+      id-token: write\n+    \n+    environment:\n+      name: github-pages\n+      url: ${{ steps.deployment.outputs.page_url }}\n+    \n+    steps:\n+      - name: 📥 Download demo artifacts\n+        uses: actions/download-artifact@v4\n+        with:\n+          name: demo-site\n+          path: _site/\n+\n+      - name: 📥 Download docs artifacts\n+        uses: actions/download-artifact@v4\n+        with:\n+          name: docs-site\n+          path: _site/docs/\n+\n+      - name: 📤 Setup Pages\n+        uses: actions/configure-pages@v4\n+\n+      - name: 📤 Upload to Pages\n+        uses: actions/upload-pages-artifact@v3\n+        with:\n+          path: ./_site\n+\n+      - name: 🚀 Deploy to GitHub Pages\n+        id: deployment\n+        uses: actions/deploy-pages@v4\n+\n+      - name: 📊 Deployment summary\n+        run: |\n+          echo \"## 📝 Documentation & Demo Deployed!\" >> $GITHUB_STEP_SUMMARY\n+          echo \"- **Demo URL**: ${{ steps.deployment.outputs.page_url }}\" >> $GITHUB_STEP_SUMMARY  \n+          echo \"- **Docs URL**: ${{ steps.deployment.outputs.page_url }}docs/\" >> $GITHUB_STEP_SUMMARY\n+          echo \"- **Dev Demo**: ${{ steps.deployment.outputs.page_url }}dev.html\" >> $GITHUB_STEP_SUMMARY\n+          echo \"- **Build Info**: ${{ steps.deployment.outputs.page_url }}build-info.md\" >> $GITHUB_STEP_SUMMARY\n\\ No newline at end of file",
      "lines_added": 125,
      "lines_removed": 0,
      "is_binary": false
    },
    {
      "path": ".github/workflows/nightly-auto.yml",
      "status": "added",
      "diff": "diff --git a/.github/workflows/nightly-auto.yml b/.github/workflows/nightly-auto.yml\nnew file mode 100644\nindex 0000000..c936f3d\n--- /dev/null\n+++ b/.github/workflows/nightly-auto.yml\n@@ -0,0 +1,335 @@\n+name: Nightly Builds with Smart Detection\n+\n+on:\n+  schedule:\n+    # Ejecutar cada día a las 3:00 AM UTC\n+    - cron: '0 3 * * *'\n+  workflow_dispatch:\n+    inputs:\n+      force_build:\n+        description: 'Forzar build aunque no haya cambios'\n+        required: false\n+        default: false\n+        type: boolean\n+      include_prereleases:\n+        description: 'Incluir cambios de prereleases en detección'\n+        required: false\n+        default: false\n+        type: boolean\n+\n+env:\n+  NODE_VERSION: '20'\n+\n+jobs:\n+  # ===== SMART CHANGE DETECTION =====\n+  detect-changes:\n+    runs-on: ubuntu-latest\n+    outputs:\n+      has_changes: ${{ steps.changes.outputs.has_changes }}\n+      change_type: ${{ steps.changes.outputs.change_type }}\n+      last_commit: ${{ steps.changes.outputs.last_commit }}\n+      commit_count: ${{ steps.changes.outputs.commit_count }}\n+      significant_changes: ${{ steps.changes.outputs.significant_changes }}\n+      files_changed: ${{ steps.changes.outputs.files_changed }}\n+    \n+    steps:\n+      - name: 📥 Checkout code\n+        uses: actions/checkout@v4\n+        with:\n+          fetch-depth: 0\n+\n+      - name: 🔍 Analyze changes since last nightly\n+        id: changes\n+        run: |\n+          # Buscar último tag nightly\n+          LAST_NIGHTLY=$(git tag -l \"nightly-*\" | sort -V | tail -1 || echo \"\")\n+          LAST_RELEASE=$(git tag -l \"v*\" --exclude=\"nightly-*\" --exclude=\"*alpha*\" --exclude=\"*beta*\" | sort -V | tail -1 || echo \"\")\n+          \n+          if [ -z \"$LAST_NIGHTLY\" ] && [ -z \"$LAST_RELEASE\" ]; then\n+            # No hay tags previos, verificar desde hace 24 horas\n+            SINCE_DATE=$(date -d '24 hours ago' --iso-8601)\n+            COMMITS_COUNT=$(git log --since=\"$SINCE_DATE\" --oneline | wc -l)\n+            REFERENCE_POINT=\"24 hours ago\"\n+          elif [ -n \"$LAST_NIGHTLY\" ] && [ -z \"$LAST_RELEASE\" ]; then\n+            # Solo hay nightlies\n+            COMMITS_COUNT=$(git log $LAST_NIGHTLY..HEAD --oneline | wc -l)\n+            REFERENCE_POINT=$LAST_NIGHTLY\n+          elif [ -z \"$LAST_NIGHTLY\" ] && [ -n \"$LAST_RELEASE\" ]; then\n+            # Solo hay releases normales\n+            COMMITS_COUNT=$(git log $LAST_RELEASE..HEAD --oneline | wc -l)\n+            REFERENCE_POINT=$LAST_RELEASE\n+          else\n+            # Hay ambos, usar el más reciente\n+            LAST_NIGHTLY_DATE=$(git log -1 --format=%ct $LAST_NIGHTLY)\n+            LAST_RELEASE_DATE=$(git log -1 --format=%ct $LAST_RELEASE)\n+            \n+            if [ \"$LAST_NIGHTLY_DATE\" -gt \"$LAST_RELEASE_DATE\" ]; then\n+              COMMITS_COUNT=$(git log $LAST_NIGHTLY..HEAD --oneline | wc -l)\n+              REFERENCE_POINT=$LAST_NIGHTLY\n+            else\n+              COMMITS_COUNT=$(git log $LAST_RELEASE..HEAD --oneline | wc -l)\n+              REFERENCE_POINT=$LAST_RELEASE\n+            fi\n+          fi\n+          \n+          LAST_COMMIT=$(git rev-parse --short HEAD)\n+          \n+          echo \"commit_count=$COMMITS_COUNT\" >> $GITHUB_OUTPUT\n+          echo \"last_commit=$LAST_COMMIT\" >> $GITHUB_OUTPUT\n+          \n+          # Análisis inteligente de cambios\n+          SIGNIFICANT_CHANGES=\"false\"\n+          CHANGE_TYPE=\"maintenance\"\n+          \n+          if [ \"$COMMITS_COUNT\" -gt 0 ]; then\n+            # Analizar tipos de cambios desde el punto de referencia\n+            if [ \"$REFERENCE_POINT\" != \"24 hours ago\" ]; then\n+              CHANGES_LOG=$(git log $REFERENCE_POINT..HEAD --pretty=format:\"%s\" --no-merges)\n+            else\n+              CHANGES_LOG=$(git log --since=\"24 hours ago\" --pretty=format:\"%s\" --no-merges)\n+            fi\n+            \n+            # Detectar cambios significativos\n+            if echo \"$CHANGES_LOG\" | grep -qE \"(feat|feature|add|new)\"; then\n+              SIGNIFICANT_CHANGES=\"true\"\n+              CHANGE_TYPE=\"feature\"\n+            elif echo \"$CHANGES_LOG\" | grep -qE \"(fix|bug|repair|patch)\"; then\n+              SIGNIFICANT_CHANGES=\"true\" \n+              CHANGE_TYPE=\"bugfix\"\n+            elif echo \"$CHANGES_LOG\" | grep -qE \"(perf|performance|optim|speed)\"; then\n+              SIGNIFICANT_CHANGES=\"true\"\n+              CHANGE_TYPE=\"performance\"\n+            elif echo \"$CHANGES_LOG\" | grep -qE \"(refactor|restructure|rewrite)\"; then\n+              CHANGE_TYPE=\"refactor\"\n+            elif echo \"$CHANGES_LOG\" | grep -qE \"(docs|documentation|readme)\"; then\n+              CHANGE_TYPE=\"documentation\"\n+            fi\n+            \n+            # Analizar archivos modificados\n+            if [ \"$REFERENCE_POINT\" != \"24 hours ago\" ]; then\n+              FILES_CHANGED=$(git diff --name-only $REFERENCE_POINT..HEAD | wc -l)\n+            else\n+              FILES_CHANGED=$(git log --since=\"24 hours ago\" --name-only --pretty=format: | sort | uniq | wc -l)\n+            fi\n+          else\n+            FILES_CHANGED=0\n+          fi\n+          \n+          echo \"significant_changes=$SIGNIFICANT_CHANGES\" >> $GITHUB_OUTPUT\n+          echo \"change_type=$CHANGE_TYPE\" >> $GITHUB_OUTPUT\n+          echo \"files_changed=$FILES_CHANGED\" >> $GITHUB_OUTPUT\n+          \n+          # Determinar si hacer build\n+          if [ \"$COMMITS_COUNT\" -gt 0 ] || [ \"${{ inputs.force_build }}\" == \"true\" ]; then\n+            echo \"has_changes=true\" >> $GITHUB_OUTPUT\n+            echo \"✅ Cambios detectados: $COMMITS_COUNT commits ($CHANGE_TYPE)\"\n+            echo \"📊 Archivos modificados: $FILES_CHANGED\"\n+            echo \"🔍 Desde: $REFERENCE_POINT\"\n+          else\n+            echo \"has_changes=false\" >> $GITHUB_OUTPUT  \n+            echo \"ℹ️ No hay cambios desde último build\"\n+          fi\n+\n+  # ===== INTELLIGENT NIGHTLY BUILD =====\n+  nightly-build:\n+    runs-on: ubuntu-latest\n+    needs: detect-changes\n+    if: needs.detect-changes.outputs.has_changes == 'true'\n+    \n+    permissions:\n+      contents: write\n+      packages: write\n+      id-token: write\n+    \n+    outputs:\n+      nightly_version: ${{ steps.version.outputs.version }}\n+      nightly_tag: ${{ steps.version.outputs.tag }}\n+    \n+    steps:\n+      - name: 📥 Checkout code\n+        uses: actions/checkout@v4\n+        with:\n+          fetch-depth: 0\n+          token: ${{ secrets.GITHUB_TOKEN }}\n+\n+      - name: 📦 Setup Node.js\n+        uses: actions/setup-node@v4\n+        with:\n+          node-version: ${{ env.NODE_VERSION }}\n+          cache: 'npm'\n+\n+      - name: 🔧 Install dependencies\n+        run: npm run ci:install\n+\n+      - name: 🏗️ Build library with quality checks\n+        run: |\n+          npm run build:all\n+          npm run type-check\n+          npm run ci:test\n+\n+      - name: 🏷️ Generate intelligent nightly version\n+        id: version\n+        run: |\n+          # Generar versión nightly inteligente\n+          DATE=$(date +%Y%m%d)\n+          TIME=$(date +%H%M)\n+          SHORT_SHA=\"${{ needs.detect-changes.outputs.last_commit }}\"\n+          BASE_VERSION=$(node -p \"require('./package.json').version\")\n+          CHANGE_TYPE=\"${{ needs.detect-changes.outputs.change_type }}\"\n+          \n+          # Remover cualquier sufijo existente del base version\n+          CLEAN_VERSION=$(echo $BASE_VERSION | sed 's/-.*//')\n+          \n+          # Crear versión con contexto inteligente\n+          if [ \"${{ needs.detect-changes.outputs.significant_changes }}\" == \"true\" ]; then\n+            NIGHTLY_VERSION=\"${CLEAN_VERSION}-nightly.${DATE}.${CHANGE_TYPE}.${SHORT_SHA}\"\n+          else\n+            NIGHTLY_VERSION=\"${CLEAN_VERSION}-nightly.${DATE}.${SHORT_SHA}\"\n+          fi\n+          \n+          NIGHTLY_TAG=\"nightly-${DATE}-${TIME}-${SHORT_SHA}\"\n+          \n+          echo \"version=$NIGHTLY_VERSION\" >> $GITHUB_OUTPUT\n+          echo \"tag=$NIGHTLY_TAG\" >> $GITHUB_OUTPUT\n+          echo \"🌙 Nightly version: $NIGHTLY_VERSION\"\n+          echo \"🏷️ Nightly tag: $NIGHTLY_TAG\"\n+\n+      - name: 📝 Update package for nightly\n+        run: |\n+          npm version ${{ steps.version.outputs.version }} --no-git-tag-version\n+\n+      - name: 📊 Generate build report\n+        run: |\n+          mkdir -p nightly-reports\n+          \n+          echo \"# Nightly Build Report\" > nightly-reports/build-report.md\n+          echo \"- **Version**: ${{ steps.version.outputs.version }}\" >> nightly-reports/build-report.md\n+          echo \"- **Build Date**: $(date)\" >> nightly-reports/build-report.md\n+          echo \"- **Commit**: ${{ needs.detect-changes.outputs.last_commit }}\" >> nightly-reports/build-report.md\n+          echo \"- **Commits Since Last**: ${{ needs.detect-changes.outputs.commit_count }}\" >> nightly-reports/build-report.md\n+          echo \"- **Files Changed**: ${{ needs.detect-changes.outputs.files_changed }}\" >> nightly-reports/build-report.md\n+          echo \"- **Change Type**: ${{ needs.detect-changes.outputs.change_type }}\" >> nightly-reports/build-report.md\n+          echo \"- **Significant Changes**: ${{ needs.detect-changes.outputs.significant_changes }}\" >> nightly-reports/build-report.md\n+          echo \"\" >> nightly-reports/build-report.md\n+          \n+          echo \"## Bundle Sizes\" >> nightly-reports/build-report.md\n+          echo \"\\`\\`\\`\" >> nightly-reports/build-report.md\n+          ls -lh dist/*.js dist/*.cjs 2>/dev/null | grep -E '\\.(js|cjs)$' >> nightly-reports/build-report.md\n+          echo \"\\`\\`\\`\" >> nightly-reports/build-report.md\n+\n+      - name: 📦 Create nightly archives  \n+        run: |\n+          mkdir -p nightly-dist\n+          VERSION=${{ steps.version.outputs.version }}\n+          TAG=${{ steps.version.outputs.tag }}\n+          \n+          # Archivos completos\n+          tar -czf nightly-dist/better-logger-nightly-${TAG}.tar.gz dist/ nightly-reports/ README.md package.json\n+          zip -r nightly-dist/better-logger-nightly-${TAG}.zip dist/ nightly-reports/ README.md package.json\n+          \n+          # Archivos modulares (si existen)\n+          for module in core styling exports; do\n+            if [ -d \"dist/modular/$module\" ]; then\n+              tar -czf nightly-dist/better-logger-${module}-nightly-${TAG}.tar.gz dist/modular/${module}/ README.md package.json\n+            fi\n+          done\n+\n+      - name: 🚀 Publish nightly to NPM\n+        run: |\n+          npm publish --tag nightly --access public\n+        env:\n+          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}\n+\n+      - name: 📦 Publish nightly to GitHub Packages  \n+        run: |\n+          echo \"//npm.pkg.github.com/:_authToken=${{ secrets.GITHUB_TOKEN }}\" >> ~/.npmrc\n+          echo \"@mks2508:registry=https://npm.pkg.github.com\" >> ~/.npmrc\n+          npm publish --registry=https://npm.pkg.github.com --tag nightly --access public\n+\n+      - name: 🏷️ Create nightly tag\n+        run: |\n+          git config user.name \"github-actions[bot]\"\n+          git config user.email \"github-actions[bot]@users.noreply.github.com\" \n+          git tag -a \"${{ steps.version.outputs.tag }}\" -m \"Nightly build ${{ steps.version.outputs.version }} (${{ needs.detect-changes.outputs.change_type }})\"\n+          git push origin \"${{ steps.version.outputs.tag }}\"\n+\n+      - name: 🌙 Create intelligent nightly release\n+        uses: softprops/action-gh-release@v1\n+        with:\n+          tag_name: ${{ steps.version.outputs.tag }}\n+          name: \"🌙 Nightly Build ${{ steps.version.outputs.version }}\"\n+          body: |\n+            🌙 **Nightly Build** - Experimental version for testing\n+            \n+            **⚠️ This is a development build - not recommended for production use**\n+            \n+            ## 📊 Build Analysis\n+            - **Change Type**: ${{ needs.detect-changes.outputs.change_type }}\n+            - **Significant Changes**: ${{ needs.detect-changes.outputs.significant_changes }}\n+            - **Commits**: ${{ needs.detect-changes.outputs.commit_count }}\n+            - **Files Modified**: ${{ needs.detect-changes.outputs.files_changed }}\n+            \n+            ## 🔄 What's Included\n+            ${{ needs.detect-changes.outputs.change_type == 'feature' && '✨ New features and enhancements' || '' }}\n+            ${{ needs.detect-changes.outputs.change_type == 'bugfix' && '🐛 Bug fixes and patches' || '' }}\n+            ${{ needs.detect-changes.outputs.change_type == 'performance' && '⚡ Performance improvements' || '' }}\n+            ${{ needs.detect-changes.outputs.change_type == 'refactor' && '🔧 Code refactoring and improvements' || '' }}\n+            ${{ needs.detect-changes.outputs.change_type == 'documentation' && '📝 Documentation updates' || '' }}\n+            ${{ needs.detect-changes.outputs.change_type == 'maintenance' && '🧹 Maintenance and minor updates' || '' }}\n+            \n+            ## 📦 Installation\n+            ```bash\n+            npm install @mks2508/better-logger@nightly\n+            ```\n+            \n+            ## 🔗 Links\n+            - **Commit**: https://github.com/MKS2508/advanced-logger/commit/${{ needs.detect-changes.outputs.last_commit }}\n+            - **NPM**: https://www.npmjs.com/package/@mks2508/better-logger/v/${{ steps.version.outputs.version }}\n+            \n+            ## ⏰ Auto-Generated\n+            This nightly build was automatically generated and published based on detected changes.\n+          draft: false\n+          prerelease: true\n+          files: |\n+            nightly-dist/better-logger-nightly-${{ steps.version.outputs.tag }}.tar.gz  \n+            nightly-dist/better-logger-nightly-${{ steps.version.outputs.tag }}.zip\n+            nightly-dist/better-logger-*-nightly-${{ steps.version.outputs.tag }}.tar.gz\n+            nightly-reports/build-report.md\n+        env:\n+          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n+\n+      - name: 📊 Nightly build summary\n+        run: |\n+          echo \"## 🌙 Intelligent Nightly Build Complete!\" >> $GITHUB_STEP_SUMMARY\n+          echo \"- **Version**: ${{ steps.version.outputs.version }}\" >> $GITHUB_STEP_SUMMARY\n+          echo \"- **Change Type**: ${{ needs.detect-changes.outputs.change_type }}\" >> $GITHUB_STEP_SUMMARY\n+          echo \"- **Significant**: ${{ needs.detect-changes.outputs.significant_changes }}\" >> $GITHUB_STEP_SUMMARY  \n+          echo \"- **Commits**: ${{ needs.detect-changes.outputs.commit_count }}\" >> $GITHUB_STEP_SUMMARY\n+          echo \"- **Files**: ${{ needs.detect-changes.outputs.files_changed }}\" >> $GITHUB_STEP_SUMMARY\n+          echo \"\" >> $GITHUB_STEP_SUMMARY\n+          echo \"### 🔗 Links\" >> $GITHUB_STEP_SUMMARY\n+          echo \"- **NPM**: https://www.npmjs.com/package/@mks2508/better-logger/v/${{ steps.version.outputs.version }}\" >> $GITHUB_STEP_SUMMARY\n+          echo \"- **GitHub**: https://github.com/MKS2508/advanced-logger/releases/tag/${{ steps.version.outputs.tag }}\" >> $GITHUB_STEP_SUMMARY\n+          echo \"\" >> $GITHUB_STEP_SUMMARY\n+          echo \"### 📦 Installation\" >> $GITHUB_STEP_SUMMARY\n+          echo \"\\`\\`\\`bash\" >> $GITHUB_STEP_SUMMARY  \n+          echo \"npm install @mks2508/better-logger@nightly\" >> $GITHUB_STEP_SUMMARY\n+          echo \"\\`\\`\\`\" >> $GITHUB_STEP_SUMMARY\n+\n+  # ===== NO CHANGES HANDLER =====\n+  no-changes:\n+    runs-on: ubuntu-latest\n+    needs: detect-changes\n+    if: needs.detect-changes.outputs.has_changes == 'false'\n+    \n+    steps:\n+      - name: ℹ️ No changes detected\n+        run: |\n+          echo \"## ℹ️ No Nightly Build Required\" >> $GITHUB_STEP_SUMMARY\n+          echo \"No significant changes detected since last nightly build.\" >> $GITHUB_STEP_SUMMARY\n+          echo \"\" >> $GITHUB_STEP_SUMMARY\n+          echo \"### 🔍 Analysis Results\" >> $GITHUB_STEP_SUMMARY\n+          echo \"- **Commits**: ${{ needs.detect-changes.outputs.commit_count }}\" >> $GITHUB_STEP_SUMMARY\n+          echo \"- **Files Changed**: ${{ needs.detect-changes.outputs.files_changed }}\" >> $GITHUB_STEP_SUMMARY\n+          echo \"\" >> $GITHUB_STEP_SUMMARY\n+          echo \"Use \\`workflow_dispatch\\` with \\`force_build: true\\` to force a build.\" >> $GITHUB_STEP_SUMMARY\n\\ No newline at end of file",
      "lines_added": 335,
      "lines_removed": 0,
      "is_binary": false
    },
    {
      "path": ".github/workflows/releases-core.yml",
      "status": "added",
      "diff": "diff --git a/.github/workflows/releases-core.yml b/.github/workflows/releases-core.yml\nnew file mode 100644\nindex 0000000..aa4b59c\n--- /dev/null\n+++ b/.github/workflows/releases-core.yml\n@@ -0,0 +1,378 @@\n+name: Core Modular Releases\n+\n+on:\n+  workflow_dispatch:\n+    inputs:\n+      module:\n+        description: 'Módulo a construir y publicar'\n+        required: true\n+        default: 'all'\n+        type: choice\n+        options:\n+          - all\n+          - core\n+          - styling\n+          - exports\n+          - full\n+      release_type:\n+        description: 'Tipo de release'\n+        required: true\n+        default: 'patch'\n+        type: choice\n+        options:\n+          - patch\n+          - minor\n+          - major\n+          - alpha\n+          - beta\n+      target_registry:\n+        description: 'Registro objetivo'\n+        required: false\n+        default: 'both'\n+        type: choice\n+        options:\n+          - npm\n+          - github\n+          - both\n+      skip_tests:\n+        description: 'Saltar tests (no recomendado)'\n+        required: false\n+        default: false\n+        type: boolean\n+\n+env:\n+  NODE_VERSION: '20'\n+\n+jobs:\n+  # ===== VALIDATION & VERSIONING =====\n+  prepare-modular-release:\n+    runs-on: ubuntu-latest\n+    \n+    outputs:\n+      version: ${{ steps.version.outputs.version }}\n+      tag: ${{ steps.version.outputs.tag }}\n+      is_prerelease: ${{ steps.version.outputs.is_prerelease }}\n+      release_channel: ${{ steps.version.outputs.release_channel }}\n+      modules_to_build: ${{ steps.modules.outputs.modules }}\n+    \n+    steps:\n+      - name: 📥 Checkout code\n+        uses: actions/checkout@v4\n+        with:\n+          fetch-depth: 0\n+          token: ${{ secrets.GITHUB_TOKEN }}\n+\n+      - name: 📦 Setup Node.js\n+        uses: actions/setup-node@v4\n+        with:\n+          node-version: ${{ env.NODE_VERSION }}\n+          cache: 'npm'\n+\n+      - name: 🔧 Install dependencies\n+        run: npm run ci:install\n+\n+      - name: 🧪 Run tests (unless skipped)\n+        if: ${{ !inputs.skip_tests }}\n+        run: |\n+          npm run type-check\n+          npm run ci:test\n+\n+      - name: 🏷️ Generate version\n+        id: version\n+        run: |\n+          npm run version:${{ inputs.release_type }}\n+          \n+          # Obtener nueva versión\n+          NEW_VERSION=$(node -p \"require('./package.json').version\")\n+          echo \"version=$NEW_VERSION\" >> $GITHUB_OUTPUT\n+          echo \"tag=v$NEW_VERSION\" >> $GITHUB_OUTPUT\n+          \n+          # Determinar si es prerelease y canal\n+          if [[ \"$NEW_VERSION\" == *\"alpha\"* ]]; then\n+            echo \"is_prerelease=true\" >> $GITHUB_OUTPUT\n+            echo \"release_channel=alpha\" >> $GITHUB_OUTPUT\n+          elif [[ \"$NEW_VERSION\" == *\"beta\"* ]]; then\n+            echo \"is_prerelease=true\" >> $GITHUB_OUTPUT  \n+            echo \"release_channel=beta\" >> $GITHUB_OUTPUT\n+          else\n+            echo \"is_prerelease=false\" >> $GITHUB_OUTPUT\n+            echo \"release_channel=latest\" >> $GITHUB_OUTPUT\n+          fi\n+          \n+          echo \"📦 Nueva versión: $NEW_VERSION\"\n+\n+      - name: 🧩 Determine modules to build\n+        id: modules\n+        run: |\n+          case \"${{ inputs.module }}\" in\n+            \"all\") \n+              MODULES='[\"core\", \"styling\", \"exports\", \"full\"]'\n+              ;;\n+            \"core\"|\"styling\"|\"exports\"|\"full\")\n+              MODULES='[\"${{ inputs.module }}\"]'\n+              ;;\n+          esac\n+          echo \"modules=$MODULES\" >> $GITHUB_OUTPUT\n+          echo \"📦 Módulos a construir: $MODULES\"\n+\n+  # ===== MODULAR BUILDS =====\n+  build-modules:\n+    runs-on: ubuntu-latest\n+    needs: prepare-modular-release\n+    \n+    strategy:\n+      matrix:\n+        module: ${{ fromJson(needs.prepare-modular-release.outputs.modules_to_build) }}\n+    \n+    steps:\n+      - name: 📥 Checkout code\n+        uses: actions/checkout@v4\n+\n+      - name: 📦 Setup Node.js\n+        uses: actions/setup-node@v4\n+        with:\n+          node-version: ${{ env.NODE_VERSION }}\n+          cache: 'npm'\n+\n+      - name: 🔧 Install dependencies\n+        run: npm run ci:install\n+\n+      - name: 🔄 Update package version\n+        run: npm version ${{ needs.prepare-modular-release.outputs.version }} --no-git-tag-version\n+\n+      - name: 🏗️ Build module ${{ matrix.module }}\n+        run: |\n+          if [ \"${{ matrix.module }}\" = \"full\" ]; then\n+            npm run build:full\n+          else\n+            npm run build:${{ matrix.module }}\n+          fi\n+\n+      - name: 📦 Create module archives\n+        run: |\n+          VERSION=${{ needs.prepare-modular-release.outputs.version }}\n+          MODULE=${{ matrix.module }}\n+          \n+          if [ \"$MODULE\" = \"full\" ]; then\n+            # Build completa - todos los archivos\n+            tar -czf better-logger-${MODULE}-${VERSION}.tar.gz dist/ README.md package.json\n+            zip -r better-logger-${MODULE}-${VERSION}.zip dist/ README.md package.json\n+          else\n+            # Build modular - solo archivos específicos\n+            tar -czf better-logger-${MODULE}-${VERSION}.tar.gz dist/modular/${MODULE}/ README.md package.json\n+            zip -r better-logger-${MODULE}-${VERSION}.zip dist/modular/${MODULE}/ README.md package.json\n+          fi\n+\n+      - name: 📤 Upload module artifacts\n+        uses: actions/upload-artifact@v4\n+        with:\n+          name: module-${{ matrix.module }}-${{ needs.prepare-modular-release.outputs.version }}\n+          path: |\n+            better-logger-${{ matrix.module }}-${{ needs.prepare-modular-release.outputs.version }}.*\n+            dist/\n+            package.json\n+          retention-days: 30\n+\n+  # ===== PUBLISH TO NPM =====\n+  publish-npm:\n+    runs-on: ubuntu-latest\n+    needs: [prepare-modular-release, build-modules]\n+    if: ${{ inputs.target_registry == 'npm' || inputs.target_registry == 'both' }}\n+    \n+    strategy:\n+      matrix:\n+        module: ${{ fromJson(needs.prepare-modular-release.outputs.modules_to_build) }}\n+    \n+    steps:\n+      - name: 📥 Checkout code\n+        uses: actions/checkout@v4\n+\n+      - name: 📦 Setup Node.js for NPM\n+        uses: actions/setup-node@v4\n+        with:\n+          node-version: ${{ env.NODE_VERSION }}\n+          cache: 'npm'\n+          registry-url: 'https://registry.npmjs.org'\n+\n+      - name: 📥 Download module artifacts\n+        uses: actions/download-artifact@v4\n+        with:\n+          name: module-${{ matrix.module }}-${{ needs.prepare-modular-release.outputs.version }}\n+\n+      - name: 🔄 Update package version\n+        run: npm version ${{ needs.prepare-modular-release.outputs.version }} --no-git-tag-version\n+\n+      - name: 🚀 Publish ${{ matrix.module }} to NPM\n+        run: |\n+          if [ \"${{ needs.prepare-modular-release.outputs.is_prerelease }}\" == \"true\" ]; then\n+            echo \"📦 Publishing prerelease ${{ matrix.module }} to NPM with tag: ${{ needs.prepare-modular-release.outputs.release_channel }}\"\n+            npm publish --access public --tag ${{ needs.prepare-modular-release.outputs.release_channel }}\n+          else\n+            echo \"📦 Publishing stable ${{ matrix.module }} to NPM\"\n+            npm publish --access public\n+          fi\n+        env:\n+          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}\n+\n+  # ===== PUBLISH TO GITHUB PACKAGES =====\n+  publish-github:\n+    runs-on: ubuntu-latest\n+    needs: [prepare-modular-release, build-modules]\n+    if: ${{ inputs.target_registry == 'github' || inputs.target_registry == 'both' }}\n+    \n+    strategy:\n+      matrix:\n+        module: ${{ fromJson(needs.prepare-modular-release.outputs.modules_to_build) }}\n+    \n+    steps:\n+      - name: 📥 Checkout code\n+        uses: actions/checkout@v4\n+\n+      - name: 📦 Setup Node.js for GitHub Packages\n+        uses: actions/setup-node@v4\n+        with:\n+          node-version: ${{ env.NODE_VERSION }}\n+          cache: 'npm'\n+          registry-url: 'https://npm.pkg.github.com'\n+\n+      - name: 📥 Download module artifacts\n+        uses: actions/download-artifact@v4\n+        with:\n+          name: module-${{ matrix.module }}-${{ needs.prepare-modular-release.outputs.version }}\n+\n+      - name: 🔄 Update package version\n+        run: npm version ${{ needs.prepare-modular-release.outputs.version }} --no-git-tag-version\n+\n+      - name: 📦 Publish ${{ matrix.module }} to GitHub Packages\n+        run: |\n+          if [ \"${{ needs.prepare-modular-release.outputs.is_prerelease }}\" == \"true\" ]; then\n+            echo \"📦 Publishing prerelease ${{ matrix.module }} to GitHub Packages with tag: ${{ needs.prepare-modular-release.outputs.release_channel }}\"\n+            npm publish --access public --tag ${{ needs.prepare-modular-release.outputs.release_channel }}\n+          else\n+            echo \"📦 Publishing stable ${{ matrix.module }} to GitHub Packages\" \n+            npm publish --access public\n+          fi\n+        env:\n+          NODE_AUTH_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n+\n+  # ===== CREATE GITHUB RELEASE =====\n+  create-github-release:\n+    runs-on: ubuntu-latest\n+    needs: [prepare-modular-release, build-modules, publish-npm, publish-github]\n+    if: always() && needs.prepare-modular-release.result == 'success'\n+    \n+    permissions:\n+      contents: write\n+      id-token: write\n+    \n+    steps:\n+      - name: 📥 Checkout code  \n+        uses: actions/checkout@v4\n+        with:\n+          fetch-depth: 0\n+          token: ${{ secrets.GITHUB_TOKEN }}\n+\n+      - name: 📥 Download all module artifacts\n+        uses: actions/download-artifact@v4\n+        with:\n+          pattern: module-*-${{ needs.prepare-modular-release.outputs.version }}\n+          merge-multiple: true\n+\n+      - name: 🏷️ Commit and tag\n+        run: |\n+          git config user.name \"github-actions[bot]\"\n+          git config user.email \"github-actions[bot]@users.noreply.github.com\"\n+          git add package.json\n+          git commit -m \"chore: release ${{ needs.prepare-modular-release.outputs.version }} (modular)\" || true\n+          git tag -a \"${{ needs.prepare-modular-release.outputs.tag }}\" -m \"Modular Release ${{ needs.prepare-modular-release.outputs.version }}\"\n+          git push origin main --tags\n+\n+      - name: 📝 Prepare release notes\n+        run: |\n+          VERSION=${{ needs.prepare-modular-release.outputs.version }}\n+          MODULE=${{ inputs.module }}\n+          \n+          echo \"# Better Logger ${VERSION} - Modular Release\" > RELEASE_NOTES.md\n+          echo \"\" >> RELEASE_NOTES.md\n+          \n+          if [ \"${{ needs.prepare-modular-release.outputs.is_prerelease }}\" == \"true\" ]; then\n+            echo \"⚠️ **This is a pre-release version** - Not recommended for production use.\" >> RELEASE_NOTES.md\n+            echo \"\" >> RELEASE_NOTES.md\n+          fi\n+          \n+          echo \"## 📦 Modules Released\" >> RELEASE_NOTES.md\n+          echo \"**Selected Module(s)**: \\`$MODULE\\`\" >> RELEASE_NOTES.md\n+          echo \"\" >> RELEASE_NOTES.md\n+          \n+          echo \"### Available Module Builds:\" >> RELEASE_NOTES.md\n+          echo \"- **Core**: Minimal logger functionality\" >> RELEASE_NOTES.md\n+          echo \"- **Styling**: Advanced visual features\" >> RELEASE_NOTES.md  \n+          echo \"- **Exports**: Export and remote handlers\" >> RELEASE_NOTES.md\n+          echo \"- **Full**: Complete library with all features\" >> RELEASE_NOTES.md\n+          echo \"\" >> RELEASE_NOTES.md\n+          \n+          echo \"## 📦 Installation\" >> RELEASE_NOTES.md\n+          if [ \"${{ needs.prepare-modular-release.outputs.is_prerelease }}\" == \"true\" ]; then\n+            echo \"\\`\\`\\`bash\" >> RELEASE_NOTES.md\n+            echo \"npm install @mks2508/better-logger@${{ needs.prepare-modular-release.outputs.release_channel }}\" >> RELEASE_NOTES.md\n+            echo \"\\`\\`\\`\" >> RELEASE_NOTES.md\n+          else\n+            echo \"\\`\\`\\`bash\" >> RELEASE_NOTES.md  \n+            echo \"npm install @mks2508/better-logger\" >> RELEASE_NOTES.md\n+            echo \"\\`\\`\\`\" >> RELEASE_NOTES.md\n+          fi\n+\n+      - name: 🚀 Create GitHub Release\n+        uses: softprops/action-gh-release@v1\n+        with:\n+          tag_name: ${{ needs.prepare-modular-release.outputs.tag }}\n+          name: Better Logger ${{ needs.prepare-modular-release.outputs.version }} (Modular)\n+          body_path: RELEASE_NOTES.md\n+          draft: false\n+          prerelease: ${{ needs.prepare-modular-release.outputs.is_prerelease == 'true' }}\n+          files: |\n+            better-logger-*-${{ needs.prepare-modular-release.outputs.version }}.tar.gz\n+            better-logger-*-${{ needs.prepare-modular-release.outputs.version }}.zip\n+        env:\n+          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n+\n+  # ===== RELEASE SUMMARY =====\n+  release-summary:\n+    runs-on: ubuntu-latest\n+    needs: [prepare-modular-release, build-modules, publish-npm, publish-github, create-github-release]\n+    if: always() && needs.prepare-modular-release.result == 'success'\n+    \n+    steps:\n+      - name: 📊 Modular Release Summary  \n+        run: |\n+          VERSION=\"${{ needs.prepare-modular-release.outputs.version }}\"\n+          TAG=\"${{ needs.prepare-modular-release.outputs.tag }}\"\n+          CHANNEL=\"${{ needs.prepare-modular-release.outputs.release_channel }}\"\n+          IS_PRERELEASE=\"${{ needs.prepare-modular-release.outputs.is_prerelease }}\"\n+          MODULE=\"${{ inputs.module }}\"\n+          \n+          echo \"## 🎉 Modular Release Complete!\" >> $GITHUB_STEP_SUMMARY\n+          echo \"- **Version**: $VERSION\" >> $GITHUB_STEP_SUMMARY\n+          echo \"- **Module(s)**: $MODULE\" >> $GITHUB_STEP_SUMMARY\n+          echo \"- **Channel**: $CHANNEL\" >> $GITHUB_STEP_SUMMARY\n+          echo \"- **Prerelease**: $IS_PRERELEASE\" >> $GITHUB_STEP_SUMMARY\n+          echo \"\" >> $GITHUB_STEP_SUMMARY\n+          \n+          echo \"### 🔗 Links\" >> $GITHUB_STEP_SUMMARY\n+          if [ \"${{ inputs.target_registry == 'npm' || inputs.target_registry == 'both' }}\" ]; then\n+            echo \"- **NPM**: https://www.npmjs.com/package/@mks2508/better-logger\" >> $GITHUB_STEP_SUMMARY\n+          fi\n+          if [ \"${{ inputs.target_registry == 'github' || inputs.target_registry == 'both' }}\" ]; then\n+            echo \"- **GitHub Packages**: https://github.com/MKS2508/advanced-logger/packages/\" >> $GITHUB_STEP_SUMMARY  \n+          fi\n+          echo \"- **GitHub Release**: https://github.com/MKS2508/advanced-logger/releases/tag/$TAG\" >> $GITHUB_STEP_SUMMARY\n+          echo \"\" >> $GITHUB_STEP_SUMMARY\n+          \n+          echo \"### 📦 Installation\" >> $GITHUB_STEP_SUMMARY\n+          echo \"\\`\\`\\`bash\" >> $GITHUB_STEP_SUMMARY\n+          if [ \"$IS_PRERELEASE\" == \"true\" ]; then\n+            echo \"npm install @mks2508/better-logger@$CHANNEL\" >> $GITHUB_STEP_SUMMARY\n+          else  \n+            echo \"npm install @mks2508/better-logger\" >> $GITHUB_STEP_SUMMARY\n+          fi\n+          echo \"\\`\\`\\`\" >> $GITHUB_STEP_SUMMARY\n\\ No newline at end of file",
      "lines_added": 378,
      "lines_removed": 0,
      "is_binary": false
    },
    {
      "path": ".github/workflows/releases-full.yml",
      "status": "added",
      "diff": "diff --git a/.github/workflows/releases-full.yml b/.github/workflows/releases-full.yml\nnew file mode 100644\nindex 0000000..44bab03\n--- /dev/null\n+++ b/.github/workflows/releases-full.yml\n@@ -0,0 +1,501 @@\n+name: Full Release Pipeline with Gemini AI\n+\n+on:\n+  workflow_dispatch:\n+    inputs:\n+      use_gemini:\n+        description: 'Usar Gemini AI para versionado inteligente'\n+        required: false\n+        default: true\n+        type: boolean\n+      release_type:\n+        description: 'Tipo de release (solo si no usar Gemini)'\n+        required: false\n+        default: 'auto'\n+        type: choice\n+        options:\n+          - auto\n+          - patch\n+          - minor\n+          - major\n+          - alpha\n+          - beta\n+          - stable\n+      target_registry:\n+        description: 'Registro objetivo'\n+        required: false\n+        default: 'both'\n+        type: choice\n+        options:\n+          - npm\n+          - github\n+          - both\n+      skip_tests:\n+        description: 'Saltar tests (no recomendado)'\n+        required: false\n+        default: false\n+        type: boolean\n+      force_release:\n+        description: 'Forzar release aunque no haya cambios significativos'\n+        required: false\n+        default: false\n+        type: boolean\n+\n+env:\n+  NODE_VERSION: '20'\n+\n+jobs:\n+  # ===== INTELLIGENT VERSIONING WITH GEMINI =====\n+  gemini-analysis:\n+    runs-on: ubuntu-latest\n+    if: ${{ inputs.use_gemini }}\n+    \n+    outputs:\n+      should_release: ${{ steps.analysis.outputs.should_release }}\n+      version_type: ${{ steps.analysis.outputs.version_type }}\n+      changelog: ${{ steps.analysis.outputs.changelog }}\n+      release_notes: ${{ steps.analysis.outputs.release_notes }}\n+    \n+    steps:\n+      - name: 📥 Checkout code\n+        uses: actions/checkout@v4\n+        with:\n+          fetch-depth: 0\n+          token: ${{ secrets.GITHUB_TOKEN }}\n+\n+      - name: 📦 Setup Node.js\n+        uses: actions/setup-node@v4\n+        with:\n+          node-version: ${{ env.NODE_VERSION }}\n+          cache: 'npm'\n+\n+      - name: 🔧 Install dependencies\n+        run: npm run ci:install\n+\n+      - name: 🤖 Run Gemini AI Analysis\n+        id: analysis\n+        run: |\n+          echo \"🤖 Ejecutando análisis inteligente con Gemini...\"\n+          \n+          # Usar project-utils auto-release con Gemini\n+          npm run release:auto\n+          \n+          # Verificar si se debe hacer release\n+          if [ -f \"project-utils/.temp/gemini-response.md\" ]; then\n+            # Extraer información del análisis de Gemini\n+            SHOULD_RELEASE=$(grep -o \"should_release: [a-zA-Z]*\" project-utils/.temp/gemini-response.md | cut -d' ' -f2 || echo \"true\")\n+            VERSION_TYPE=$(grep -o \"version_type: [a-zA-Z]*\" project-utils/.temp/gemini-response.md | cut -d' ' -f2 || echo \"patch\")\n+            \n+            echo \"should_release=$SHOULD_RELEASE\" >> $GITHUB_OUTPUT\n+            echo \"version_type=$VERSION_TYPE\" >> $GITHUB_OUTPUT\n+            \n+            # Extraer changelog y release notes si existen\n+            if [ -f \"project-utils/.temp/commit-proposal\"*\".md\" ]; then\n+              CHANGELOG=$(head -n 10 project-utils/.temp/commit-proposal*.md | base64 -w 0)\n+              echo \"changelog=$CHANGELOG\" >> $GITHUB_OUTPUT\n+            fi\n+            \n+            echo \"🤖 Análisis completado: should_release=$SHOULD_RELEASE, version_type=$VERSION_TYPE\"\n+          else\n+            # Fallback si no hay respuesta de Gemini\n+            echo \"should_release=true\" >> $GITHUB_OUTPUT\n+            echo \"version_type=patch\" >> $GITHUB_OUTPUT\n+            echo \"⚠️ No se encontró respuesta de Gemini, usando valores por defecto\"\n+          fi\n+\n+      - name: 📤 Upload Gemini artifacts\n+        uses: actions/upload-artifact@v4\n+        if: always()\n+        with:\n+          name: gemini-analysis\n+          path: project-utils/.temp/\n+          retention-days: 7\n+\n+  # ===== PREPARE RELEASE =====\n+  prepare-full-release:\n+    runs-on: ubuntu-latest\n+    needs: gemini-analysis\n+    if: always() && (needs.gemini-analysis.outputs.should_release == 'true' || inputs.force_release || !inputs.use_gemini)\n+    \n+    outputs:\n+      version: ${{ steps.version.outputs.version }}\n+      tag: ${{ steps.version.outputs.tag }}\n+      is_prerelease: ${{ steps.version.outputs.is_prerelease }}\n+      release_channel: ${{ steps.version.outputs.release_channel }}\n+      changelog: ${{ steps.version.outputs.changelog }}\n+    \n+    steps:\n+      - name: 📥 Checkout code\n+        uses: actions/checkout@v4\n+        with:\n+          fetch-depth: 0\n+          token: ${{ secrets.GITHUB_TOKEN }}\n+\n+      - name: 📦 Setup Node.js\n+        uses: actions/setup-node@v4\n+        with:\n+          node-version: ${{ env.NODE_VERSION }}\n+          cache: 'npm'\n+\n+      - name: 🔧 Install dependencies\n+        run: npm run ci:install\n+\n+      - name: 🧪 Run tests (unless skipped)\n+        if: ${{ !inputs.skip_tests }}\n+        run: |\n+          npm run type-check\n+          npm run ci:test\n+\n+      - name: 🏷️ Generate version with AI or manual\n+        id: version\n+        run: |\n+          if [ \"${{ inputs.use_gemini }}\" == \"true\" ]; then\n+            # Usar resultado de Gemini\n+            VERSION_TYPE=\"${{ needs.gemini-analysis.outputs.version_type }}\"\n+            echo \"🤖 Usando tipo de versión de Gemini: $VERSION_TYPE\"\n+          else\n+            # Usar input manual\n+            VERSION_TYPE=\"${{ inputs.release_type }}\"\n+            echo \"👤 Usando tipo de versión manual: $VERSION_TYPE\"\n+          fi\n+          \n+          # Aplicar versionado según el tipo determinado\n+          case \"$VERSION_TYPE\" in\n+            \"auto\")\n+              npm run version:auto\n+              ;;\n+            \"patch\")\n+              npm run version:patch\n+              ;;\n+            \"minor\")\n+              npm run version:minor\n+              ;;\n+            \"major\")\n+              npm run version:major\n+              ;;\n+            \"alpha\")\n+              npm run version:alpha\n+              ;;\n+            \"beta\")\n+              npm run version:beta\n+              ;;\n+            \"stable\")\n+              npm run version:stable\n+              ;;\n+          esac\n+          \n+          # Obtener nueva versión del package.json\n+          NEW_VERSION=$(node -p \"require('./package.json').version\")\n+          echo \"version=$NEW_VERSION\" >> $GITHUB_OUTPUT\n+          echo \"tag=v$NEW_VERSION\" >> $GITHUB_OUTPUT\n+          \n+          # Determinar si es prerelease y canal\n+          if [[ \"$NEW_VERSION\" == *\"alpha\"* ]]; then\n+            echo \"is_prerelease=true\" >> $GITHUB_OUTPUT\n+            echo \"release_channel=alpha\" >> $GITHUB_OUTPUT\n+          elif [[ \"$NEW_VERSION\" == *\"beta\"* ]]; then\n+            echo \"is_prerelease=true\" >> $GITHUB_OUTPUT  \n+            echo \"release_channel=beta\" >> $GITHUB_OUTPUT\n+          else\n+            echo \"is_prerelease=false\" >> $GITHUB_OUTPUT\n+            echo \"release_channel=latest\" >> $GITHUB_OUTPUT\n+          fi\n+          \n+          echo \"📦 Nueva versión: $NEW_VERSION\"\n+\n+      - name: 📝 Generate enhanced changelog\n+        id: changelog\n+        run: |\n+          if [ \"${{ inputs.use_gemini }}\" == \"true\" ] && [ \"${{ needs.gemini-analysis.outputs.changelog }}\" != \"\" ]; then\n+            # Usar changelog de Gemini si existe\n+            echo \"📋 Usando changelog generado por Gemini AI...\"\n+            CHANGELOG=$(echo \"${{ needs.gemini-analysis.outputs.changelog }}\" | base64 -d)\n+          else\n+            # Generar changelog tradicional\n+            echo \"📋 Generando changelog tradicional...\"\n+            LAST_TAG=$(git describe --tags --abbrev=0 HEAD~1 2>/dev/null || echo \"\")\n+            if [ -n \"$LAST_TAG\" ]; then\n+              CHANGELOG=$(git log $LAST_TAG..HEAD --pretty=format:\"- %s (%h)\" --no-merges)\n+            else\n+              CHANGELOG=\"- Initial release with complete Better Logger functionality\"\n+            fi\n+          fi\n+          \n+          # Guardar changelog en archivo\n+          echo \"$CHANGELOG\" > RELEASE_CHANGELOG.md\n+          echo \"changelog=$(echo \"$CHANGELOG\" | base64 -w 0)\" >> $GITHUB_OUTPUT\n+          echo \"📋 Changelog generado exitosamente\"\n+\n+      - name: 🏗️ Build all modules\n+        run: npm run build:all\n+\n+      - name: 📊 Generate bundle analysis\n+        run: |\n+          echo \"## 📦 Bundle Analysis\" > BUNDLE_ANALYSIS.md\n+          echo \"### Full Build\" >> BUNDLE_ANALYSIS.md\n+          echo \"\\`\\`\\`\" >> BUNDLE_ANALYSIS.md\n+          ls -lh dist/*.js dist/*.cjs | grep -E '\\.(js|cjs)$' >> BUNDLE_ANALYSIS.md\n+          echo \"\\`\\`\\`\" >> BUNDLE_ANALYSIS.md\n+          echo \"\" >> BUNDLE_ANALYSIS.md\n+          \n+          echo \"### Modular Builds\" >> BUNDLE_ANALYSIS.md\n+          for module in core styling exports; do\n+            if [ -d \"dist/modular/$module\" ]; then\n+              echo \"#### $module Module\" >> BUNDLE_ANALYSIS.md\n+              echo \"\\`\\`\\`\" >> BUNDLE_ANALYSIS.md\n+              ls -lh dist/modular/$module/*.js dist/modular/$module/*.cjs 2>/dev/null | grep -E '\\.(js|cjs)$' >> BUNDLE_ANALYSIS.md\n+              echo \"\\`\\`\\`\" >> BUNDLE_ANALYSIS.md\n+            fi\n+          done\n+\n+      - name: 📤 Upload release artifacts\n+        uses: actions/upload-artifact@v4\n+        with:\n+          name: full-release-${{ steps.version.outputs.version }}\n+          path: |\n+            dist/\n+            RELEASE_CHANGELOG.md\n+            BUNDLE_ANALYSIS.md\n+          retention-days: 30\n+\n+  # ===== PUBLISH TO NPM =====\n+  publish-npm-full:\n+    runs-on: ubuntu-latest\n+    needs: prepare-full-release\n+    if: ${{ inputs.target_registry == 'npm' || inputs.target_registry == 'both' }}\n+    \n+    steps:\n+      - name: 📥 Checkout code\n+        uses: actions/checkout@v4\n+\n+      - name: 📦 Setup Node.js for NPM\n+        uses: actions/setup-node@v4\n+        with:\n+          node-version: ${{ env.NODE_VERSION }}\n+          cache: 'npm'\n+          registry-url: 'https://registry.npmjs.org'\n+\n+      - name: 📥 Download release artifacts\n+        uses: actions/download-artifact@v4\n+        with:\n+          name: full-release-${{ needs.prepare-full-release.outputs.version }}\n+\n+      - name: 🔄 Update package version\n+        run: npm version ${{ needs.prepare-full-release.outputs.version }} --no-git-tag-version\n+\n+      - name: 🚀 Publish to NPM\n+        run: |\n+          if [ \"${{ needs.prepare-full-release.outputs.is_prerelease }}\" == \"true\" ]; then\n+            echo \"📦 Publishing prerelease to NPM with tag: ${{ needs.prepare-full-release.outputs.release_channel }}\"\n+            npm publish --access public --tag ${{ needs.prepare-full-release.outputs.release_channel }}\n+          else\n+            echo \"📦 Publishing stable release to NPM\"\n+            npm publish --access public\n+          fi\n+        env:\n+          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}\n+\n+  # ===== PUBLISH TO GITHUB PACKAGES =====\n+  publish-github-full:\n+    runs-on: ubuntu-latest\n+    needs: prepare-full-release\n+    if: ${{ inputs.target_registry == 'github' || inputs.target_registry == 'both' }}\n+    \n+    steps:\n+      - name: 📥 Checkout code\n+        uses: actions/checkout@v4\n+\n+      - name: 📦 Setup Node.js for GitHub Packages\n+        uses: actions/setup-node@v4\n+        with:\n+          node-version: ${{ env.NODE_VERSION }}\n+          cache: 'npm'\n+          registry-url: 'https://npm.pkg.github.com'\n+\n+      - name: 📥 Download release artifacts\n+        uses: actions/download-artifact@v4\n+        with:\n+          name: full-release-${{ needs.prepare-full-release.outputs.version }}\n+\n+      - name: 🔄 Update package version\n+        run: npm version ${{ needs.prepare-full-release.outputs.version }} --no-git-tag-version\n+\n+      - name: 📦 Publish to GitHub Packages\n+        run: |\n+          if [ \"${{ needs.prepare-full-release.outputs.is_prerelease }}\" == \"true\" ]; then\n+            echo \"📦 Publishing prerelease to GitHub Packages with tag: ${{ needs.prepare-full-release.outputs.release_channel }}\"\n+            npm publish --access public --tag ${{ needs.prepare-full-release.outputs.release_channel }}\n+          else\n+            echo \"📦 Publishing stable release to GitHub Packages\" \n+            npm publish --access public\n+          fi\n+        env:\n+          NODE_AUTH_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n+\n+  # ===== CREATE COMPREHENSIVE GITHUB RELEASE =====\n+  create-comprehensive-release:\n+    runs-on: ubuntu-latest\n+    needs: [gemini-analysis, prepare-full-release, publish-npm-full, publish-github-full]\n+    if: always() && needs.prepare-full-release.result == 'success'\n+    \n+    permissions:\n+      contents: write\n+      id-token: write\n+    \n+    steps:\n+      - name: 📥 Checkout code  \n+        uses: actions/checkout@v4\n+        with:\n+          fetch-depth: 0\n+          token: ${{ secrets.GITHUB_TOKEN }}\n+\n+      - name: 📥 Download release artifacts\n+        uses: actions/download-artifact@v4\n+        with:\n+          name: full-release-${{ needs.prepare-full-release.outputs.version }}\n+\n+      - name: 📥 Download Gemini artifacts (if available)\n+        uses: actions/download-artifact@v4\n+        if: needs.gemini-analysis.result == 'success'\n+        with:\n+          name: gemini-analysis\n+          path: gemini-temp/\n+\n+      - name: 📦 Create comprehensive release archives\n+        run: |\n+          VERSION=${{ needs.prepare-full-release.outputs.version }}\n+          \n+          # Crear archivos de distribución completa\n+          tar -czf better-logger-complete-${VERSION}.tar.gz dist/ docs/ README.md package.json\n+          zip -r better-logger-complete-${VERSION}.zip dist/ docs/ README.md package.json\n+          \n+          # Crear paquetes modulares individuales\n+          for module in core styling exports; do\n+            if [ -d \"dist/modular/$module\" ]; then\n+              tar -czf better-logger-${module}-${VERSION}.tar.gz dist/modular/${module}/ README.md package.json\n+              zip -r better-logger-${module}-${VERSION}.zip dist/modular/${module}/ README.md package.json\n+            fi\n+          done\n+\n+      - name: 🏷️ Commit and tag with enhanced info\n+        run: |\n+          git config user.name \"github-actions[bot]\"\n+          git config user.email \"github-actions[bot]@users.noreply.github.com\"\n+          git add package.json\n+          \n+          # Crear commit message mejorado\n+          COMMIT_MSG=\"chore: release ${{ needs.prepare-full-release.outputs.version }}\"\n+          if [ \"${{ inputs.use_gemini }}\" == \"true\" ]; then\n+            COMMIT_MSG=\"$COMMIT_MSG (AI-generated)\"\n+          fi\n+          \n+          git commit -m \"$COMMIT_MSG\" || true\n+          git tag -a \"${{ needs.prepare-full-release.outputs.tag }}\" -m \"Release ${{ needs.prepare-full-release.outputs.version }}\"\n+          git push origin main --tags\n+\n+      - name: 📝 Prepare comprehensive release notes\n+        run: |\n+          VERSION=${{ needs.prepare-full-release.outputs.version }}\n+          CHANGELOG=$(echo \"${{ needs.prepare-full-release.outputs.changelog }}\" | base64 -d)\n+          \n+          echo \"# Better Logger ${VERSION}\" > FINAL_RELEASE_NOTES.md\n+          echo \"\" >> FINAL_RELEASE_NOTES.md\n+          \n+          if [ \"${{ inputs.use_gemini }}\" == \"true\" ]; then\n+            echo \"🤖 **AI-Generated Release** - This release was analyzed and versioned using Gemini AI\" >> FINAL_RELEASE_NOTES.md\n+            echo \"\" >> FINAL_RELEASE_NOTES.md\n+          fi\n+          \n+          if [ \"${{ needs.prepare-full-release.outputs.is_prerelease }}\" == \"true\" ]; then\n+            echo \"⚠️ **This is a pre-release version** - Not recommended for production use.\" >> FINAL_RELEASE_NOTES.md\n+            echo \"\" >> FINAL_RELEASE_NOTES.md\n+          fi\n+          \n+          echo \"## 🔄 Changes\" >> FINAL_RELEASE_NOTES.md\n+          echo \"$CHANGELOG\" >> FINAL_RELEASE_NOTES.md\n+          echo \"\" >> FINAL_RELEASE_NOTES.md\n+          \n+          # Incluir análisis de bundle\n+          cat BUNDLE_ANALYSIS.md >> FINAL_RELEASE_NOTES.md\n+          echo \"\" >> FINAL_RELEASE_NOTES.md\n+          \n+          echo \"## 📦 Available Packages\" >> FINAL_RELEASE_NOTES.md\n+          echo \"### Complete Library\" >> FINAL_RELEASE_NOTES.md\n+          echo \"\\`\\`\\`bash\" >> FINAL_RELEASE_NOTES.md\n+          if [ \"${{ needs.prepare-full-release.outputs.is_prerelease }}\" == \"true\" ]; then\n+            echo \"npm install @mks2508/better-logger@${{ needs.prepare-full-release.outputs.release_channel }}\" >> FINAL_RELEASE_NOTES.md\n+          else\n+            echo \"npm install @mks2508/better-logger\" >> FINAL_RELEASE_NOTES.md\n+          fi\n+          echo \"\\`\\`\\`\" >> FINAL_RELEASE_NOTES.md\n+          echo \"\" >> FINAL_RELEASE_NOTES.md\n+          \n+          echo \"### Modular Packages\" >> FINAL_RELEASE_NOTES.md\n+          echo \"Download individual modules from the release assets below for selective usage.\" >> FINAL_RELEASE_NOTES.md\n+\n+      - name: 🚀 Create Comprehensive GitHub Release\n+        uses: softprops/action-gh-release@v1\n+        with:\n+          tag_name: ${{ needs.prepare-full-release.outputs.tag }}\n+          name: Better Logger ${{ needs.prepare-full-release.outputs.version }}${{ inputs.use_gemini && ' (AI)' || '' }}\n+          body_path: FINAL_RELEASE_NOTES.md\n+          draft: false\n+          prerelease: ${{ needs.prepare-full-release.outputs.is_prerelease == 'true' }}\n+          files: |\n+            better-logger-complete-${{ needs.prepare-full-release.outputs.version }}.tar.gz\n+            better-logger-complete-${{ needs.prepare-full-release.outputs.version }}.zip\n+            better-logger-core-${{ needs.prepare-full-release.outputs.version }}.tar.gz\n+            better-logger-core-${{ needs.prepare-full-release.outputs.version }}.zip\n+            better-logger-styling-${{ needs.prepare-full-release.outputs.version }}.tar.gz\n+            better-logger-styling-${{ needs.prepare-full-release.outputs.version }}.zip\n+            better-logger-exports-${{ needs.prepare-full-release.outputs.version }}.tar.gz\n+            better-logger-exports-${{ needs.prepare-full-release.outputs.version }}.zip\n+        env:\n+          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n+\n+  # ===== COMPREHENSIVE RELEASE SUMMARY =====\n+  comprehensive-summary:\n+    runs-on: ubuntu-latest\n+    needs: [gemini-analysis, prepare-full-release, publish-npm-full, publish-github-full, create-comprehensive-release]\n+    if: always() && needs.prepare-full-release.result == 'success'\n+    \n+    steps:\n+      - name: 📊 Comprehensive Release Summary  \n+        run: |\n+          VERSION=\"${{ needs.prepare-full-release.outputs.version }}\"\n+          TAG=\"${{ needs.prepare-full-release.outputs.tag }}\"\n+          CHANNEL=\"${{ needs.prepare-full-release.outputs.release_channel }}\"\n+          IS_PRERELEASE=\"${{ needs.prepare-full-release.outputs.is_prerelease }}\"\n+          USED_AI=\"${{ inputs.use_gemini }}\"\n+          \n+          echo \"## 🎉 Comprehensive Release Complete!\" >> $GITHUB_STEP_SUMMARY\n+          echo \"- **Version**: $VERSION\" >> $GITHUB_STEP_SUMMARY\n+          echo \"- **Channel**: $CHANNEL\" >> $GITHUB_STEP_SUMMARY\n+          echo \"- **Prerelease**: $IS_PRERELEASE\" >> $GITHUB_STEP_SUMMARY\n+          echo \"- **AI-Generated**: $USED_AI\" >> $GITHUB_STEP_SUMMARY\n+          echo \"\" >> $GITHUB_STEP_SUMMARY\n+          \n+          echo \"### 📦 Published Packages\" >> $GITHUB_STEP_SUMMARY\n+          echo \"- **Complete Library**: Full Better Logger with all features\" >> $GITHUB_STEP_SUMMARY\n+          echo \"- **Modular Builds**: Core, Styling, and Exports available separately\" >> $GITHUB_STEP_SUMMARY\n+          echo \"\" >> $GITHUB_STEP_SUMMARY\n+          \n+          echo \"### 🔗 Links\" >> $GITHUB_STEP_SUMMARY\n+          if [ \"${{ inputs.target_registry == 'npm' || inputs.target_registry == 'both' }}\" ]; then\n+            echo \"- **NPM**: https://www.npmjs.com/package/@mks2508/better-logger\" >> $GITHUB_STEP_SUMMARY\n+          fi\n+          if [ \"${{ inputs.target_registry == 'github' || inputs.target_registry == 'both' }}\" ]; then\n+            echo \"- **GitHub Packages**: https://github.com/MKS2508/advanced-logger/packages/\" >> $GITHUB_STEP_SUMMARY  \n+          fi\n+          echo \"- **GitHub Release**: https://github.com/MKS2508/advanced-logger/releases/tag/$TAG\" >> $GITHUB_STEP_SUMMARY\n+          echo \"- **Documentation**: https://mks2508.github.io/advanced-logger/\" >> $GITHUB_STEP_SUMMARY\n+          echo \"\" >> $GITHUB_STEP_SUMMARY\n+          \n+          echo \"### 📦 Installation\" >> $GITHUB_STEP_SUMMARY\n+          echo \"\\`\\`\\`bash\" >> $GITHUB_STEP_SUMMARY\n+          if [ \"$IS_PRERELEASE\" == \"true\" ]; then\n+            echo \"npm install @mks2508/better-logger@$CHANNEL\" >> $GITHUB_STEP_SUMMARY\n+          else  \n+            echo \"npm install @mks2508/better-logger\" >> $GITHUB_STEP_SUMMARY\n+          fi\n+          echo \"\\`\\`\\`\" >> $GITHUB_STEP_SUMMARY\n\\ No newline at end of file",
      "lines_added": 501,
      "lines_removed": 0,
      "is_binary": false
    },
    {
      "path": "package.json",
      "status": "modified",
      "diff": "diff --git a/package.json b/package.json\nindex 49619ea..bcde04c 100644\n--- a/package.json\n+++ b/package.json\n@@ -29,32 +29,38 @@\n   \"homepage\": \"https://mks2508.github.io/advanced-logger/\",\n   \"scripts\": {\n     \"dev\": \"vite\",\n-    \"build\": \"tsc && vite build\",\n-    \"build:watch\": \"vite build --watch\",\n-    \"build:analyze\": \"vite build --mode analyze\",\n-    \"preview\": \"vite preview\",\n+    \"build\": \"tsc && BUILD_MODE=full vite build\",\n+    \"build:full\": \"tsc && BUILD_MODE=full vite build\", \n+    \"build:core\": \"tsc && BUILD_MODE=core vite build\",\n+    \"build:styling\": \"tsc && BUILD_MODE=styling vite build\",\n+    \"build:exports\": \"tsc && BUILD_MODE=exports vite build\",\n+    \"build:all\": \"npm run build:full && npm run build:core && npm run build:styling && npm run build:exports\",\n     \"clean\": \"rm -rf dist node_modules/.vite\",\n     \"type-check\": \"tsc --noEmit\",\n-    \"lint\": \"echo 'Linting with ESLint...' && exit 0\",\n-    \"lint:fix\": \"echo 'Fixing with ESLint...' && exit 0\",\n     \"test\": \"echo 'Running tests...' && exit 0\",\n-    \"test:watch\": \"echo 'Running tests in watch mode...' && exit 0\",\n-    \"test:coverage\": \"echo 'Running tests with coverage...' && exit 0\",\n     \"test:performance\": \"echo 'Running performance benchmarks...' && exit 0\",\n     \"test:visual\": \"echo 'Running visual tests...' && exit 0\",\n-    \"prepublishOnly\": \"npm run clean && npm run type-check && npm run build\",\n-    \"release\": \"npm version patch && npm publish --access public\",\n-    \"release:minor\": \"npm version minor && npm publish --access public\",\n-    \"release:major\": \"npm version major && npm publish --access public\",\n-    \"release:alpha\": \"npm version prerelease --preid=alpha && npm publish --access public --tag alpha\",\n-    \"release:beta\": \"npm version prerelease --preid=beta && npm publish --access public --tag beta\",\n-    \"demo:serve\": \"python3 -m http.server 8080\",\n     \"size-limit\": \"echo 'Checking bundle sizes...' && ls -la dist/\",\n     \"ci:install\": \"npm ci\",\n-    \"ci:build\": \"npm run build\",\n+    \"ci:build\": \"npm run build:all\",\n     \"ci:test\": \"npm run test\",\n     \"ci:publish\": \"npm publish --access public --ignore-scripts\",\n-    \"ci:publish:github\": \"npm publish --registry=https://npm.pkg.github.com --access public --ignore-scripts\"\n+    \"ci:publish:github\": \"npm publish --registry=https://npm.pkg.github.com --access public --ignore-scripts\",\n+    \"commit:auto\": \"bun project-utils/commit-generator.ts --auto-approve --quiet\",\n+    \"commit:ui\": \"bun project-utils/commit-ui.ts\",\n+    \"version:auto\": \"bun project-utils/version-manager.ts --auto-approve\",\n+    \"version:patch\": \"bun project-utils/version-manager.ts --type patch --auto-approve\",\n+    \"version:minor\": \"bun project-utils/version-manager.ts --type minor --auto-approve\", \n+    \"version:major\": \"bun project-utils/version-manager.ts --type major --auto-approve\",\n+    \"version:alpha\": \"bun project-utils/version-manager.ts --prefix alpha --auto-approve\",\n+    \"version:beta\": \"bun project-utils/version-manager.ts --prefix beta --auto-approve\",\n+    \"version:stable\": \"bun project-utils/version-manager.ts --prefix '' --auto-approve\",\n+    \"release:github\": \"bun project-utils/github-release-manager.ts --auto-approve\",\n+    \"release:full\": \"npm run version:auto && npm run build:all && npm run release:github && npm run ci:publish\",\n+    \"release:auto\": \"bun project-utils/auto-release-gemini.ts --ai --auto-approve\",\n+    \"workflow:full\": \"npm run commit:auto && npm run release:full\",\n+    \"workflow:commit\": \"npm run commit:auto\",\n+    \"workflow:release\": \"npm run version:auto && npm run build:all && npm run release:github\"\n   },\n   \"devDependencies\": {\n     \"terser\": \"^5.43.1\",",
      "lines_added": 23,
      "lines_removed": 17,
      "is_binary": false
    },
    {
      "path": "project-utils/.temp/analysis-context.json",
      "status": "added",
      "diff": "diff --git a/project-utils/.temp/analysis-context.json b/project-utils/.temp/analysis-context.json\nnew file mode 100644\nindex 0000000..f443d31\n--- /dev/null\n+++ b/project-utils/.temp/analysis-context.json\n@@ -0,0 +1,189 @@\n+{\n+  \"files\": [\n+    {\n+      \"path\": \".github/workflows/ci.yml -> .github/workflows-backup/ci.yml\",\n+      \"status\": \"renamed\",\n+      \"diff\": \"\"\n+    },\n+    {\n+      \"path\": \".github/workflows-backup/nightly.yml\",\n+      \"status\": \"added\",\n+      \"diff\": \"diff --git a/.github/workflows-backup/nightly.yml b/.github/workflows-backup/nightly.yml\\nnew file mode 100644\\nindex 0000000..2618595\\n--- /dev/null\\n+++ b/.github/workflows-backup/nightly.yml\\n@@ -0,0 +1,196 @@\\n+name: Nightly Builds\\n+\\n+on:\\n+  schedule:\\n+    # Ejecutar cada día a las 3:00 AM UTC\\n+    - cron: '0 3 * * *'\\n+  workflow_dispatch:\\n+    inputs:\\n+      force_build:\\n+        description: 'Forzar build aunque no haya cambios'\\n+        required: false\\n+        default: false\\n+        type: boolean\\n+\\n+env:\\n+  NODE_VERSION: '20'\\n+  REGISTRY_URL: 'https://registry.npmjs.org'\\n+\\n+jobs:\\n+  check-changes:\\n+    runs-on: ubuntu-latest\\n+    outputs:\\n+      has_changes: ${{ steps.changes.outputs.has_changes }}\\n+      last_commit: ${{ steps.changes.outputs.last_commit }}\\n+      commit_count: ${{ steps.changes.outputs.commit_count }}\\n+    \\n+    steps:\\n+      - name: 📥 Checkout code\\n+        uses: actions/checkout@v4\\n+        with:\\n+          fetch-depth: 0\\n+\\n+      - name: 🔍 Check for changes since last nightly\\n+        id: changes\\n+        run: |\\n+          # Buscar último tag nightly\\n+          LAST_NIGHTLY=$(git tag -l \\\"nightly-*\\\" | sort -V | tail -1 || echo \\\"\\\")\\n+          \\n+          if [ -z \\\"$LAST_NIGHTLY\\\" ]; then\\n+            # No hay nightlies previos, verificar desde hace 24 horas\\n+            SINCE_DATE=$(date -d '24 hours ago' --iso-8601)\\n+            COMMITS_COUNT=$(git log --since=\\\"$SINCE_DATE\\\" --oneline | wc -l)\\n+          else\\n+            # Verificar desde último nightly\\n+            COMMITS_COUNT=$(git log $LAST_NIGHTLY..HEAD --oneline | wc -l)\\n+          fi\\n+          \\n+          LAST_COMMIT=$(git rev-parse --short HEAD)\\n+          \\n+          echo \\\"commit_count=$COMMITS_COUNT\\\" >> $GITHUB_OUTPUT\\n+          echo \\\"last_commit=$LAST_COMMIT\\\" >> $GITHUB_OUTPUT\\n+          \\n+          if [ \\\"$COMMITS_COUNT\\\" -gt 0 ] || [ \\\"${{ inputs.force_build }}\\\" == \\\"true\\\" ]; then\\n+            echo \\\"has_changes=true\\\" >> $GITHUB_OUTPUT\\n+            echo \\\"✅ Cambios detectados: $COMMITS_COUNT commits\\\"\\n+          else\\n+            echo \\\"has_changes=false\\\" >> $GITHUB_OUTPUT  \\n+            echo \\\"ℹ️ No hay cambios desde último nightly\\\"\\n+          fi\\n+\\n+  nightly-build:\\n+    runs-on: ubuntu-latest\\n+    needs: check-changes\\n+    if: needs.check-changes.outputs.has_changes == 'true'\\n+    \\n+    permissions:\\n+      contents: write\\n+      packages: write\\n+      id-token: write\\n+    \\n+    steps:\\n+      - name: 📥 Checkout code\\n+        uses: actions/checkout@v4\\n+        with:\\n+          fetch-depth: 0\\n+          token: ${{ secrets.GITHUB_TOKEN }}\\n+\\n+      - name: 📦 Setup Node.js\\n+        uses: actions/setup-node@v4\\n+        with:\\n+          node-version: ${{ env.NODE_VERSION }}\\n+          cache: 'npm'\\n+          registry-url: ${{ env.REGISTRY_URL }}\\n+\\n+      - name: 🔧 Install dependencies\\n+        run: npm ci\\n+\\n+      - name: 🏗️ Build library\\n+        run: npm run build\\n+\\n+      - name: 🧪 Run tests\\n+        run: |\\n+          npm run type-check\\n+          npm run test\\n+          npm run size-limit\\n+\\n+      - name: 🏷️ Generate nightly version\\n+        id: version\\n+        run: |\\n+          # Generar versión nightly usando commit y fecha\\n+          DATE=$(date +%Y%m%d)\\n+          SHORT_SHA=\\\"${{ needs.check-changes.outputs.last_commit }}\\\"\\n+          BASE_VERSION=$(node -p \\\"require('./package.json').version\\\")\\n+          \\n+          # Remover cualquier sufijo existente del base version\\n+          CLEAN_VERSION=$(echo $BASE_VERSION | sed 's/-.*//')\\n+          NIGHTLY_VERSION=\\\"${CLEAN_VERSION}-nightly.${DATE}.${SHORT_SHA}\\\"\\n+          \\n+          echo \\\"version=$NIGHTLY_VERSION\\\" >> $GITHUB_OUTPUT\\n+          echo \\\"tag=nightly-$DATE-$SHORT_SHA\\\" >> $GITHUB_OUTPUT\\n+          echo \\\"🌙 Nightly version: $NIGHTLY_VERSION\\\"\\n+\\n+      - name: 📝 Update package.json for nightly\\n+        run: |\\n+          npm version ${{ steps.version.outputs.version }} --no-git-tag-version\\n+\\n+      - name: 📦 Create nightly archives  \\n+        run: |\\n+          mkdir -p nightly-dist\\n+          \\n+          # Crear archivos de distribución nightly\\n+          tar -czf nightly-dist/better-logger-nightly-${{ steps.version.outputs.tag }}.tar.gz dist/ README.md package.json\\n+          zip -r nightly-dist/better-logger-nightly-${{ steps.version.outputs.tag }}.zip dist/ README.md package.json\\n+\\n+      - name: 🚀 Publish nightly to NPM\\n+        run: |\\n+          npm publish --tag nightly --access public\\n+        env:\\n+          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}\\n+\\n+      - name: 📦 Publish nightly to GitHub Packages  \\n+        run: |\\n+          echo \\\"//npm.pkg.github.com/:_authToken=${{ secrets.GITHUB_TOKEN }}\\\" >> ~/.npmrc\\n+          echo \\\"@mks2508:registry=https://npm.pkg.github.com\\\" >> ~/.npmrc\\n+          npm publish --registry=https://npm.pkg.github.com --tag nightly --access public\\n+\\n+      - name: 🏷️ Create nightly tag\\n+        run: |\\n+          git config user.name \\\"github-actions[bot]\\\"\\n+          git config user.email \\\"github-actions[bot]@users.noreply.github.com\\\" \\n+          git tag -a \\\"${{ steps.version.outputs.tag }}\\\" -m \\\"Nightly build ${{ steps.version.outputs.version }}\\\"\\n+          git push origin \\\"${{ steps.version.outputs.tag }}\\\"\\n+\\n+      - name: 🌙 Create nightly release\\n+        uses: softprops/action-gh-release@v1\\n+        with:\\n+          tag_name: ${{ steps.version.outputs.tag }}\\n+          name: \\\"Nightly Build ${{ steps.version.outputs.version }}\\\"\\n+          body: |\\n+            🌙 **Nightly Build** - Experimental version for testing\\n+            \\n+            **⚠️ This is a development build - not recommended for production use**\\n+            \\n+            ## 📋 Changes since last nightly\\n+            ${{ needs.check-changes.outputs.commit_count }} commits included in this build.\\n+            \\n+            ## 📦 Installation\\n+            ```bash\\n+            npm install @mks2508/better-logger@nightly\\n+            ```\\n+            \\n+            ## 🔗 Links\\n+            - **Commit**: https://github.com/MKS2508/advanced-logger/commit/${{ needs.check-changes.outputs.last_commit }}\\n+            - **NPM**: https://www.npmjs.com/package/@mks2508/better-logger/v/${{ steps.version.outputs.version }}\\n+          draft: false\\n+          prerelease: true\\n+          files: |\\n+            nightly-dist/better-logger-nightly-${{ steps.version.outputs.tag }}.tar.gz  \\n+            nightly-dist/better-logger-nightly-${{ steps.version.outputs.tag }}.zip\\n+        env:\\n+          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\\n+\\n+      - name: 📊 Nightly build summary\\n+        run: |\\n+          echo \\\"## 🌙 Nightly Build Complete!\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"- **Version**: ${{ steps.version.outputs.version }}\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"- **Commits**: ${{ needs.check-changes.outputs.commit_count }}\\\" >> $GITHUB_STEP_SUMMARY  \\n+          echo \\\"- **NPM**: https://www.npmjs.com/package/@mks2508/better-logger/v/${{ steps.version.outputs.version }}\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"- **GitHub**: https://github.com/MKS2508/advanced-logger/releases/tag/${{ steps.version.outputs.tag }}\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"### 📦 Installation\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"\\\\`\\\\`\\\\`bash\\\" >> $GITHUB_STEP_SUMMARY  \\n+          echo \\\"npm install @mks2508/better-logger@nightly\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"\\\\`\\\\`\\\\`\\\" >> $GITHUB_STEP_SUMMARY\\n+\\n+  no-changes:\\n+    runs-on: ubuntu-latest\\n+    needs: check-changes\\n+    if: needs.check-changes.outputs.has_changes == 'false'\\n+    \\n+    steps:\\n+      - name: ℹ️ No changes detected\\n+        run: |\\n+          echo \\\"## ℹ️ No Nightly Build Required\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"No changes detected since last nightly build.\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"Use \\\\`workflow_dispatch\\\\` with \\\\`force_build: true\\\\` to force a build.\\\" >> $GITHUB_STEP_SUMMARY\\n\\\\ No newline at end of file\",\n+      \"lines_added\": 196,\n+      \"lines_removed\": 0,\n+      \"is_binary\": false\n+    },\n+    {\n+      \"path\": \".github/workflows-backup/release-optimized.yml\",\n+      \"status\": \"added\",\n+      \"diff\": \"diff --git a/.github/workflows-backup/release-optimized.yml b/.github/workflows-backup/release-optimized.yml\\nnew file mode 100644\\nindex 0000000..846bd9b\\n--- /dev/null\\n+++ b/.github/workflows-backup/release-optimized.yml\\n@@ -0,0 +1,373 @@\\n+name: Optimized Release Pipeline\\n+\\n+on:\\n+  workflow_dispatch:\\n+    inputs:\\n+      release_type:\\n+        description: 'Tipo de release'\\n+        required: true\\n+        default: 'auto'\\n+        type: choice\\n+        options:\\n+          - auto\\n+          - patch\\n+          - minor\\n+          - major\\n+          - alpha\\n+          - beta\\n+          - stable\\n+      use_gemini:\\n+        description: 'Usar Gemini AI para versionado'\\n+        required: false\\n+        default: true\\n+        type: boolean\\n+      skip_tests:\\n+        description: 'Saltar tests (no recomendado)'\\n+        required: false\\n+        default: false\\n+        type: boolean\\n+      target_registry:\\n+        description: 'Registro objetivo'\\n+        required: false\\n+        default: 'both'\\n+        type: choice\\n+        options:\\n+          - npm\\n+          - github\\n+          - both\\n+\\n+env:\\n+  NODE_VERSION: '20'\\n+\\n+jobs:\\n+  # ===== VALIDATION & VERSIONING =====\\n+  prepare-release:\\n+    runs-on: ubuntu-latest\\n+    \\n+    outputs:\\n+      version: ${{ steps.version.outputs.version }}\\n+      tag: ${{ steps.version.outputs.tag }}\\n+      is_prerelease: ${{ steps.version.outputs.is_prerelease }}\\n+      changelog: ${{ steps.version.outputs.changelog }}\\n+      release_channel: ${{ steps.version.outputs.release_channel }}\\n+    \\n+    steps:\\n+      - name: 📥 Checkout code\\n+        uses: actions/checkout@v4\\n+        with:\\n+          fetch-depth: 0\\n+          token: ${{ secrets.GITHUB_TOKEN }}\\n+\\n+      - name: 📦 Setup Node.js\\n+        uses: actions/setup-node@v4\\n+        with:\\n+          node-version: ${{ env.NODE_VERSION }}\\n+          cache: 'npm'\\n+\\n+      - name: 🔧 Install dependencies\\n+        run: npm ci\\n+\\n+      - name: 🧪 Run tests (unless skipped)\\n+        if: ${{ !inputs.skip_tests }}\\n+        run: |\\n+          npm run type-check\\n+          npm run lint  \\n+          npm run test\\n+          npm run build\\n+\\n+      - name: 🏷️ Generate version with project-utils\\n+        id: version\\n+        run: |\\n+          if [ \\\"${{ inputs.use_gemini }}\\\" == \\\"true\\\" ] && [ \\\"${{ inputs.release_type }}\\\" == \\\"auto\\\" ]; then\\n+            # Usar auto-release con Gemini para detección inteligente\\n+            echo \\\"🤖 Usando Gemini AI para versionado automático...\\\"\\n+            npm run version:auto\\n+          elif [ \\\"${{ inputs.release_type }}\\\" == \\\"auto\\\" ]; then\\n+            # Auto-detección sin Gemini  \\n+            echo \\\"🔍 Auto-detectando tipo de versión...\\\"\\n+            npm run version:auto\\n+          else\\n+            # Tipo específico forzado\\n+            echo \\\"🎯 Usando tipo de versión forzado: ${{ inputs.release_type }}\\\"\\n+            case \\\"${{ inputs.release_type }}\\\" in\\n+              \\\"patch\\\") npm run version:patch ;;\\n+              \\\"minor\\\") npm run version:minor ;;  \\n+              \\\"major\\\") npm run version:major ;;\\n+              \\\"alpha\\\") npm run version:alpha ;;\\n+              \\\"beta\\\") npm run version:beta ;;\\n+              \\\"stable\\\") npm run version:stable ;;\\n+            esac\\n+          fi\\n+          \\n+          # Obtener nueva versión del package.json\\n+          NEW_VERSION=$(node -p \\\"require('./package.json').version\\\")\\n+          echo \\\"version=$NEW_VERSION\\\" >> $GITHUB_OUTPUT\\n+          echo \\\"tag=v$NEW_VERSION\\\" >> $GITHUB_OUTPUT\\n+          \\n+          # Determinar si es prerelease y canal\\n+          if [[ \\\"$NEW_VERSION\\\" == *\\\"alpha\\\"* ]]; then\\n+            echo \\\"is_prerelease=true\\\" >> $GITHUB_OUTPUT\\n+            echo \\\"release_channel=alpha\\\" >> $GITHUB_OUTPUT\\n+          elif [[ \\\"$NEW_VERSION\\\" == *\\\"beta\\\"* ]]; then\\n+            echo \\\"is_prerelease=true\\\" >> $GITHUB_OUTPUT  \\n+            echo \\\"release_channel=beta\\\" >> $GITHUB_OUTPUT\\n+          else\\n+            echo \\\"is_prerelease=false\\\" >> $GITHUB_OUTPUT\\n+            echo \\\"release_channel=latest\\\" >> $GITHUB_OUTPUT\\n+          fi\\n+          \\n+          echo \\\"📦 Nueva versión: $NEW_VERSION\\\"\\n+\\n+      - name: 📝 Generate changelog \\n+        id: changelog\\n+        run: |\\n+          # Usar project-utils para generar changelog si existe\\n+          if [ -f \\\"project-utils/.temp/commit-proposal\\\"*\\\".md\\\" ]; then\\n+            echo \\\"📋 Usando changelog de project-utils...\\\"\\n+            CHANGELOG=$(cat project-utils/.temp/commit-proposal*.md | head -n 20)\\n+          else\\n+            # Fallback a changelog tradicional\\n+            LAST_TAG=$(git describe --tags --abbrev=0 HEAD~1 2>/dev/null || echo \\\"\\\")\\n+            if [ -n \\\"$LAST_TAG\\\" ]; then\\n+              echo \\\"📋 Generando changelog desde $LAST_TAG...\\\"\\n+              CHANGELOG=$(git log $LAST_TAG..HEAD --pretty=format:\\\"- %s (%h)\\\")\\n+            else\\n+              echo \\\"📋 Changelog de release inicial...\\\"\\n+              CHANGELOG=\\\"- Initial release with complete Better Logger functionality\\\"\\n+            fi\\n+          fi\\n+          \\n+          # Guardar changelog en archivo para uso posterior\\n+          echo \\\"$CHANGELOG\\\" > RELEASE_CHANGELOG.md\\n+          echo \\\"changelog=$(echo \\\"$CHANGELOG\\\" | base64 -w 0)\\\" >> $GITHUB_OUTPUT\\n+\\n+      - name: 🏗️ Build optimized\\n+        run: |\\n+          npm run build\\n+          \\n+          # Verificar que todos los archivos esperados existen\\n+          echo \\\"📊 Verificando build outputs...\\\"\\n+          ls -la dist/\\n+          \\n+          # Guardar información de bundle sizes  \\n+          echo \\\"## 📦 Bundle Sizes\\\" > BUNDLE_SIZES.md\\n+          echo \\\"\\\\`\\\\`\\\\`\\\" >> BUNDLE_SIZES.md\\n+          ls -lh dist/*.js dist/*.cjs | grep -E '\\\\.(js|cjs)$' >> BUNDLE_SIZES.md\\n+          echo \\\"\\\\`\\\\`\\\\`\\\" >> BUNDLE_SIZES.md\\n+\\n+      - name: 📤 Upload build artifacts\\n+        uses: actions/upload-artifact@v4\\n+        with:\\n+          name: release-build-${{ steps.version.outputs.version }}\\n+          path: |\\n+            dist/\\n+            RELEASE_CHANGELOG.md\\n+            BUNDLE_SIZES.md\\n+          retention-days: 30\\n+\\n+  # ===== SMART PUBLISHING =====\\n+  publish-packages:\\n+    runs-on: ubuntu-latest\\n+    needs: prepare-release\\n+    if: ${{ inputs.target_registry == 'npm' || inputs.target_registry == 'both' }}\\n+    \\n+    steps:\\n+      - name: 📥 Checkout code\\n+        uses: actions/checkout@v4\\n+\\n+      - name: 📦 Setup Node.js for NPM\\n+        uses: actions/setup-node@v4\\n+        with:\\n+          node-version: ${{ env.NODE_VERSION }}\\n+          cache: 'npm'\\n+          registry-url: 'https://registry.npmjs.org'\\n+\\n+      - name: 📥 Download build artifacts\\n+        uses: actions/download-artifact@v4\\n+        with:\\n+          name: release-build-${{ needs.prepare-release.outputs.version }}\\n+\\n+      - name: 🔄 Update package version\\n+        run: npm version ${{ needs.prepare-release.outputs.version }} --no-git-tag-version\\n+\\n+      - name: 🚀 Publish to NPM\\n+        run: |\\n+          if [ \\\"${{ needs.prepare-release.outputs.is_prerelease }}\\\" == \\\"true\\\" ]; then\\n+            echo \\\"📦 Publishing prerelease to NPM with tag: ${{ needs.prepare-release.outputs.release_channel }}\\\"\\n+            npm publish --access public --tag ${{ needs.prepare-release.outputs.release_channel }}\\n+          else\\n+            echo \\\"📦 Publishing stable release to NPM\\\"\\n+            npm publish --access public\\n+          fi\\n+        env:\\n+          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}\\n+\\n+  publish-github:\\n+    runs-on: ubuntu-latest\\n+    needs: prepare-release\\n+    if: ${{ inputs.target_registry == 'github' || inputs.target_registry == 'both' }}\\n+    \\n+    steps:\\n+      - name: 📥 Checkout code\\n+        uses: actions/checkout@v4\\n+\\n+      - name: 📦 Setup Node.js for GitHub Packages\\n+        uses: actions/setup-node@v4\\n+        with:\\n+          node-version: ${{ env.NODE_VERSION }}\\n+          cache: 'npm'\\n+          registry-url: 'https://npm.pkg.github.com'\\n+\\n+      - name: 📥 Download build artifacts\\n+        uses: actions/download-artifact@v4\\n+        with:\\n+          name: release-build-${{ needs.prepare-release.outputs.version }}\\n+\\n+      - name: 🔄 Update package version\\n+        run: npm version ${{ needs.prepare-release.outputs.version }} --no-git-tag-version\\n+\\n+      - name: 📦 Publish to GitHub Packages\\n+        run: |\\n+          if [ \\\"${{ needs.prepare-release.outputs.is_prerelease }}\\\" == \\\"true\\\" ]; then\\n+            echo \\\"📦 Publishing prerelease to GitHub Packages with tag: ${{ needs.prepare-release.outputs.release_channel }}\\\"\\n+            npm publish --access public --tag ${{ needs.prepare-release.outputs.release_channel }}\\n+          else\\n+            echo \\\"📦 Publishing stable release to GitHub Packages\\\" \\n+            npm publish --access public\\n+          fi\\n+        env:\\n+          NODE_AUTH_TOKEN: ${{ secrets.GITHUB_TOKEN }}\\n+\\n+  # ===== GITHUB RELEASE =====\\n+  create-github-release:\\n+    runs-on: ubuntu-latest\\n+    needs: [prepare-release, publish-packages, publish-github]\\n+    if: always() && needs.prepare-release.result == 'success'\\n+    \\n+    permissions:\\n+      contents: write\\n+      id-token: write\\n+    \\n+    steps:\\n+      - name: 📥 Checkout code  \\n+        uses: actions/checkout@v4\\n+        with:\\n+          fetch-depth: 0\\n+          token: ${{ secrets.GITHUB_TOKEN }}\\n+\\n+      - name: 📥 Download build artifacts\\n+        uses: actions/download-artifact@v4\\n+        with:\\n+          name: release-build-${{ needs.prepare-release.outputs.version }}\\n+\\n+      - name: 📦 Create release archives\\n+        run: |\\n+          VERSION=${{ needs.prepare-release.outputs.version }}\\n+          \\n+          # Crear archivos de distribución\\n+          tar -czf better-logger-${VERSION}.tar.gz dist/ docs/ README.md package.json\\n+          zip -r better-logger-${VERSION}.zip dist/ docs/ README.md package.json\\n+          \\n+          # Crear paquetes modulares\\n+          cd dist\\n+          tar -czf ../better-logger-core-${VERSION}.tar.gz core.* types/core.d.ts 2>/dev/null || true\\n+          tar -czf ../better-logger-styling-${VERSION}.tar.gz styling.* types/styling.d.ts 2>/dev/null || true\\n+          tar -czf ../better-logger-exports-${VERSION}.tar.gz exports.* types/exports.d.ts 2>/dev/null || true\\n+          cd ..\\n+\\n+      - name: 🏷️ Commit and tag\\n+        run: |\\n+          git config user.name \\\"github-actions[bot]\\\"\\n+          git config user.email \\\"github-actions[bot]@users.noreply.github.com\\\"\\n+          git add package.json\\n+          git commit -m \\\"chore: release ${{ needs.prepare-release.outputs.version }}\\\" || true\\n+          git tag -a \\\"${{ needs.prepare-release.outputs.tag }}\\\" -m \\\"Release ${{ needs.prepare-release.outputs.version }}\\\"\\n+          git push origin main --tags\\n+\\n+      - name: 📝 Prepare release notes\\n+        run: |\\n+          VERSION=${{ needs.prepare-release.outputs.version }}\\n+          CHANGELOG=$(echo \\\"${{ needs.prepare-release.outputs.changelog }}\\\" | base64 -d)\\n+          \\n+          echo \\\"# Better Logger ${VERSION}\\\" > FINAL_RELEASE_NOTES.md\\n+          echo \\\"\\\" >> FINAL_RELEASE_NOTES.md\\n+          \\n+          if [ \\\"${{ needs.prepare-release.outputs.is_prerelease }}\\\" == \\\"true\\\" ]; then\\n+            echo \\\"⚠️ **This is a pre-release version** - Not recommended for production use.\\\" >> FINAL_RELEASE_NOTES.md\\n+            echo \\\"\\\" >> FINAL_RELEASE_NOTES.md\\n+          fi\\n+          \\n+          echo \\\"## 🔄 Changes\\\" >> FINAL_RELEASE_NOTES.md\\n+          echo \\\"$CHANGELOG\\\" >> FINAL_RELEASE_NOTES.md\\n+          echo \\\"\\\" >> FINAL_RELEASE_NOTES.md\\n+          \\n+          cat BUNDLE_SIZES.md >> FINAL_RELEASE_NOTES.md\\n+          echo \\\"\\\" >> FINAL_RELEASE_NOTES.md\\n+          \\n+          echo \\\"## 📦 Installation\\\" >> FINAL_RELEASE_NOTES.md\\n+          if [ \\\"${{ needs.prepare-release.outputs.is_prerelease }}\\\" == \\\"true\\\" ]; then\\n+            echo \\\"\\\\`\\\\`\\\\`bash\\\" >> FINAL_RELEASE_NOTES.md\\n+            echo \\\"npm install @mks2508/better-logger@${{ needs.prepare-release.outputs.release_channel }}\\\" >> FINAL_RELEASE_NOTES.md\\n+            echo \\\"\\\\`\\\\`\\\\`\\\" >> FINAL_RELEASE_NOTES.md\\n+          else\\n+            echo \\\"\\\\`\\\\`\\\\`bash\\\" >> FINAL_RELEASE_NOTES.md  \\n+            echo \\\"npm install @mks2508/better-logger\\\" >> FINAL_RELEASE_NOTES.md\\n+            echo \\\"\\\\`\\\\`\\\\`\\\" >> FINAL_RELEASE_NOTES.md\\n+          fi\\n+\\n+      - name: 🚀 Create GitHub Release\\n+        uses: softprops/action-gh-release@v1\\n+        with:\\n+          tag_name: ${{ needs.prepare-release.outputs.tag }}\\n+          name: Better Logger ${{ needs.prepare-release.outputs.version }}\\n+          body_path: FINAL_RELEASE_NOTES.md\\n+          draft: false\\n+          prerelease: ${{ needs.prepare-release.outputs.is_prerelease == 'true' }}\\n+          files: |\\n+            better-logger-${{ needs.prepare-release.outputs.version }}.tar.gz\\n+            better-logger-${{ needs.prepare-release.outputs.version }}.zip\\n+            better-logger-core-${{ needs.prepare-release.outputs.version }}.tar.gz\\n+            better-logger-styling-${{ needs.prepare-release.outputs.version }}.tar.gz  \\n+            better-logger-exports-${{ needs.prepare-release.outputs.version }}.tar.gz\\n+        env:\\n+          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\\n+\\n+  # ===== POST-RELEASE SUMMARY =====\\n+  release-summary:\\n+    runs-on: ubuntu-latest\\n+    needs: [prepare-release, publish-packages, publish-github, create-github-release]\\n+    if: always() && needs.prepare-release.result == 'success'\\n+    \\n+    steps:\\n+      - name: 📊 Release Summary  \\n+        run: |\\n+          VERSION=\\\"${{ needs.prepare-release.outputs.version }}\\\"\\n+          TAG=\\\"${{ needs.prepare-release.outputs.tag }}\\\"\\n+          CHANNEL=\\\"${{ needs.prepare-release.outputs.release_channel }}\\\"\\n+          IS_PRERELEASE=\\\"${{ needs.prepare-release.outputs.is_prerelease }}\\\"\\n+          \\n+          echo \\\"## 🎉 Release Complete!\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"- **Version**: $VERSION\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"- **Channel**: $CHANNEL\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"- **Prerelease**: $IS_PRERELEASE\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"\\\" >> $GITHUB_STEP_SUMMARY\\n+          \\n+          echo \\\"### 🔗 Links\\\" >> $GITHUB_STEP_SUMMARY\\n+          if [ \\\"${{ inputs.target_registry == 'npm' || inputs.target_registry == 'both' }}\\\" ]; then\\n+            echo \\\"- **NPM**: https://www.npmjs.com/package/@mks2508/better-logger\\\" >> $GITHUB_STEP_SUMMARY\\n+          fi\\n+          if [ \\\"${{ inputs.target_registry == 'github' || inputs.target_registry == 'both' }}\\\" ]; then\\n+            echo \\\"- **GitHub Packages**: https://github.com/MKS2508/advanced-logger/packages/\\\" >> $GITHUB_STEP_SUMMARY  \\n+          fi\\n+          echo \\\"- **GitHub Release**: https://github.com/MKS2508/advanced-logger/releases/tag/$TAG\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"- **Documentation**: https://mks2508.github.io/advanced-logger/\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"\\\" >> $GITHUB_STEP_SUMMARY\\n+          \\n+          echo \\\"### 📦 Installation\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"\\\\`\\\\`\\\\`bash\\\" >> $GITHUB_STEP_SUMMARY\\n+          if [ \\\"$IS_PRERELEASE\\\" == \\\"true\\\" ]; then\\n+            echo \\\"npm install @mks2508/better-logger@$CHANNEL\\\" >> $GITHUB_STEP_SUMMARY\\n+          else  \\n+            echo \\\"npm install @mks2508/better-logger\\\" >> $GITHUB_STEP_SUMMARY\\n+          fi\\n+          echo \\\"\\\\`\\\\`\\\\`\\\" >> $GITHUB_STEP_SUMMARY\\n\\\\ No newline at end of file\",\n+      \"lines_added\": 373,\n+      \"lines_removed\": 0,\n+      \"is_binary\": false\n+    },\n+    {\n+      \"path\": \".github/workflows/release.yml -> .github/workflows-backup/release.yml\",\n+      \"status\": \"renamed\",\n+      \"diff\": \"\"\n+    },\n+    {\n+      \"path\": \".github/workflows/ci-quality.yml\",\n+      \"status\": \"added\",\n+      \"diff\": \"diff --git a/.github/workflows/ci-quality.yml b/.github/workflows/ci-quality.yml\\nnew file mode 100644\\nindex 0000000..5974ff0\\n--- /dev/null\\n+++ b/.github/workflows/ci-quality.yml\\n@@ -0,0 +1,357 @@\\n+name: CI Quality & Testing\\n+\\n+on:\\n+  push:\\n+    branches: [ main, develop ]\\n+  pull_request:\\n+    branches: [ main, develop ]\\n+  workflow_dispatch:\\n+    inputs:\\n+      run_performance:\\n+        description: 'Ejecutar tests de performance'\\n+        required: false\\n+        default: true\\n+        type: boolean\\n+      run_visual:\\n+        description: 'Ejecutar tests visuales'\\n+        required: false\\n+        default: false\\n+        type: boolean\\n+\\n+env:\\n+  NODE_VERSION: '20'\\n+\\n+jobs:\\n+  # ===== MATRIX TESTING =====\\n+  test-matrix:\\n+    runs-on: ubuntu-latest\\n+    \\n+    strategy:\\n+      fail-fast: false\\n+      matrix:\\n+        node-version: [18, 20, 21]\\n+        build-mode: [full, core, styling, exports]\\n+    \\n+    name: Test Node ${{ matrix.node-version }} - ${{ matrix.build-mode }}\\n+    \\n+    steps:\\n+      - name: 📥 Checkout code\\n+        uses: actions/checkout@v4\\n+        with:\\n+          fetch-depth: 0\\n+\\n+      - name: 📦 Setup Node.js ${{ matrix.node-version }}\\n+        uses: actions/setup-node@v4\\n+        with:\\n+          node-version: ${{ matrix.node-version }}\\n+          cache: 'npm'\\n+\\n+      - name: 🔧 Install dependencies\\n+        run: npm run ci:install\\n+\\n+      - name: 🔍 Type checking\\n+        run: npm run type-check\\n+\\n+      - name: 🏗️ Build ${{ matrix.build-mode }}\\n+        run: |\\n+          if [ \\\"${{ matrix.build-mode }}\\\" = \\\"full\\\" ]; then\\n+            npm run build:all\\n+          else\\n+            npm run build:${{ matrix.build-mode }}\\n+          fi\\n+\\n+      - name: 🧪 Run tests\\n+        run: npm run ci:test\\n+\\n+      - name: 📊 Check bundle sizes\\n+        run: npm run size-limit\\n+\\n+      - name: 📤 Upload build artifacts (Node 20 only)\\n+        uses: actions/upload-artifact@v4\\n+        if: matrix.node-version == 20\\n+        with:\\n+          name: build-${{ matrix.build-mode }}-node${{ matrix.node-version }}\\n+          path: dist/\\n+          retention-days: 7\\n+\\n+  # ===== PERFORMANCE TESTING =====\\n+  performance-tests:\\n+    runs-on: ubuntu-latest\\n+    needs: test-matrix\\n+    if: ${{ inputs.run_performance != false }}\\n+    \\n+    steps:\\n+      - name: 📥 Checkout code\\n+        uses: actions/checkout@v4\\n+\\n+      - name: 📦 Setup Node.js\\n+        uses: actions/setup-node@v4\\n+        with:\\n+          node-version: ${{ env.NODE_VERSION }}\\n+          cache: 'npm'\\n+\\n+      - name: 🔧 Install dependencies\\n+        run: npm run ci:install\\n+\\n+      - name: 📥 Download build artifacts\\n+        uses: actions/download-artifact@v4\\n+        with:\\n+          name: build-full-node20\\n+          path: dist/\\n+\\n+      - name: ⚡ Performance benchmarks\\n+        run: npm run test:performance\\n+\\n+      - name: 📊 Bundle analysis\\n+        run: |\\n+          echo \\\"## 📦 Bundle Analysis Report\\\" > performance-report.md\\n+          echo \\\"### Size Breakdown\\\" >> performance-report.md\\n+          echo \\\"\\\\`\\\\`\\\\`\\\" >> performance-report.md\\n+          ls -la dist/ >> performance-report.md\\n+          echo \\\"\\\\`\\\\`\\\\`\\\" >> performance-report.md\\n+          \\n+          echo \\\"### File Sizes by Module\\\" >> performance-report.md\\n+          for module in core styling exports; do\\n+            if [ -d \\\"dist/modular/$module\\\" ]; then\\n+              echo \\\"#### $module Module\\\" >> performance-report.md\\n+              echo \\\"\\\\`\\\\`\\\\`\\\" >> performance-report.md\\n+              ls -la dist/modular/$module/ >> performance-report.md\\n+              echo \\\"\\\\`\\\\`\\\\`\\\" >> performance-report.md\\n+            fi\\n+          done\\n+          \\n+          echo \\\"### Performance Metrics\\\" >> performance-report.md\\n+          echo \\\"- **Build Time**: $(date)\\\" >> performance-report.md\\n+          echo \\\"- **Node Version**: ${{ env.NODE_VERSION }}\\\" >> performance-report.md\\n+\\n+      - name: 📤 Upload performance report\\n+        uses: actions/upload-artifact@v4\\n+        with:\\n+          name: performance-report\\n+          path: performance-report.md\\n+          retention-days: 30\\n+\\n+  # ===== VISUAL TESTING =====\\n+  visual-tests:\\n+    runs-on: ubuntu-latest\\n+    needs: test-matrix\\n+    if: ${{ inputs.run_visual == true }}\\n+    \\n+    steps:\\n+      - name: 📥 Checkout code\\n+        uses: actions/checkout@v4\\n+\\n+      - name: 📦 Setup Node.js\\n+        uses: actions/setup-node@v4\\n+        with:\\n+          node-version: ${{ env.NODE_VERSION }}\\n+          cache: 'npm'\\n+\\n+      - name: 🔧 Install dependencies\\n+        run: npm run ci:install\\n+\\n+      - name: 📥 Download build artifacts\\n+        uses: actions/download-artifact@v4\\n+        with:\\n+          name: build-full-node20\\n+          path: dist/\\n+\\n+      - name: 🎭 Install Playwright\\n+        run: npx playwright install --with-deps chromium\\n+\\n+      - name: 🖼️ Run visual tests\\n+        run: npm run test:visual\\n+\\n+      - name: 📤 Upload test results\\n+        uses: actions/upload-artifact@v4\\n+        if: always()\\n+        with:\\n+          name: visual-test-results\\n+          path: test-results/\\n+          retention-days: 30\\n+\\n+      - name: 📤 Upload screenshots\\n+        uses: actions/upload-artifact@v4\\n+        if: failure()\\n+        with:\\n+          name: visual-test-failures\\n+          path: test-results/\\n+          retention-days: 30\\n+\\n+  # ===== SECURITY AUDIT =====\\n+  security-audit:\\n+    runs-on: ubuntu-latest\\n+    \\n+    steps:\\n+      - name: 📥 Checkout code\\n+        uses: actions/checkout@v4\\n+\\n+      - name: 📦 Setup Node.js\\n+        uses: actions/setup-node@v4\\n+        with:\\n+          node-version: ${{ env.NODE_VERSION }}\\n+          cache: 'npm'\\n+\\n+      - name: 🔒 Security audit\\n+        run: |\\n+          echo \\\"🔒 Running security audit...\\\"\\n+          npm audit --audit-level=high || echo \\\"Security issues detected, review required\\\"\\n+\\n+      - name: 📊 Check for outdated packages\\n+        run: |\\n+          echo \\\"📊 Checking for outdated packages...\\\"\\n+          npm outdated || true\\n+\\n+      - name: 🔍 Vulnerability report\\n+        run: |\\n+          echo \\\"## 🔒 Security Audit Report\\\" > security-report.md\\n+          echo \\\"### NPM Audit Results\\\" >> security-report.md\\n+          echo \\\"\\\\`\\\\`\\\\`\\\" >> security-report.md\\n+          npm audit --audit-level=moderate >> security-report.md || echo \\\"No critical vulnerabilities\\\" >> security-report.md\\n+          echo \\\"\\\\`\\\\`\\\\`\\\" >> security-report.md\\n+          \\n+          echo \\\"### Outdated Packages\\\" >> security-report.md\\n+          echo \\\"\\\\`\\\\`\\\\`\\\" >> security-report.md\\n+          npm outdated >> security-report.md || echo \\\"All packages up to date\\\" >> security-report.md\\n+          echo \\\"\\\\`\\\\`\\\\`\\\" >> security-report.md\\n+\\n+      - name: 📤 Upload security report\\n+        uses: actions/upload-artifact@v4\\n+        with:\\n+          name: security-report\\n+          path: security-report.md\\n+          retention-days: 30\\n+\\n+  # ===== CODE QUALITY ANALYSIS =====\\n+  code-quality:\\n+    runs-on: ubuntu-latest\\n+    needs: test-matrix\\n+    \\n+    steps:\\n+      - name: 📥 Checkout code\\n+        uses: actions/checkout@v4\\n+\\n+      - name: 📦 Setup Node.js\\n+        uses: actions/setup-node@v4\\n+        with:\\n+          node-version: ${{ env.NODE_VERSION }}\\n+          cache: 'npm'\\n+\\n+      - name: 🔧 Install dependencies\\n+        run: npm run ci:install\\n+\\n+      - name: 🔍 Code analysis\\n+        run: |\\n+          echo \\\"🔍 Analyzing code quality...\\\"\\n+          \\n+          # Análisis básico de código\\n+          echo \\\"## 📊 Code Quality Report\\\" > quality-report.md\\n+          echo \\\"### TypeScript Analysis\\\" >> quality-report.md\\n+          echo \\\"\\\\`\\\\`\\\\`\\\" >> quality-report.md\\n+          npm run type-check >> quality-report.md 2>&1 || echo \\\"TypeScript issues detected\\\" >> quality-report.md\\n+          echo \\\"\\\\`\\\\`\\\\`\\\" >> quality-report.md\\n+          \\n+          echo \\\"### File Statistics\\\" >> quality-report.md\\n+          echo \\\"- **Total TypeScript files**: $(find src/ -name '*.ts' | wc -l)\\\" >> quality-report.md\\n+          echo \\\"- **Total lines of code**: $(find src/ -name '*.ts' -exec wc -l {} + | tail -1 | awk '{print $1}')\\\" >> quality-report.md\\n+          echo \\\"- **Build date**: $(date)\\\" >> quality-report.md\\n+\\n+      - name: 📤 Upload quality report\\n+        uses: actions/upload-artifact@v4\\n+        with:\\n+          name: code-quality-report\\n+          path: quality-report.md\\n+          retention-days: 30\\n+\\n+  # ===== PROJECT UTILS VALIDATION =====\\n+  validate-project-utils:\\n+    runs-on: ubuntu-latest\\n+    \\n+    steps:\\n+      - name: 📥 Checkout code\\n+        uses: actions/checkout@v4\\n+\\n+      - name: 📦 Setup Node.js\\n+        uses: actions/setup-node@v4\\n+        with:\\n+          node-version: ${{ env.NODE_VERSION }}\\n+          cache: 'npm'\\n+\\n+      - name: 🔧 Install dependencies\\n+        run: npm run ci:install\\n+\\n+      - name: 🧪 Test project-utils scripts\\n+        run: |\\n+          echo \\\"🧪 Validating project-utils scripts...\\\"\\n+          \\n+          # Verificar que los scripts existan y sean ejecutables\\n+          SCRIPTS=(\\\"commit-generator.ts\\\" \\\"version-manager.ts\\\" \\\"github-release-manager.ts\\\" \\\"auto-release-gemini.ts\\\")\\n+          \\n+          for script in \\\"${SCRIPTS[@]}\\\"; do\\n+            if [ -f \\\"project-utils/$script\\\" ]; then\\n+              echo \\\"✅ $script exists\\\"\\n+              # Verificar sintaxis básica\\n+              node --check \\\"project-utils/$script\\\" && echo \\\"✅ $script syntax OK\\\" || echo \\\"❌ $script syntax error\\\"\\n+            else\\n+              echo \\\"❌ $script missing\\\"\\n+            fi\\n+          done\\n+\\n+      - name: 📊 Validate package.json scripts\\n+        run: |\\n+          echo \\\"📊 Validating package.json scripts...\\\"\\n+          \\n+          # Verificar scripts críticos\\n+          CRITICAL_SCRIPTS=(\\\"build\\\" \\\"build:all\\\" \\\"commit:auto\\\" \\\"version:auto\\\" \\\"workflow:full\\\")\\n+          \\n+          for script in \\\"${CRITICAL_SCRIPTS[@]}\\\"; do\\n+            if npm run --silent \\\"$script\\\" --help >/dev/null 2>&1; then\\n+              echo \\\"✅ Script '$script' is valid\\\"\\n+            else\\n+              echo \\\"❌ Script '$script' has issues\\\"\\n+            fi\\n+          done\\n+\\n+  # ===== COMPREHENSIVE SUMMARY =====\\n+  ci-summary:\\n+    runs-on: ubuntu-latest\\n+    needs: [test-matrix, performance-tests, visual-tests, security-audit, code-quality, validate-project-utils]\\n+    if: always()\\n+    \\n+    steps:\\n+      - name: 📊 CI Quality Summary\\n+        run: |\\n+          echo \\\"## 📊 CI Quality & Testing Summary\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"\\\" >> $GITHUB_STEP_SUMMARY\\n+          \\n+          # Status de cada job\\n+          echo \\\"### 🧪 Test Results\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"- **Matrix Testing**: ${{ needs.test-matrix.result }}\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"- **Performance Tests**: ${{ needs.performance-tests.result }}\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"- **Visual Tests**: ${{ needs.visual-tests.result }}\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"- **Security Audit**: ${{ needs.security-audit.result }}\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"- **Code Quality**: ${{ needs.code-quality.result }}\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"- **Project Utils**: ${{ needs.validate-project-utils.result }}\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"\\\" >> $GITHUB_STEP_SUMMARY\\n+          \\n+          echo \\\"### 📋 Coverage Matrix\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"- **Node Versions**: 18, 20, 21\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"- **Build Modes**: full, core, styling, exports\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"- **Test Types**: unit, performance, visual, security\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"\\\" >> $GITHUB_STEP_SUMMARY\\n+          \\n+          # Determinar estado general\\n+          if [ \\\"${{ needs.test-matrix.result }}\\\" = \\\"success\\\" ] && [ \\\"${{ needs.security-audit.result }}\\\" = \\\"success\\\" ] && [ \\\"${{ needs.code-quality.result }}\\\" = \\\"success\\\" ]; then\\n+            echo \\\"### ✅ Overall Status: PASSED\\\" >> $GITHUB_STEP_SUMMARY\\n+            echo \\\"All critical quality checks passed successfully.\\\" >> $GITHUB_STEP_SUMMARY\\n+          else\\n+            echo \\\"### ⚠️ Overall Status: ATTENTION REQUIRED\\\" >> $GITHUB_STEP_SUMMARY\\n+            echo \\\"Some quality checks require attention. Review individual job results.\\\" >> $GITHUB_STEP_SUMMARY\\n+          fi\\n+          \\n+          echo \\\"\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"### 📎 Artifacts Generated\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"- Build artifacts for all modules\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"- Performance analysis report\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"- Security audit report\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"- Code quality metrics\\\" >> $GITHUB_STEP_SUMMARY\\n\\\\ No newline at end of file\",\n+      \"lines_added\": 357,\n+      \"lines_removed\": 0,\n+      \"is_binary\": false\n+    },\n+    {\n+      \"path\": \".github/workflows/docs-demo.yml\",\n+      \"status\": \"added\",\n+      \"diff\": \"diff --git a/.github/workflows/docs-demo.yml b/.github/workflows/docs-demo.yml\\nnew file mode 100644\\nindex 0000000..f7c4cd3\\n--- /dev/null\\n+++ b/.github/workflows/docs-demo.yml\\n@@ -0,0 +1,125 @@\\n+name: Docs & Demo Deployment\\n+\\n+on:\\n+  push:\\n+    branches: [ main ]\\n+    paths: \\n+      - 'docs/**'\\n+      - 'demo.html'\\n+      - 'index.html'\\n+      - 'src/**'\\n+  workflow_dispatch:\\n+\\n+env:\\n+  NODE_VERSION: '20'\\n+\\n+jobs:\\n+  # ===== BUILD DEMO =====\\n+  build-demo:\\n+    runs-on: ubuntu-latest\\n+    \\n+    steps:\\n+      - name: 📥 Checkout code\\n+        uses: actions/checkout@v4\\n+\\n+      - name: 📦 Setup Node.js\\n+        uses: actions/setup-node@v4\\n+        with:\\n+          node-version: ${{ env.NODE_VERSION }}\\n+          cache: 'npm'\\n+\\n+      - name: 🔧 Install dependencies\\n+        run: npm run ci:install\\n+\\n+      - name: 🏗️ Build library for demo\\n+        run: npm run build:full\\n+\\n+      - name: 🏗️ Setup demo structure\\n+        run: |\\n+          mkdir -p _site/docs\\n+          # Copy demo as root\\n+          cp demo.html _site/index.html\\n+          cp index.html _site/dev.html\\n+          cp -r dist/ _site/dist/\\n+          \\n+          # Create demo metadata\\n+          echo \\\"## 📦 Demo Build Info\\\" > _site/build-info.md\\n+          echo \\\"- **Build Date**: $(date)\\\" >> _site/build-info.md\\n+          echo \\\"- **Commit**: ${{ github.sha }}\\\" >> _site/build-info.md\\n+          echo \\\"- **Version**: $(node -p 'require(\\\"./package.json\\\").version')\\\" >> _site/build-info.md\\n+\\n+      - name: 📤 Upload demo artifacts\\n+        uses: actions/upload-artifact@v4\\n+        with:\\n+          name: demo-site\\n+          path: _site/\\n+          retention-days: 30\\n+\\n+  # ===== BUILD DOCS =====\\n+  build-docs:\\n+    runs-on: ubuntu-latest\\n+    \\n+    steps:\\n+      - name: 📥 Checkout code\\n+        uses: actions/checkout@v4\\n+\\n+      - name: 📤 Build Jekyll documentation\\n+        uses: actions/jekyll-build-pages@v1\\n+        with:\\n+          source: ./docs\\n+          destination: ./_site/docs\\n+\\n+      - name: 📤 Upload docs artifacts\\n+        uses: actions/upload-artifact@v4\\n+        with:\\n+          name: docs-site\\n+          path: _site/docs/\\n+          retention-days: 30\\n+\\n+  # ===== DEPLOY TO GITHUB PAGES =====\\n+  deploy-pages:\\n+    runs-on: ubuntu-latest\\n+    needs: [build-demo, build-docs]\\n+    if: github.ref == 'refs/heads/main'\\n+    \\n+    permissions:\\n+      contents: read\\n+      pages: write\\n+      id-token: write\\n+    \\n+    environment:\\n+      name: github-pages\\n+      url: ${{ steps.deployment.outputs.page_url }}\\n+    \\n+    steps:\\n+      - name: 📥 Download demo artifacts\\n+        uses: actions/download-artifact@v4\\n+        with:\\n+          name: demo-site\\n+          path: _site/\\n+\\n+      - name: 📥 Download docs artifacts\\n+        uses: actions/download-artifact@v4\\n+        with:\\n+          name: docs-site\\n+          path: _site/docs/\\n+\\n+      - name: 📤 Setup Pages\\n+        uses: actions/configure-pages@v4\\n+\\n+      - name: 📤 Upload to Pages\\n+        uses: actions/upload-pages-artifact@v3\\n+        with:\\n+          path: ./_site\\n+\\n+      - name: 🚀 Deploy to GitHub Pages\\n+        id: deployment\\n+        uses: actions/deploy-pages@v4\\n+\\n+      - name: 📊 Deployment summary\\n+        run: |\\n+          echo \\\"## 📝 Documentation & Demo Deployed!\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"- **Demo URL**: ${{ steps.deployment.outputs.page_url }}\\\" >> $GITHUB_STEP_SUMMARY  \\n+          echo \\\"- **Docs URL**: ${{ steps.deployment.outputs.page_url }}docs/\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"- **Dev Demo**: ${{ steps.deployment.outputs.page_url }}dev.html\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"- **Build Info**: ${{ steps.deployment.outputs.page_url }}build-info.md\\\" >> $GITHUB_STEP_SUMMARY\\n\\\\ No newline at end of file\",\n+      \"lines_added\": 125,\n+      \"lines_removed\": 0,\n+      \"is_binary\": false\n+    },\n+    {\n+      \"path\": \".github/workflows/nightly-auto.yml\",\n+      \"status\": \"added\",\n+      \"diff\": \"diff --git a/.github/workflows/nightly-auto.yml b/.github/workflows/nightly-auto.yml\\nnew file mode 100644\\nindex 0000000..c936f3d\\n--- /dev/null\\n+++ b/.github/workflows/nightly-auto.yml\\n@@ -0,0 +1,335 @@\\n+name: Nightly Builds with Smart Detection\\n+\\n+on:\\n+  schedule:\\n+    # Ejecutar cada día a las 3:00 AM UTC\\n+    - cron: '0 3 * * *'\\n+  workflow_dispatch:\\n+    inputs:\\n+      force_build:\\n+        description: 'Forzar build aunque no haya cambios'\\n+        required: false\\n+        default: false\\n+        type: boolean\\n+      include_prereleases:\\n+        description: 'Incluir cambios de prereleases en detección'\\n+        required: false\\n+        default: false\\n+        type: boolean\\n+\\n+env:\\n+  NODE_VERSION: '20'\\n+\\n+jobs:\\n+  # ===== SMART CHANGE DETECTION =====\\n+  detect-changes:\\n+    runs-on: ubuntu-latest\\n+    outputs:\\n+      has_changes: ${{ steps.changes.outputs.has_changes }}\\n+      change_type: ${{ steps.changes.outputs.change_type }}\\n+      last_commit: ${{ steps.changes.outputs.last_commit }}\\n+      commit_count: ${{ steps.changes.outputs.commit_count }}\\n+      significant_changes: ${{ steps.changes.outputs.significant_changes }}\\n+      files_changed: ${{ steps.changes.outputs.files_changed }}\\n+    \\n+    steps:\\n+      - name: 📥 Checkout code\\n+        uses: actions/checkout@v4\\n+        with:\\n+          fetch-depth: 0\\n+\\n+      - name: 🔍 Analyze changes since last nightly\\n+        id: changes\\n+        run: |\\n+          # Buscar último tag nightly\\n+          LAST_NIGHTLY=$(git tag -l \\\"nightly-*\\\" | sort -V | tail -1 || echo \\\"\\\")\\n+          LAST_RELEASE=$(git tag -l \\\"v*\\\" --exclude=\\\"nightly-*\\\" --exclude=\\\"*alpha*\\\" --exclude=\\\"*beta*\\\" | sort -V | tail -1 || echo \\\"\\\")\\n+          \\n+          if [ -z \\\"$LAST_NIGHTLY\\\" ] && [ -z \\\"$LAST_RELEASE\\\" ]; then\\n+            # No hay tags previos, verificar desde hace 24 horas\\n+            SINCE_DATE=$(date -d '24 hours ago' --iso-8601)\\n+            COMMITS_COUNT=$(git log --since=\\\"$SINCE_DATE\\\" --oneline | wc -l)\\n+            REFERENCE_POINT=\\\"24 hours ago\\\"\\n+          elif [ -n \\\"$LAST_NIGHTLY\\\" ] && [ -z \\\"$LAST_RELEASE\\\" ]; then\\n+            # Solo hay nightlies\\n+            COMMITS_COUNT=$(git log $LAST_NIGHTLY..HEAD --oneline | wc -l)\\n+            REFERENCE_POINT=$LAST_NIGHTLY\\n+          elif [ -z \\\"$LAST_NIGHTLY\\\" ] && [ -n \\\"$LAST_RELEASE\\\" ]; then\\n+            # Solo hay releases normales\\n+            COMMITS_COUNT=$(git log $LAST_RELEASE..HEAD --oneline | wc -l)\\n+            REFERENCE_POINT=$LAST_RELEASE\\n+          else\\n+            # Hay ambos, usar el más reciente\\n+            LAST_NIGHTLY_DATE=$(git log -1 --format=%ct $LAST_NIGHTLY)\\n+            LAST_RELEASE_DATE=$(git log -1 --format=%ct $LAST_RELEASE)\\n+            \\n+            if [ \\\"$LAST_NIGHTLY_DATE\\\" -gt \\\"$LAST_RELEASE_DATE\\\" ]; then\\n+              COMMITS_COUNT=$(git log $LAST_NIGHTLY..HEAD --oneline | wc -l)\\n+              REFERENCE_POINT=$LAST_NIGHTLY\\n+            else\\n+              COMMITS_COUNT=$(git log $LAST_RELEASE..HEAD --oneline | wc -l)\\n+              REFERENCE_POINT=$LAST_RELEASE\\n+            fi\\n+          fi\\n+          \\n+          LAST_COMMIT=$(git rev-parse --short HEAD)\\n+          \\n+          echo \\\"commit_count=$COMMITS_COUNT\\\" >> $GITHUB_OUTPUT\\n+          echo \\\"last_commit=$LAST_COMMIT\\\" >> $GITHUB_OUTPUT\\n+          \\n+          # Análisis inteligente de cambios\\n+          SIGNIFICANT_CHANGES=\\\"false\\\"\\n+          CHANGE_TYPE=\\\"maintenance\\\"\\n+          \\n+          if [ \\\"$COMMITS_COUNT\\\" -gt 0 ]; then\\n+            # Analizar tipos de cambios desde el punto de referencia\\n+            if [ \\\"$REFERENCE_POINT\\\" != \\\"24 hours ago\\\" ]; then\\n+              CHANGES_LOG=$(git log $REFERENCE_POINT..HEAD --pretty=format:\\\"%s\\\" --no-merges)\\n+            else\\n+              CHANGES_LOG=$(git log --since=\\\"24 hours ago\\\" --pretty=format:\\\"%s\\\" --no-merges)\\n+            fi\\n+            \\n+            # Detectar cambios significativos\\n+            if echo \\\"$CHANGES_LOG\\\" | grep -qE \\\"(feat|feature|add|new)\\\"; then\\n+              SIGNIFICANT_CHANGES=\\\"true\\\"\\n+              CHANGE_TYPE=\\\"feature\\\"\\n+            elif echo \\\"$CHANGES_LOG\\\" | grep -qE \\\"(fix|bug|repair|patch)\\\"; then\\n+              SIGNIFICANT_CHANGES=\\\"true\\\" \\n+              CHANGE_TYPE=\\\"bugfix\\\"\\n+            elif echo \\\"$CHANGES_LOG\\\" | grep -qE \\\"(perf|performance|optim|speed)\\\"; then\\n+              SIGNIFICANT_CHANGES=\\\"true\\\"\\n+              CHANGE_TYPE=\\\"performance\\\"\\n+            elif echo \\\"$CHANGES_LOG\\\" | grep -qE \\\"(refactor|restructure|rewrite)\\\"; then\\n+              CHANGE_TYPE=\\\"refactor\\\"\\n+            elif echo \\\"$CHANGES_LOG\\\" | grep -qE \\\"(docs|documentation|readme)\\\"; then\\n+              CHANGE_TYPE=\\\"documentation\\\"\\n+            fi\\n+            \\n+            # Analizar archivos modificados\\n+            if [ \\\"$REFERENCE_POINT\\\" != \\\"24 hours ago\\\" ]; then\\n+              FILES_CHANGED=$(git diff --name-only $REFERENCE_POINT..HEAD | wc -l)\\n+            else\\n+              FILES_CHANGED=$(git log --since=\\\"24 hours ago\\\" --name-only --pretty=format: | sort | uniq | wc -l)\\n+            fi\\n+          else\\n+            FILES_CHANGED=0\\n+          fi\\n+          \\n+          echo \\\"significant_changes=$SIGNIFICANT_CHANGES\\\" >> $GITHUB_OUTPUT\\n+          echo \\\"change_type=$CHANGE_TYPE\\\" >> $GITHUB_OUTPUT\\n+          echo \\\"files_changed=$FILES_CHANGED\\\" >> $GITHUB_OUTPUT\\n+          \\n+          # Determinar si hacer build\\n+          if [ \\\"$COMMITS_COUNT\\\" -gt 0 ] || [ \\\"${{ inputs.force_build }}\\\" == \\\"true\\\" ]; then\\n+            echo \\\"has_changes=true\\\" >> $GITHUB_OUTPUT\\n+            echo \\\"✅ Cambios detectados: $COMMITS_COUNT commits ($CHANGE_TYPE)\\\"\\n+            echo \\\"📊 Archivos modificados: $FILES_CHANGED\\\"\\n+            echo \\\"🔍 Desde: $REFERENCE_POINT\\\"\\n+          else\\n+            echo \\\"has_changes=false\\\" >> $GITHUB_OUTPUT  \\n+            echo \\\"ℹ️ No hay cambios desde último build\\\"\\n+          fi\\n+\\n+  # ===== INTELLIGENT NIGHTLY BUILD =====\\n+  nightly-build:\\n+    runs-on: ubuntu-latest\\n+    needs: detect-changes\\n+    if: needs.detect-changes.outputs.has_changes == 'true'\\n+    \\n+    permissions:\\n+      contents: write\\n+      packages: write\\n+      id-token: write\\n+    \\n+    outputs:\\n+      nightly_version: ${{ steps.version.outputs.version }}\\n+      nightly_tag: ${{ steps.version.outputs.tag }}\\n+    \\n+    steps:\\n+      - name: 📥 Checkout code\\n+        uses: actions/checkout@v4\\n+        with:\\n+          fetch-depth: 0\\n+          token: ${{ secrets.GITHUB_TOKEN }}\\n+\\n+      - name: 📦 Setup Node.js\\n+        uses: actions/setup-node@v4\\n+        with:\\n+          node-version: ${{ env.NODE_VERSION }}\\n+          cache: 'npm'\\n+\\n+      - name: 🔧 Install dependencies\\n+        run: npm run ci:install\\n+\\n+      - name: 🏗️ Build library with quality checks\\n+        run: |\\n+          npm run build:all\\n+          npm run type-check\\n+          npm run ci:test\\n+\\n+      - name: 🏷️ Generate intelligent nightly version\\n+        id: version\\n+        run: |\\n+          # Generar versión nightly inteligente\\n+          DATE=$(date +%Y%m%d)\\n+          TIME=$(date +%H%M)\\n+          SHORT_SHA=\\\"${{ needs.detect-changes.outputs.last_commit }}\\\"\\n+          BASE_VERSION=$(node -p \\\"require('./package.json').version\\\")\\n+          CHANGE_TYPE=\\\"${{ needs.detect-changes.outputs.change_type }}\\\"\\n+          \\n+          # Remover cualquier sufijo existente del base version\\n+          CLEAN_VERSION=$(echo $BASE_VERSION | sed 's/-.*//')\\n+          \\n+          # Crear versión con contexto inteligente\\n+          if [ \\\"${{ needs.detect-changes.outputs.significant_changes }}\\\" == \\\"true\\\" ]; then\\n+            NIGHTLY_VERSION=\\\"${CLEAN_VERSION}-nightly.${DATE}.${CHANGE_TYPE}.${SHORT_SHA}\\\"\\n+          else\\n+            NIGHTLY_VERSION=\\\"${CLEAN_VERSION}-nightly.${DATE}.${SHORT_SHA}\\\"\\n+          fi\\n+          \\n+          NIGHTLY_TAG=\\\"nightly-${DATE}-${TIME}-${SHORT_SHA}\\\"\\n+          \\n+          echo \\\"version=$NIGHTLY_VERSION\\\" >> $GITHUB_OUTPUT\\n+          echo \\\"tag=$NIGHTLY_TAG\\\" >> $GITHUB_OUTPUT\\n+          echo \\\"🌙 Nightly version: $NIGHTLY_VERSION\\\"\\n+          echo \\\"🏷️ Nightly tag: $NIGHTLY_TAG\\\"\\n+\\n+      - name: 📝 Update package for nightly\\n+        run: |\\n+          npm version ${{ steps.version.outputs.version }} --no-git-tag-version\\n+\\n+      - name: 📊 Generate build report\\n+        run: |\\n+          mkdir -p nightly-reports\\n+          \\n+          echo \\\"# Nightly Build Report\\\" > nightly-reports/build-report.md\\n+          echo \\\"- **Version**: ${{ steps.version.outputs.version }}\\\" >> nightly-reports/build-report.md\\n+          echo \\\"- **Build Date**: $(date)\\\" >> nightly-reports/build-report.md\\n+          echo \\\"- **Commit**: ${{ needs.detect-changes.outputs.last_commit }}\\\" >> nightly-reports/build-report.md\\n+          echo \\\"- **Commits Since Last**: ${{ needs.detect-changes.outputs.commit_count }}\\\" >> nightly-reports/build-report.md\\n+          echo \\\"- **Files Changed**: ${{ needs.detect-changes.outputs.files_changed }}\\\" >> nightly-reports/build-report.md\\n+          echo \\\"- **Change Type**: ${{ needs.detect-changes.outputs.change_type }}\\\" >> nightly-reports/build-report.md\\n+          echo \\\"- **Significant Changes**: ${{ needs.detect-changes.outputs.significant_changes }}\\\" >> nightly-reports/build-report.md\\n+          echo \\\"\\\" >> nightly-reports/build-report.md\\n+          \\n+          echo \\\"## Bundle Sizes\\\" >> nightly-reports/build-report.md\\n+          echo \\\"\\\\`\\\\`\\\\`\\\" >> nightly-reports/build-report.md\\n+          ls -lh dist/*.js dist/*.cjs 2>/dev/null | grep -E '\\\\.(js|cjs)$' >> nightly-reports/build-report.md\\n+          echo \\\"\\\\`\\\\`\\\\`\\\" >> nightly-reports/build-report.md\\n+\\n+      - name: 📦 Create nightly archives  \\n+        run: |\\n+          mkdir -p nightly-dist\\n+          VERSION=${{ steps.version.outputs.version }}\\n+          TAG=${{ steps.version.outputs.tag }}\\n+          \\n+          # Archivos completos\\n+          tar -czf nightly-dist/better-logger-nightly-${TAG}.tar.gz dist/ nightly-reports/ README.md package.json\\n+          zip -r nightly-dist/better-logger-nightly-${TAG}.zip dist/ nightly-reports/ README.md package.json\\n+          \\n+          # Archivos modulares (si existen)\\n+          for module in core styling exports; do\\n+            if [ -d \\\"dist/modular/$module\\\" ]; then\\n+              tar -czf nightly-dist/better-logger-${module}-nightly-${TAG}.tar.gz dist/modular/${module}/ README.md package.json\\n+            fi\\n+          done\\n+\\n+      - name: 🚀 Publish nightly to NPM\\n+        run: |\\n+          npm publish --tag nightly --access public\\n+        env:\\n+          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}\\n+\\n+      - name: 📦 Publish nightly to GitHub Packages  \\n+        run: |\\n+          echo \\\"//npm.pkg.github.com/:_authToken=${{ secrets.GITHUB_TOKEN }}\\\" >> ~/.npmrc\\n+          echo \\\"@mks2508:registry=https://npm.pkg.github.com\\\" >> ~/.npmrc\\n+          npm publish --registry=https://npm.pkg.github.com --tag nightly --access public\\n+\\n+      - name: 🏷️ Create nightly tag\\n+        run: |\\n+          git config user.name \\\"github-actions[bot]\\\"\\n+          git config user.email \\\"github-actions[bot]@users.noreply.github.com\\\" \\n+          git tag -a \\\"${{ steps.version.outputs.tag }}\\\" -m \\\"Nightly build ${{ steps.version.outputs.version }} (${{ needs.detect-changes.outputs.change_type }})\\\"\\n+          git push origin \\\"${{ steps.version.outputs.tag }}\\\"\\n+\\n+      - name: 🌙 Create intelligent nightly release\\n+        uses: softprops/action-gh-release@v1\\n+        with:\\n+          tag_name: ${{ steps.version.outputs.tag }}\\n+          name: \\\"🌙 Nightly Build ${{ steps.version.outputs.version }}\\\"\\n+          body: |\\n+            🌙 **Nightly Build** - Experimental version for testing\\n+            \\n+            **⚠️ This is a development build - not recommended for production use**\\n+            \\n+            ## 📊 Build Analysis\\n+            - **Change Type**: ${{ needs.detect-changes.outputs.change_type }}\\n+            - **Significant Changes**: ${{ needs.detect-changes.outputs.significant_changes }}\\n+            - **Commits**: ${{ needs.detect-changes.outputs.commit_count }}\\n+            - **Files Modified**: ${{ needs.detect-changes.outputs.files_changed }}\\n+            \\n+            ## 🔄 What's Included\\n+            ${{ needs.detect-changes.outputs.change_type == 'feature' && '✨ New features and enhancements' || '' }}\\n+            ${{ needs.detect-changes.outputs.change_type == 'bugfix' && '🐛 Bug fixes and patches' || '' }}\\n+            ${{ needs.detect-changes.outputs.change_type == 'performance' && '⚡ Performance improvements' || '' }}\\n+            ${{ needs.detect-changes.outputs.change_type == 'refactor' && '🔧 Code refactoring and improvements' || '' }}\\n+            ${{ needs.detect-changes.outputs.change_type == 'documentation' && '📝 Documentation updates' || '' }}\\n+            ${{ needs.detect-changes.outputs.change_type == 'maintenance' && '🧹 Maintenance and minor updates' || '' }}\\n+            \\n+            ## 📦 Installation\\n+            ```bash\\n+            npm install @mks2508/better-logger@nightly\\n+            ```\\n+            \\n+            ## 🔗 Links\\n+            - **Commit**: https://github.com/MKS2508/advanced-logger/commit/${{ needs.detect-changes.outputs.last_commit }}\\n+            - **NPM**: https://www.npmjs.com/package/@mks2508/better-logger/v/${{ steps.version.outputs.version }}\\n+            \\n+            ## ⏰ Auto-Generated\\n+            This nightly build was automatically generated and published based on detected changes.\\n+          draft: false\\n+          prerelease: true\\n+          files: |\\n+            nightly-dist/better-logger-nightly-${{ steps.version.outputs.tag }}.tar.gz  \\n+            nightly-dist/better-logger-nightly-${{ steps.version.outputs.tag }}.zip\\n+            nightly-dist/better-logger-*-nightly-${{ steps.version.outputs.tag }}.tar.gz\\n+            nightly-reports/build-report.md\\n+        env:\\n+          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\\n+\\n+      - name: 📊 Nightly build summary\\n+        run: |\\n+          echo \\\"## 🌙 Intelligent Nightly Build Complete!\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"- **Version**: ${{ steps.version.outputs.version }}\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"- **Change Type**: ${{ needs.detect-changes.outputs.change_type }}\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"- **Significant**: ${{ needs.detect-changes.outputs.significant_changes }}\\\" >> $GITHUB_STEP_SUMMARY  \\n+          echo \\\"- **Commits**: ${{ needs.detect-changes.outputs.commit_count }}\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"- **Files**: ${{ needs.detect-changes.outputs.files_changed }}\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"### 🔗 Links\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"- **NPM**: https://www.npmjs.com/package/@mks2508/better-logger/v/${{ steps.version.outputs.version }}\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"- **GitHub**: https://github.com/MKS2508/advanced-logger/releases/tag/${{ steps.version.outputs.tag }}\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"### 📦 Installation\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"\\\\`\\\\`\\\\`bash\\\" >> $GITHUB_STEP_SUMMARY  \\n+          echo \\\"npm install @mks2508/better-logger@nightly\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"\\\\`\\\\`\\\\`\\\" >> $GITHUB_STEP_SUMMARY\\n+\\n+  # ===== NO CHANGES HANDLER =====\\n+  no-changes:\\n+    runs-on: ubuntu-latest\\n+    needs: detect-changes\\n+    if: needs.detect-changes.outputs.has_changes == 'false'\\n+    \\n+    steps:\\n+      - name: ℹ️ No changes detected\\n+        run: |\\n+          echo \\\"## ℹ️ No Nightly Build Required\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"No significant changes detected since last nightly build.\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"### 🔍 Analysis Results\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"- **Commits**: ${{ needs.detect-changes.outputs.commit_count }}\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"- **Files Changed**: ${{ needs.detect-changes.outputs.files_changed }}\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"Use \\\\`workflow_dispatch\\\\` with \\\\`force_build: true\\\\` to force a build.\\\" >> $GITHUB_STEP_SUMMARY\\n\\\\ No newline at end of file\",\n+      \"lines_added\": 335,\n+      \"lines_removed\": 0,\n+      \"is_binary\": false\n+    },\n+    {\n+      \"path\": \".github/workflows/releases-core.yml\",\n+      \"status\": \"added\",\n+      \"diff\": \"diff --git a/.github/workflows/releases-core.yml b/.github/workflows/releases-core.yml\\nnew file mode 100644\\nindex 0000000..aa4b59c\\n--- /dev/null\\n+++ b/.github/workflows/releases-core.yml\\n@@ -0,0 +1,378 @@\\n+name: Core Modular Releases\\n+\\n+on:\\n+  workflow_dispatch:\\n+    inputs:\\n+      module:\\n+        description: 'Módulo a construir y publicar'\\n+        required: true\\n+        default: 'all'\\n+        type: choice\\n+        options:\\n+          - all\\n+          - core\\n+          - styling\\n+          - exports\\n+          - full\\n+      release_type:\\n+        description: 'Tipo de release'\\n+        required: true\\n+        default: 'patch'\\n+        type: choice\\n+        options:\\n+          - patch\\n+          - minor\\n+          - major\\n+          - alpha\\n+          - beta\\n+      target_registry:\\n+        description: 'Registro objetivo'\\n+        required: false\\n+        default: 'both'\\n+        type: choice\\n+        options:\\n+          - npm\\n+          - github\\n+          - both\\n+      skip_tests:\\n+        description: 'Saltar tests (no recomendado)'\\n+        required: false\\n+        default: false\\n+        type: boolean\\n+\\n+env:\\n+  NODE_VERSION: '20'\\n+\\n+jobs:\\n+  # ===== VALIDATION & VERSIONING =====\\n+  prepare-modular-release:\\n+    runs-on: ubuntu-latest\\n+    \\n+    outputs:\\n+      version: ${{ steps.version.outputs.version }}\\n+      tag: ${{ steps.version.outputs.tag }}\\n+      is_prerelease: ${{ steps.version.outputs.is_prerelease }}\\n+      release_channel: ${{ steps.version.outputs.release_channel }}\\n+      modules_to_build: ${{ steps.modules.outputs.modules }}\\n+    \\n+    steps:\\n+      - name: 📥 Checkout code\\n+        uses: actions/checkout@v4\\n+        with:\\n+          fetch-depth: 0\\n+          token: ${{ secrets.GITHUB_TOKEN }}\\n+\\n+      - name: 📦 Setup Node.js\\n+        uses: actions/setup-node@v4\\n+        with:\\n+          node-version: ${{ env.NODE_VERSION }}\\n+          cache: 'npm'\\n+\\n+      - name: 🔧 Install dependencies\\n+        run: npm run ci:install\\n+\\n+      - name: 🧪 Run tests (unless skipped)\\n+        if: ${{ !inputs.skip_tests }}\\n+        run: |\\n+          npm run type-check\\n+          npm run ci:test\\n+\\n+      - name: 🏷️ Generate version\\n+        id: version\\n+        run: |\\n+          npm run version:${{ inputs.release_type }}\\n+          \\n+          # Obtener nueva versión\\n+          NEW_VERSION=$(node -p \\\"require('./package.json').version\\\")\\n+          echo \\\"version=$NEW_VERSION\\\" >> $GITHUB_OUTPUT\\n+          echo \\\"tag=v$NEW_VERSION\\\" >> $GITHUB_OUTPUT\\n+          \\n+          # Determinar si es prerelease y canal\\n+          if [[ \\\"$NEW_VERSION\\\" == *\\\"alpha\\\"* ]]; then\\n+            echo \\\"is_prerelease=true\\\" >> $GITHUB_OUTPUT\\n+            echo \\\"release_channel=alpha\\\" >> $GITHUB_OUTPUT\\n+          elif [[ \\\"$NEW_VERSION\\\" == *\\\"beta\\\"* ]]; then\\n+            echo \\\"is_prerelease=true\\\" >> $GITHUB_OUTPUT  \\n+            echo \\\"release_channel=beta\\\" >> $GITHUB_OUTPUT\\n+          else\\n+            echo \\\"is_prerelease=false\\\" >> $GITHUB_OUTPUT\\n+            echo \\\"release_channel=latest\\\" >> $GITHUB_OUTPUT\\n+          fi\\n+          \\n+          echo \\\"📦 Nueva versión: $NEW_VERSION\\\"\\n+\\n+      - name: 🧩 Determine modules to build\\n+        id: modules\\n+        run: |\\n+          case \\\"${{ inputs.module }}\\\" in\\n+            \\\"all\\\") \\n+              MODULES='[\\\"core\\\", \\\"styling\\\", \\\"exports\\\", \\\"full\\\"]'\\n+              ;;\\n+            \\\"core\\\"|\\\"styling\\\"|\\\"exports\\\"|\\\"full\\\")\\n+              MODULES='[\\\"${{ inputs.module }}\\\"]'\\n+              ;;\\n+          esac\\n+          echo \\\"modules=$MODULES\\\" >> $GITHUB_OUTPUT\\n+          echo \\\"📦 Módulos a construir: $MODULES\\\"\\n+\\n+  # ===== MODULAR BUILDS =====\\n+  build-modules:\\n+    runs-on: ubuntu-latest\\n+    needs: prepare-modular-release\\n+    \\n+    strategy:\\n+      matrix:\\n+        module: ${{ fromJson(needs.prepare-modular-release.outputs.modules_to_build) }}\\n+    \\n+    steps:\\n+      - name: 📥 Checkout code\\n+        uses: actions/checkout@v4\\n+\\n+      - name: 📦 Setup Node.js\\n+        uses: actions/setup-node@v4\\n+        with:\\n+          node-version: ${{ env.NODE_VERSION }}\\n+          cache: 'npm'\\n+\\n+      - name: 🔧 Install dependencies\\n+        run: npm run ci:install\\n+\\n+      - name: 🔄 Update package version\\n+        run: npm version ${{ needs.prepare-modular-release.outputs.version }} --no-git-tag-version\\n+\\n+      - name: 🏗️ Build module ${{ matrix.module }}\\n+        run: |\\n+          if [ \\\"${{ matrix.module }}\\\" = \\\"full\\\" ]; then\\n+            npm run build:full\\n+          else\\n+            npm run build:${{ matrix.module }}\\n+          fi\\n+\\n+      - name: 📦 Create module archives\\n+        run: |\\n+          VERSION=${{ needs.prepare-modular-release.outputs.version }}\\n+          MODULE=${{ matrix.module }}\\n+          \\n+          if [ \\\"$MODULE\\\" = \\\"full\\\" ]; then\\n+            # Build completa - todos los archivos\\n+            tar -czf better-logger-${MODULE}-${VERSION}.tar.gz dist/ README.md package.json\\n+            zip -r better-logger-${MODULE}-${VERSION}.zip dist/ README.md package.json\\n+          else\\n+            # Build modular - solo archivos específicos\\n+            tar -czf better-logger-${MODULE}-${VERSION}.tar.gz dist/modular/${MODULE}/ README.md package.json\\n+            zip -r better-logger-${MODULE}-${VERSION}.zip dist/modular/${MODULE}/ README.md package.json\\n+          fi\\n+\\n+      - name: 📤 Upload module artifacts\\n+        uses: actions/upload-artifact@v4\\n+        with:\\n+          name: module-${{ matrix.module }}-${{ needs.prepare-modular-release.outputs.version }}\\n+          path: |\\n+            better-logger-${{ matrix.module }}-${{ needs.prepare-modular-release.outputs.version }}.*\\n+            dist/\\n+            package.json\\n+          retention-days: 30\\n+\\n+  # ===== PUBLISH TO NPM =====\\n+  publish-npm:\\n+    runs-on: ubuntu-latest\\n+    needs: [prepare-modular-release, build-modules]\\n+    if: ${{ inputs.target_registry == 'npm' || inputs.target_registry == 'both' }}\\n+    \\n+    strategy:\\n+      matrix:\\n+        module: ${{ fromJson(needs.prepare-modular-release.outputs.modules_to_build) }}\\n+    \\n+    steps:\\n+      - name: 📥 Checkout code\\n+        uses: actions/checkout@v4\\n+\\n+      - name: 📦 Setup Node.js for NPM\\n+        uses: actions/setup-node@v4\\n+        with:\\n+          node-version: ${{ env.NODE_VERSION }}\\n+          cache: 'npm'\\n+          registry-url: 'https://registry.npmjs.org'\\n+\\n+      - name: 📥 Download module artifacts\\n+        uses: actions/download-artifact@v4\\n+        with:\\n+          name: module-${{ matrix.module }}-${{ needs.prepare-modular-release.outputs.version }}\\n+\\n+      - name: 🔄 Update package version\\n+        run: npm version ${{ needs.prepare-modular-release.outputs.version }} --no-git-tag-version\\n+\\n+      - name: 🚀 Publish ${{ matrix.module }} to NPM\\n+        run: |\\n+          if [ \\\"${{ needs.prepare-modular-release.outputs.is_prerelease }}\\\" == \\\"true\\\" ]; then\\n+            echo \\\"📦 Publishing prerelease ${{ matrix.module }} to NPM with tag: ${{ needs.prepare-modular-release.outputs.release_channel }}\\\"\\n+            npm publish --access public --tag ${{ needs.prepare-modular-release.outputs.release_channel }}\\n+          else\\n+            echo \\\"📦 Publishing stable ${{ matrix.module }} to NPM\\\"\\n+            npm publish --access public\\n+          fi\\n+        env:\\n+          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}\\n+\\n+  # ===== PUBLISH TO GITHUB PACKAGES =====\\n+  publish-github:\\n+    runs-on: ubuntu-latest\\n+    needs: [prepare-modular-release, build-modules]\\n+    if: ${{ inputs.target_registry == 'github' || inputs.target_registry == 'both' }}\\n+    \\n+    strategy:\\n+      matrix:\\n+        module: ${{ fromJson(needs.prepare-modular-release.outputs.modules_to_build) }}\\n+    \\n+    steps:\\n+      - name: 📥 Checkout code\\n+        uses: actions/checkout@v4\\n+\\n+      - name: 📦 Setup Node.js for GitHub Packages\\n+        uses: actions/setup-node@v4\\n+        with:\\n+          node-version: ${{ env.NODE_VERSION }}\\n+          cache: 'npm'\\n+          registry-url: 'https://npm.pkg.github.com'\\n+\\n+      - name: 📥 Download module artifacts\\n+        uses: actions/download-artifact@v4\\n+        with:\\n+          name: module-${{ matrix.module }}-${{ needs.prepare-modular-release.outputs.version }}\\n+\\n+      - name: 🔄 Update package version\\n+        run: npm version ${{ needs.prepare-modular-release.outputs.version }} --no-git-tag-version\\n+\\n+      - name: 📦 Publish ${{ matrix.module }} to GitHub Packages\\n+        run: |\\n+          if [ \\\"${{ needs.prepare-modular-release.outputs.is_prerelease }}\\\" == \\\"true\\\" ]; then\\n+            echo \\\"📦 Publishing prerelease ${{ matrix.module }} to GitHub Packages with tag: ${{ needs.prepare-modular-release.outputs.release_channel }}\\\"\\n+            npm publish --access public --tag ${{ needs.prepare-modular-release.outputs.release_channel }}\\n+          else\\n+            echo \\\"📦 Publishing stable ${{ matrix.module }} to GitHub Packages\\\" \\n+            npm publish --access public\\n+          fi\\n+        env:\\n+          NODE_AUTH_TOKEN: ${{ secrets.GITHUB_TOKEN }}\\n+\\n+  # ===== CREATE GITHUB RELEASE =====\\n+  create-github-release:\\n+    runs-on: ubuntu-latest\\n+    needs: [prepare-modular-release, build-modules, publish-npm, publish-github]\\n+    if: always() && needs.prepare-modular-release.result == 'success'\\n+    \\n+    permissions:\\n+      contents: write\\n+      id-token: write\\n+    \\n+    steps:\\n+      - name: 📥 Checkout code  \\n+        uses: actions/checkout@v4\\n+        with:\\n+          fetch-depth: 0\\n+          token: ${{ secrets.GITHUB_TOKEN }}\\n+\\n+      - name: 📥 Download all module artifacts\\n+        uses: actions/download-artifact@v4\\n+        with:\\n+          pattern: module-*-${{ needs.prepare-modular-release.outputs.version }}\\n+          merge-multiple: true\\n+\\n+      - name: 🏷️ Commit and tag\\n+        run: |\\n+          git config user.name \\\"github-actions[bot]\\\"\\n+          git config user.email \\\"github-actions[bot]@users.noreply.github.com\\\"\\n+          git add package.json\\n+          git commit -m \\\"chore: release ${{ needs.prepare-modular-release.outputs.version }} (modular)\\\" || true\\n+          git tag -a \\\"${{ needs.prepare-modular-release.outputs.tag }}\\\" -m \\\"Modular Release ${{ needs.prepare-modular-release.outputs.version }}\\\"\\n+          git push origin main --tags\\n+\\n+      - name: 📝 Prepare release notes\\n+        run: |\\n+          VERSION=${{ needs.prepare-modular-release.outputs.version }}\\n+          MODULE=${{ inputs.module }}\\n+          \\n+          echo \\\"# Better Logger ${VERSION} - Modular Release\\\" > RELEASE_NOTES.md\\n+          echo \\\"\\\" >> RELEASE_NOTES.md\\n+          \\n+          if [ \\\"${{ needs.prepare-modular-release.outputs.is_prerelease }}\\\" == \\\"true\\\" ]; then\\n+            echo \\\"⚠️ **This is a pre-release version** - Not recommended for production use.\\\" >> RELEASE_NOTES.md\\n+            echo \\\"\\\" >> RELEASE_NOTES.md\\n+          fi\\n+          \\n+          echo \\\"## 📦 Modules Released\\\" >> RELEASE_NOTES.md\\n+          echo \\\"**Selected Module(s)**: \\\\`$MODULE\\\\`\\\" >> RELEASE_NOTES.md\\n+          echo \\\"\\\" >> RELEASE_NOTES.md\\n+          \\n+          echo \\\"### Available Module Builds:\\\" >> RELEASE_NOTES.md\\n+          echo \\\"- **Core**: Minimal logger functionality\\\" >> RELEASE_NOTES.md\\n+          echo \\\"- **Styling**: Advanced visual features\\\" >> RELEASE_NOTES.md  \\n+          echo \\\"- **Exports**: Export and remote handlers\\\" >> RELEASE_NOTES.md\\n+          echo \\\"- **Full**: Complete library with all features\\\" >> RELEASE_NOTES.md\\n+          echo \\\"\\\" >> RELEASE_NOTES.md\\n+          \\n+          echo \\\"## 📦 Installation\\\" >> RELEASE_NOTES.md\\n+          if [ \\\"${{ needs.prepare-modular-release.outputs.is_prerelease }}\\\" == \\\"true\\\" ]; then\\n+            echo \\\"\\\\`\\\\`\\\\`bash\\\" >> RELEASE_NOTES.md\\n+            echo \\\"npm install @mks2508/better-logger@${{ needs.prepare-modular-release.outputs.release_channel }}\\\" >> RELEASE_NOTES.md\\n+            echo \\\"\\\\`\\\\`\\\\`\\\" >> RELEASE_NOTES.md\\n+          else\\n+            echo \\\"\\\\`\\\\`\\\\`bash\\\" >> RELEASE_NOTES.md  \\n+            echo \\\"npm install @mks2508/better-logger\\\" >> RELEASE_NOTES.md\\n+            echo \\\"\\\\`\\\\`\\\\`\\\" >> RELEASE_NOTES.md\\n+          fi\\n+\\n+      - name: 🚀 Create GitHub Release\\n+        uses: softprops/action-gh-release@v1\\n+        with:\\n+          tag_name: ${{ needs.prepare-modular-release.outputs.tag }}\\n+          name: Better Logger ${{ needs.prepare-modular-release.outputs.version }} (Modular)\\n+          body_path: RELEASE_NOTES.md\\n+          draft: false\\n+          prerelease: ${{ needs.prepare-modular-release.outputs.is_prerelease == 'true' }}\\n+          files: |\\n+            better-logger-*-${{ needs.prepare-modular-release.outputs.version }}.tar.gz\\n+            better-logger-*-${{ needs.prepare-modular-release.outputs.version }}.zip\\n+        env:\\n+          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\\n+\\n+  # ===== RELEASE SUMMARY =====\\n+  release-summary:\\n+    runs-on: ubuntu-latest\\n+    needs: [prepare-modular-release, build-modules, publish-npm, publish-github, create-github-release]\\n+    if: always() && needs.prepare-modular-release.result == 'success'\\n+    \\n+    steps:\\n+      - name: 📊 Modular Release Summary  \\n+        run: |\\n+          VERSION=\\\"${{ needs.prepare-modular-release.outputs.version }}\\\"\\n+          TAG=\\\"${{ needs.prepare-modular-release.outputs.tag }}\\\"\\n+          CHANNEL=\\\"${{ needs.prepare-modular-release.outputs.release_channel }}\\\"\\n+          IS_PRERELEASE=\\\"${{ needs.prepare-modular-release.outputs.is_prerelease }}\\\"\\n+          MODULE=\\\"${{ inputs.module }}\\\"\\n+          \\n+          echo \\\"## 🎉 Modular Release Complete!\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"- **Version**: $VERSION\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"- **Module(s)**: $MODULE\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"- **Channel**: $CHANNEL\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"- **Prerelease**: $IS_PRERELEASE\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"\\\" >> $GITHUB_STEP_SUMMARY\\n+          \\n+          echo \\\"### 🔗 Links\\\" >> $GITHUB_STEP_SUMMARY\\n+          if [ \\\"${{ inputs.target_registry == 'npm' || inputs.target_registry == 'both' }}\\\" ]; then\\n+            echo \\\"- **NPM**: https://www.npmjs.com/package/@mks2508/better-logger\\\" >> $GITHUB_STEP_SUMMARY\\n+          fi\\n+          if [ \\\"${{ inputs.target_registry == 'github' || inputs.target_registry == 'both' }}\\\" ]; then\\n+            echo \\\"- **GitHub Packages**: https://github.com/MKS2508/advanced-logger/packages/\\\" >> $GITHUB_STEP_SUMMARY  \\n+          fi\\n+          echo \\\"- **GitHub Release**: https://github.com/MKS2508/advanced-logger/releases/tag/$TAG\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"\\\" >> $GITHUB_STEP_SUMMARY\\n+          \\n+          echo \\\"### 📦 Installation\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"\\\\`\\\\`\\\\`bash\\\" >> $GITHUB_STEP_SUMMARY\\n+          if [ \\\"$IS_PRERELEASE\\\" == \\\"true\\\" ]; then\\n+            echo \\\"npm install @mks2508/better-logger@$CHANNEL\\\" >> $GITHUB_STEP_SUMMARY\\n+          else  \\n+            echo \\\"npm install @mks2508/better-logger\\\" >> $GITHUB_STEP_SUMMARY\\n+          fi\\n+          echo \\\"\\\\`\\\\`\\\\`\\\" >> $GITHUB_STEP_SUMMARY\\n\\\\ No newline at end of file\",\n+      \"lines_added\": 378,\n+      \"lines_removed\": 0,\n+      \"is_binary\": false\n+    },\n+    {\n+      \"path\": \".github/workflows/releases-full.yml\",\n+      \"status\": \"added\",\n+      \"diff\": \"diff --git a/.github/workflows/releases-full.yml b/.github/workflows/releases-full.yml\\nnew file mode 100644\\nindex 0000000..44bab03\\n--- /dev/null\\n+++ b/.github/workflows/releases-full.yml\\n@@ -0,0 +1,501 @@\\n+name: Full Release Pipeline with Gemini AI\\n+\\n+on:\\n+  workflow_dispatch:\\n+    inputs:\\n+      use_gemini:\\n+        description: 'Usar Gemini AI para versionado inteligente'\\n+        required: false\\n+        default: true\\n+        type: boolean\\n+      release_type:\\n+        description: 'Tipo de release (solo si no usar Gemini)'\\n+        required: false\\n+        default: 'auto'\\n+        type: choice\\n+        options:\\n+          - auto\\n+          - patch\\n+          - minor\\n+          - major\\n+          - alpha\\n+          - beta\\n+          - stable\\n+      target_registry:\\n+        description: 'Registro objetivo'\\n+        required: false\\n+        default: 'both'\\n+        type: choice\\n+        options:\\n+          - npm\\n+          - github\\n+          - both\\n+      skip_tests:\\n+        description: 'Saltar tests (no recomendado)'\\n+        required: false\\n+        default: false\\n+        type: boolean\\n+      force_release:\\n+        description: 'Forzar release aunque no haya cambios significativos'\\n+        required: false\\n+        default: false\\n+        type: boolean\\n+\\n+env:\\n+  NODE_VERSION: '20'\\n+\\n+jobs:\\n+  # ===== INTELLIGENT VERSIONING WITH GEMINI =====\\n+  gemini-analysis:\\n+    runs-on: ubuntu-latest\\n+    if: ${{ inputs.use_gemini }}\\n+    \\n+    outputs:\\n+      should_release: ${{ steps.analysis.outputs.should_release }}\\n+      version_type: ${{ steps.analysis.outputs.version_type }}\\n+      changelog: ${{ steps.analysis.outputs.changelog }}\\n+      release_notes: ${{ steps.analysis.outputs.release_notes }}\\n+    \\n+    steps:\\n+      - name: 📥 Checkout code\\n+        uses: actions/checkout@v4\\n+        with:\\n+          fetch-depth: 0\\n+          token: ${{ secrets.GITHUB_TOKEN }}\\n+\\n+      - name: 📦 Setup Node.js\\n+        uses: actions/setup-node@v4\\n+        with:\\n+          node-version: ${{ env.NODE_VERSION }}\\n+          cache: 'npm'\\n+\\n+      - name: 🔧 Install dependencies\\n+        run: npm run ci:install\\n+\\n+      - name: 🤖 Run Gemini AI Analysis\\n+        id: analysis\\n+        run: |\\n+          echo \\\"🤖 Ejecutando análisis inteligente con Gemini...\\\"\\n+          \\n+          # Usar project-utils auto-release con Gemini\\n+          npm run release:auto\\n+          \\n+          # Verificar si se debe hacer release\\n+          if [ -f \\\"project-utils/.temp/gemini-response.md\\\" ]; then\\n+            # Extraer información del análisis de Gemini\\n+            SHOULD_RELEASE=$(grep -o \\\"should_release: [a-zA-Z]*\\\" project-utils/.temp/gemini-response.md | cut -d' ' -f2 || echo \\\"true\\\")\\n+            VERSION_TYPE=$(grep -o \\\"version_type: [a-zA-Z]*\\\" project-utils/.temp/gemini-response.md | cut -d' ' -f2 || echo \\\"patch\\\")\\n+            \\n+            echo \\\"should_release=$SHOULD_RELEASE\\\" >> $GITHUB_OUTPUT\\n+            echo \\\"version_type=$VERSION_TYPE\\\" >> $GITHUB_OUTPUT\\n+            \\n+            # Extraer changelog y release notes si existen\\n+            if [ -f \\\"project-utils/.temp/commit-proposal\\\"*\\\".md\\\" ]; then\\n+              CHANGELOG=$(head -n 10 project-utils/.temp/commit-proposal*.md | base64 -w 0)\\n+              echo \\\"changelog=$CHANGELOG\\\" >> $GITHUB_OUTPUT\\n+            fi\\n+            \\n+            echo \\\"🤖 Análisis completado: should_release=$SHOULD_RELEASE, version_type=$VERSION_TYPE\\\"\\n+          else\\n+            # Fallback si no hay respuesta de Gemini\\n+            echo \\\"should_release=true\\\" >> $GITHUB_OUTPUT\\n+            echo \\\"version_type=patch\\\" >> $GITHUB_OUTPUT\\n+            echo \\\"⚠️ No se encontró respuesta de Gemini, usando valores por defecto\\\"\\n+          fi\\n+\\n+      - name: 📤 Upload Gemini artifacts\\n+        uses: actions/upload-artifact@v4\\n+        if: always()\\n+        with:\\n+          name: gemini-analysis\\n+          path: project-utils/.temp/\\n+          retention-days: 7\\n+\\n+  # ===== PREPARE RELEASE =====\\n+  prepare-full-release:\\n+    runs-on: ubuntu-latest\\n+    needs: gemini-analysis\\n+    if: always() && (needs.gemini-analysis.outputs.should_release == 'true' || inputs.force_release || !inputs.use_gemini)\\n+    \\n+    outputs:\\n+      version: ${{ steps.version.outputs.version }}\\n+      tag: ${{ steps.version.outputs.tag }}\\n+      is_prerelease: ${{ steps.version.outputs.is_prerelease }}\\n+      release_channel: ${{ steps.version.outputs.release_channel }}\\n+      changelog: ${{ steps.version.outputs.changelog }}\\n+    \\n+    steps:\\n+      - name: 📥 Checkout code\\n+        uses: actions/checkout@v4\\n+        with:\\n+          fetch-depth: 0\\n+          token: ${{ secrets.GITHUB_TOKEN }}\\n+\\n+      - name: 📦 Setup Node.js\\n+        uses: actions/setup-node@v4\\n+        with:\\n+          node-version: ${{ env.NODE_VERSION }}\\n+          cache: 'npm'\\n+\\n+      - name: 🔧 Install dependencies\\n+        run: npm run ci:install\\n+\\n+      - name: 🧪 Run tests (unless skipped)\\n+        if: ${{ !inputs.skip_tests }}\\n+        run: |\\n+          npm run type-check\\n+          npm run ci:test\\n+\\n+      - name: 🏷️ Generate version with AI or manual\\n+        id: version\\n+        run: |\\n+          if [ \\\"${{ inputs.use_gemini }}\\\" == \\\"true\\\" ]; then\\n+            # Usar resultado de Gemini\\n+            VERSION_TYPE=\\\"${{ needs.gemini-analysis.outputs.version_type }}\\\"\\n+            echo \\\"🤖 Usando tipo de versión de Gemini: $VERSION_TYPE\\\"\\n+          else\\n+            # Usar input manual\\n+            VERSION_TYPE=\\\"${{ inputs.release_type }}\\\"\\n+            echo \\\"👤 Usando tipo de versión manual: $VERSION_TYPE\\\"\\n+          fi\\n+          \\n+          # Aplicar versionado según el tipo determinado\\n+          case \\\"$VERSION_TYPE\\\" in\\n+            \\\"auto\\\")\\n+              npm run version:auto\\n+              ;;\\n+            \\\"patch\\\")\\n+              npm run version:patch\\n+              ;;\\n+            \\\"minor\\\")\\n+              npm run version:minor\\n+              ;;\\n+            \\\"major\\\")\\n+              npm run version:major\\n+              ;;\\n+            \\\"alpha\\\")\\n+              npm run version:alpha\\n+              ;;\\n+            \\\"beta\\\")\\n+              npm run version:beta\\n+              ;;\\n+            \\\"stable\\\")\\n+              npm run version:stable\\n+              ;;\\n+          esac\\n+          \\n+          # Obtener nueva versión del package.json\\n+          NEW_VERSION=$(node -p \\\"require('./package.json').version\\\")\\n+          echo \\\"version=$NEW_VERSION\\\" >> $GITHUB_OUTPUT\\n+          echo \\\"tag=v$NEW_VERSION\\\" >> $GITHUB_OUTPUT\\n+          \\n+          # Determinar si es prerelease y canal\\n+          if [[ \\\"$NEW_VERSION\\\" == *\\\"alpha\\\"* ]]; then\\n+            echo \\\"is_prerelease=true\\\" >> $GITHUB_OUTPUT\\n+            echo \\\"release_channel=alpha\\\" >> $GITHUB_OUTPUT\\n+          elif [[ \\\"$NEW_VERSION\\\" == *\\\"beta\\\"* ]]; then\\n+            echo \\\"is_prerelease=true\\\" >> $GITHUB_OUTPUT  \\n+            echo \\\"release_channel=beta\\\" >> $GITHUB_OUTPUT\\n+          else\\n+            echo \\\"is_prerelease=false\\\" >> $GITHUB_OUTPUT\\n+            echo \\\"release_channel=latest\\\" >> $GITHUB_OUTPUT\\n+          fi\\n+          \\n+          echo \\\"📦 Nueva versión: $NEW_VERSION\\\"\\n+\\n+      - name: 📝 Generate enhanced changelog\\n+        id: changelog\\n+        run: |\\n+          if [ \\\"${{ inputs.use_gemini }}\\\" == \\\"true\\\" ] && [ \\\"${{ needs.gemini-analysis.outputs.changelog }}\\\" != \\\"\\\" ]; then\\n+            # Usar changelog de Gemini si existe\\n+            echo \\\"📋 Usando changelog generado por Gemini AI...\\\"\\n+            CHANGELOG=$(echo \\\"${{ needs.gemini-analysis.outputs.changelog }}\\\" | base64 -d)\\n+          else\\n+            # Generar changelog tradicional\\n+            echo \\\"📋 Generando changelog tradicional...\\\"\\n+            LAST_TAG=$(git describe --tags --abbrev=0 HEAD~1 2>/dev/null || echo \\\"\\\")\\n+            if [ -n \\\"$LAST_TAG\\\" ]; then\\n+              CHANGELOG=$(git log $LAST_TAG..HEAD --pretty=format:\\\"- %s (%h)\\\" --no-merges)\\n+            else\\n+              CHANGELOG=\\\"- Initial release with complete Better Logger functionality\\\"\\n+            fi\\n+          fi\\n+          \\n+          # Guardar changelog en archivo\\n+          echo \\\"$CHANGELOG\\\" > RELEASE_CHANGELOG.md\\n+          echo \\\"changelog=$(echo \\\"$CHANGELOG\\\" | base64 -w 0)\\\" >> $GITHUB_OUTPUT\\n+          echo \\\"📋 Changelog generado exitosamente\\\"\\n+\\n+      - name: 🏗️ Build all modules\\n+        run: npm run build:all\\n+\\n+      - name: 📊 Generate bundle analysis\\n+        run: |\\n+          echo \\\"## 📦 Bundle Analysis\\\" > BUNDLE_ANALYSIS.md\\n+          echo \\\"### Full Build\\\" >> BUNDLE_ANALYSIS.md\\n+          echo \\\"\\\\`\\\\`\\\\`\\\" >> BUNDLE_ANALYSIS.md\\n+          ls -lh dist/*.js dist/*.cjs | grep -E '\\\\.(js|cjs)$' >> BUNDLE_ANALYSIS.md\\n+          echo \\\"\\\\`\\\\`\\\\`\\\" >> BUNDLE_ANALYSIS.md\\n+          echo \\\"\\\" >> BUNDLE_ANALYSIS.md\\n+          \\n+          echo \\\"### Modular Builds\\\" >> BUNDLE_ANALYSIS.md\\n+          for module in core styling exports; do\\n+            if [ -d \\\"dist/modular/$module\\\" ]; then\\n+              echo \\\"#### $module Module\\\" >> BUNDLE_ANALYSIS.md\\n+              echo \\\"\\\\`\\\\`\\\\`\\\" >> BUNDLE_ANALYSIS.md\\n+              ls -lh dist/modular/$module/*.js dist/modular/$module/*.cjs 2>/dev/null | grep -E '\\\\.(js|cjs)$' >> BUNDLE_ANALYSIS.md\\n+              echo \\\"\\\\`\\\\`\\\\`\\\" >> BUNDLE_ANALYSIS.md\\n+            fi\\n+          done\\n+\\n+      - name: 📤 Upload release artifacts\\n+        uses: actions/upload-artifact@v4\\n+        with:\\n+          name: full-release-${{ steps.version.outputs.version }}\\n+          path: |\\n+            dist/\\n+            RELEASE_CHANGELOG.md\\n+            BUNDLE_ANALYSIS.md\\n+          retention-days: 30\\n+\\n+  # ===== PUBLISH TO NPM =====\\n+  publish-npm-full:\\n+    runs-on: ubuntu-latest\\n+    needs: prepare-full-release\\n+    if: ${{ inputs.target_registry == 'npm' || inputs.target_registry == 'both' }}\\n+    \\n+    steps:\\n+      - name: 📥 Checkout code\\n+        uses: actions/checkout@v4\\n+\\n+      - name: 📦 Setup Node.js for NPM\\n+        uses: actions/setup-node@v4\\n+        with:\\n+          node-version: ${{ env.NODE_VERSION }}\\n+          cache: 'npm'\\n+          registry-url: 'https://registry.npmjs.org'\\n+\\n+      - name: 📥 Download release artifacts\\n+        uses: actions/download-artifact@v4\\n+        with:\\n+          name: full-release-${{ needs.prepare-full-release.outputs.version }}\\n+\\n+      - name: 🔄 Update package version\\n+        run: npm version ${{ needs.prepare-full-release.outputs.version }} --no-git-tag-version\\n+\\n+      - name: 🚀 Publish to NPM\\n+        run: |\\n+          if [ \\\"${{ needs.prepare-full-release.outputs.is_prerelease }}\\\" == \\\"true\\\" ]; then\\n+            echo \\\"📦 Publishing prerelease to NPM with tag: ${{ needs.prepare-full-release.outputs.release_channel }}\\\"\\n+            npm publish --access public --tag ${{ needs.prepare-full-release.outputs.release_channel }}\\n+          else\\n+            echo \\\"📦 Publishing stable release to NPM\\\"\\n+            npm publish --access public\\n+          fi\\n+        env:\\n+          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}\\n+\\n+  # ===== PUBLISH TO GITHUB PACKAGES =====\\n+  publish-github-full:\\n+    runs-on: ubuntu-latest\\n+    needs: prepare-full-release\\n+    if: ${{ inputs.target_registry == 'github' || inputs.target_registry == 'both' }}\\n+    \\n+    steps:\\n+      - name: 📥 Checkout code\\n+        uses: actions/checkout@v4\\n+\\n+      - name: 📦 Setup Node.js for GitHub Packages\\n+        uses: actions/setup-node@v4\\n+        with:\\n+          node-version: ${{ env.NODE_VERSION }}\\n+          cache: 'npm'\\n+          registry-url: 'https://npm.pkg.github.com'\\n+\\n+      - name: 📥 Download release artifacts\\n+        uses: actions/download-artifact@v4\\n+        with:\\n+          name: full-release-${{ needs.prepare-full-release.outputs.version }}\\n+\\n+      - name: 🔄 Update package version\\n+        run: npm version ${{ needs.prepare-full-release.outputs.version }} --no-git-tag-version\\n+\\n+      - name: 📦 Publish to GitHub Packages\\n+        run: |\\n+          if [ \\\"${{ needs.prepare-full-release.outputs.is_prerelease }}\\\" == \\\"true\\\" ]; then\\n+            echo \\\"📦 Publishing prerelease to GitHub Packages with tag: ${{ needs.prepare-full-release.outputs.release_channel }}\\\"\\n+            npm publish --access public --tag ${{ needs.prepare-full-release.outputs.release_channel }}\\n+          else\\n+            echo \\\"📦 Publishing stable release to GitHub Packages\\\" \\n+            npm publish --access public\\n+          fi\\n+        env:\\n+          NODE_AUTH_TOKEN: ${{ secrets.GITHUB_TOKEN }}\\n+\\n+  # ===== CREATE COMPREHENSIVE GITHUB RELEASE =====\\n+  create-comprehensive-release:\\n+    runs-on: ubuntu-latest\\n+    needs: [gemini-analysis, prepare-full-release, publish-npm-full, publish-github-full]\\n+    if: always() && needs.prepare-full-release.result == 'success'\\n+    \\n+    permissions:\\n+      contents: write\\n+      id-token: write\\n+    \\n+    steps:\\n+      - name: 📥 Checkout code  \\n+        uses: actions/checkout@v4\\n+        with:\\n+          fetch-depth: 0\\n+          token: ${{ secrets.GITHUB_TOKEN }}\\n+\\n+      - name: 📥 Download release artifacts\\n+        uses: actions/download-artifact@v4\\n+        with:\\n+          name: full-release-${{ needs.prepare-full-release.outputs.version }}\\n+\\n+      - name: 📥 Download Gemini artifacts (if available)\\n+        uses: actions/download-artifact@v4\\n+        if: needs.gemini-analysis.result == 'success'\\n+        with:\\n+          name: gemini-analysis\\n+          path: gemini-temp/\\n+\\n+      - name: 📦 Create comprehensive release archives\\n+        run: |\\n+          VERSION=${{ needs.prepare-full-release.outputs.version }}\\n+          \\n+          # Crear archivos de distribución completa\\n+          tar -czf better-logger-complete-${VERSION}.tar.gz dist/ docs/ README.md package.json\\n+          zip -r better-logger-complete-${VERSION}.zip dist/ docs/ README.md package.json\\n+          \\n+          # Crear paquetes modulares individuales\\n+          for module in core styling exports; do\\n+            if [ -d \\\"dist/modular/$module\\\" ]; then\\n+              tar -czf better-logger-${module}-${VERSION}.tar.gz dist/modular/${module}/ README.md package.json\\n+              zip -r better-logger-${module}-${VERSION}.zip dist/modular/${module}/ README.md package.json\\n+            fi\\n+          done\\n+\\n+      - name: 🏷️ Commit and tag with enhanced info\\n+        run: |\\n+          git config user.name \\\"github-actions[bot]\\\"\\n+          git config user.email \\\"github-actions[bot]@users.noreply.github.com\\\"\\n+          git add package.json\\n+          \\n+          # Crear commit message mejorado\\n+          COMMIT_MSG=\\\"chore: release ${{ needs.prepare-full-release.outputs.version }}\\\"\\n+          if [ \\\"${{ inputs.use_gemini }}\\\" == \\\"true\\\" ]; then\\n+            COMMIT_MSG=\\\"$COMMIT_MSG (AI-generated)\\\"\\n+          fi\\n+          \\n+          git commit -m \\\"$COMMIT_MSG\\\" || true\\n+          git tag -a \\\"${{ needs.prepare-full-release.outputs.tag }}\\\" -m \\\"Release ${{ needs.prepare-full-release.outputs.version }}\\\"\\n+          git push origin main --tags\\n+\\n+      - name: 📝 Prepare comprehensive release notes\\n+        run: |\\n+          VERSION=${{ needs.prepare-full-release.outputs.version }}\\n+          CHANGELOG=$(echo \\\"${{ needs.prepare-full-release.outputs.changelog }}\\\" | base64 -d)\\n+          \\n+          echo \\\"# Better Logger ${VERSION}\\\" > FINAL_RELEASE_NOTES.md\\n+          echo \\\"\\\" >> FINAL_RELEASE_NOTES.md\\n+          \\n+          if [ \\\"${{ inputs.use_gemini }}\\\" == \\\"true\\\" ]; then\\n+            echo \\\"🤖 **AI-Generated Release** - This release was analyzed and versioned using Gemini AI\\\" >> FINAL_RELEASE_NOTES.md\\n+            echo \\\"\\\" >> FINAL_RELEASE_NOTES.md\\n+          fi\\n+          \\n+          if [ \\\"${{ needs.prepare-full-release.outputs.is_prerelease }}\\\" == \\\"true\\\" ]; then\\n+            echo \\\"⚠️ **This is a pre-release version** - Not recommended for production use.\\\" >> FINAL_RELEASE_NOTES.md\\n+            echo \\\"\\\" >> FINAL_RELEASE_NOTES.md\\n+          fi\\n+          \\n+          echo \\\"## 🔄 Changes\\\" >> FINAL_RELEASE_NOTES.md\\n+          echo \\\"$CHANGELOG\\\" >> FINAL_RELEASE_NOTES.md\\n+          echo \\\"\\\" >> FINAL_RELEASE_NOTES.md\\n+          \\n+          # Incluir análisis de bundle\\n+          cat BUNDLE_ANALYSIS.md >> FINAL_RELEASE_NOTES.md\\n+          echo \\\"\\\" >> FINAL_RELEASE_NOTES.md\\n+          \\n+          echo \\\"## 📦 Available Packages\\\" >> FINAL_RELEASE_NOTES.md\\n+          echo \\\"### Complete Library\\\" >> FINAL_RELEASE_NOTES.md\\n+          echo \\\"\\\\`\\\\`\\\\`bash\\\" >> FINAL_RELEASE_NOTES.md\\n+          if [ \\\"${{ needs.prepare-full-release.outputs.is_prerelease }}\\\" == \\\"true\\\" ]; then\\n+            echo \\\"npm install @mks2508/better-logger@${{ needs.prepare-full-release.outputs.release_channel }}\\\" >> FINAL_RELEASE_NOTES.md\\n+          else\\n+            echo \\\"npm install @mks2508/better-logger\\\" >> FINAL_RELEASE_NOTES.md\\n+          fi\\n+          echo \\\"\\\\`\\\\`\\\\`\\\" >> FINAL_RELEASE_NOTES.md\\n+          echo \\\"\\\" >> FINAL_RELEASE_NOTES.md\\n+          \\n+          echo \\\"### Modular Packages\\\" >> FINAL_RELEASE_NOTES.md\\n+          echo \\\"Download individual modules from the release assets below for selective usage.\\\" >> FINAL_RELEASE_NOTES.md\\n+\\n+      - name: 🚀 Create Comprehensive GitHub Release\\n+        uses: softprops/action-gh-release@v1\\n+        with:\\n+          tag_name: ${{ needs.prepare-full-release.outputs.tag }}\\n+          name: Better Logger ${{ needs.prepare-full-release.outputs.version }}${{ inputs.use_gemini && ' (AI)' || '' }}\\n+          body_path: FINAL_RELEASE_NOTES.md\\n+          draft: false\\n+          prerelease: ${{ needs.prepare-full-release.outputs.is_prerelease == 'true' }}\\n+          files: |\\n+            better-logger-complete-${{ needs.prepare-full-release.outputs.version }}.tar.gz\\n+            better-logger-complete-${{ needs.prepare-full-release.outputs.version }}.zip\\n+            better-logger-core-${{ needs.prepare-full-release.outputs.version }}.tar.gz\\n+            better-logger-core-${{ needs.prepare-full-release.outputs.version }}.zip\\n+            better-logger-styling-${{ needs.prepare-full-release.outputs.version }}.tar.gz\\n+            better-logger-styling-${{ needs.prepare-full-release.outputs.version }}.zip\\n+            better-logger-exports-${{ needs.prepare-full-release.outputs.version }}.tar.gz\\n+            better-logger-exports-${{ needs.prepare-full-release.outputs.version }}.zip\\n+        env:\\n+          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\\n+\\n+  # ===== COMPREHENSIVE RELEASE SUMMARY =====\\n+  comprehensive-summary:\\n+    runs-on: ubuntu-latest\\n+    needs: [gemini-analysis, prepare-full-release, publish-npm-full, publish-github-full, create-comprehensive-release]\\n+    if: always() && needs.prepare-full-release.result == 'success'\\n+    \\n+    steps:\\n+      - name: 📊 Comprehensive Release Summary  \\n+        run: |\\n+          VERSION=\\\"${{ needs.prepare-full-release.outputs.version }}\\\"\\n+          TAG=\\\"${{ needs.prepare-full-release.outputs.tag }}\\\"\\n+          CHANNEL=\\\"${{ needs.prepare-full-release.outputs.release_channel }}\\\"\\n+          IS_PRERELEASE=\\\"${{ needs.prepare-full-release.outputs.is_prerelease }}\\\"\\n+          USED_AI=\\\"${{ inputs.use_gemini }}\\\"\\n+          \\n+          echo \\\"## 🎉 Comprehensive Release Complete!\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"- **Version**: $VERSION\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"- **Channel**: $CHANNEL\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"- **Prerelease**: $IS_PRERELEASE\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"- **AI-Generated**: $USED_AI\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"\\\" >> $GITHUB_STEP_SUMMARY\\n+          \\n+          echo \\\"### 📦 Published Packages\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"- **Complete Library**: Full Better Logger with all features\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"- **Modular Builds**: Core, Styling, and Exports available separately\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"\\\" >> $GITHUB_STEP_SUMMARY\\n+          \\n+          echo \\\"### 🔗 Links\\\" >> $GITHUB_STEP_SUMMARY\\n+          if [ \\\"${{ inputs.target_registry == 'npm' || inputs.target_registry == 'both' }}\\\" ]; then\\n+            echo \\\"- **NPM**: https://www.npmjs.com/package/@mks2508/better-logger\\\" >> $GITHUB_STEP_SUMMARY\\n+          fi\\n+          if [ \\\"${{ inputs.target_registry == 'github' || inputs.target_registry == 'both' }}\\\" ]; then\\n+            echo \\\"- **GitHub Packages**: https://github.com/MKS2508/advanced-logger/packages/\\\" >> $GITHUB_STEP_SUMMARY  \\n+          fi\\n+          echo \\\"- **GitHub Release**: https://github.com/MKS2508/advanced-logger/releases/tag/$TAG\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"- **Documentation**: https://mks2508.github.io/advanced-logger/\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"\\\" >> $GITHUB_STEP_SUMMARY\\n+          \\n+          echo \\\"### 📦 Installation\\\" >> $GITHUB_STEP_SUMMARY\\n+          echo \\\"\\\\`\\\\`\\\\`bash\\\" >> $GITHUB_STEP_SUMMARY\\n+          if [ \\\"$IS_PRERELEASE\\\" == \\\"true\\\" ]; then\\n+            echo \\\"npm install @mks2508/better-logger@$CHANNEL\\\" >> $GITHUB_STEP_SUMMARY\\n+          else  \\n+            echo \\\"npm install @mks2508/better-logger\\\" >> $GITHUB_STEP_SUMMARY\\n+          fi\\n+          echo \\\"\\\\`\\\\`\\\\`\\\" >> $GITHUB_STEP_SUMMARY\\n\\\\ No newline at end of file\",\n+      \"lines_added\": 501,\n+      \"lines_removed\": 0,\n+      \"is_binary\": false\n+    },\n+    {\n+      \"path\": \"package.json\",\n+      \"status\": \"modified\",\n+      \"diff\": \"diff --git a/package.json b/package.json\\nindex 49619ea..bcde04c 100644\\n--- a/package.json\\n+++ b/package.json\\n@@ -29,32 +29,38 @@\\n   \\\"homepage\\\": \\\"https://mks2508.github.io/advanced-logger/\\\",\\n   \\\"scripts\\\": {\\n     \\\"dev\\\": \\\"vite\\\",\\n-    \\\"build\\\": \\\"tsc && vite build\\\",\\n-    \\\"build:watch\\\": \\\"vite build --watch\\\",\\n-    \\\"build:analyze\\\": \\\"vite build --mode analyze\\\",\\n-    \\\"preview\\\": \\\"vite preview\\\",\\n+    \\\"build\\\": \\\"tsc && BUILD_MODE=full vite build\\\",\\n+    \\\"build:full\\\": \\\"tsc && BUILD_MODE=full vite build\\\", \\n+    \\\"build:core\\\": \\\"tsc && BUILD_MODE=core vite build\\\",\\n+    \\\"build:styling\\\": \\\"tsc && BUILD_MODE=styling vite build\\\",\\n+    \\\"build:exports\\\": \\\"tsc && BUILD_MODE=exports vite build\\\",\\n+    \\\"build:all\\\": \\\"npm run build:full && npm run build:core && npm run build:styling && npm run build:exports\\\",\\n     \\\"clean\\\": \\\"rm -rf dist node_modules/.vite\\\",\\n     \\\"type-check\\\": \\\"tsc --noEmit\\\",\\n-    \\\"lint\\\": \\\"echo 'Linting with ESLint...' && exit 0\\\",\\n-    \\\"lint:fix\\\": \\\"echo 'Fixing with ESLint...' && exit 0\\\",\\n     \\\"test\\\": \\\"echo 'Running tests...' && exit 0\\\",\\n-    \\\"test:watch\\\": \\\"echo 'Running tests in watch mode...' && exit 0\\\",\\n-    \\\"test:coverage\\\": \\\"echo 'Running tests with coverage...' && exit 0\\\",\\n     \\\"test:performance\\\": \\\"echo 'Running performance benchmarks...' && exit 0\\\",\\n     \\\"test:visual\\\": \\\"echo 'Running visual tests...' && exit 0\\\",\\n-    \\\"prepublishOnly\\\": \\\"npm run clean && npm run type-check && npm run build\\\",\\n-    \\\"release\\\": \\\"npm version patch && npm publish --access public\\\",\\n-    \\\"release:minor\\\": \\\"npm version minor && npm publish --access public\\\",\\n-    \\\"release:major\\\": \\\"npm version major && npm publish --access public\\\",\\n-    \\\"release:alpha\\\": \\\"npm version prerelease --preid=alpha && npm publish --access public --tag alpha\\\",\\n-    \\\"release:beta\\\": \\\"npm version prerelease --preid=beta && npm publish --access public --tag beta\\\",\\n-    \\\"demo:serve\\\": \\\"python3 -m http.server 8080\\\",\\n     \\\"size-limit\\\": \\\"echo 'Checking bundle sizes...' && ls -la dist/\\\",\\n     \\\"ci:install\\\": \\\"npm ci\\\",\\n-    \\\"ci:build\\\": \\\"npm run build\\\",\\n+    \\\"ci:build\\\": \\\"npm run build:all\\\",\\n     \\\"ci:test\\\": \\\"npm run test\\\",\\n     \\\"ci:publish\\\": \\\"npm publish --access public --ignore-scripts\\\",\\n-    \\\"ci:publish:github\\\": \\\"npm publish --registry=https://npm.pkg.github.com --access public --ignore-scripts\\\"\\n+    \\\"ci:publish:github\\\": \\\"npm publish --registry=https://npm.pkg.github.com --access public --ignore-scripts\\\",\\n+    \\\"commit:auto\\\": \\\"bun project-utils/commit-generator.ts --auto-approve --quiet\\\",\\n+    \\\"commit:ui\\\": \\\"bun project-utils/commit-ui.ts\\\",\\n+    \\\"version:auto\\\": \\\"bun project-utils/version-manager.ts --auto-approve\\\",\\n+    \\\"version:patch\\\": \\\"bun project-utils/version-manager.ts --type patch --auto-approve\\\",\\n+    \\\"version:minor\\\": \\\"bun project-utils/version-manager.ts --type minor --auto-approve\\\", \\n+    \\\"version:major\\\": \\\"bun project-utils/version-manager.ts --type major --auto-approve\\\",\\n+    \\\"version:alpha\\\": \\\"bun project-utils/version-manager.ts --prefix alpha --auto-approve\\\",\\n+    \\\"version:beta\\\": \\\"bun project-utils/version-manager.ts --prefix beta --auto-approve\\\",\\n+    \\\"version:stable\\\": \\\"bun project-utils/version-manager.ts --prefix '' --auto-approve\\\",\\n+    \\\"release:github\\\": \\\"bun project-utils/github-release-manager.ts --auto-approve\\\",\\n+    \\\"release:full\\\": \\\"npm run version:auto && npm run build:all && npm run release:github && npm run ci:publish\\\",\\n+    \\\"release:auto\\\": \\\"bun project-utils/auto-release-gemini.ts --ai --auto-approve\\\",\\n+    \\\"workflow:full\\\": \\\"npm run commit:auto && npm run release:full\\\",\\n+    \\\"workflow:commit\\\": \\\"npm run commit:auto\\\",\\n+    \\\"workflow:release\\\": \\\"npm run version:auto && npm run build:all && npm run release:github\\\"\\n   },\\n   \\\"devDependencies\\\": {\\n     \\\"terser\\\": \\\"^5.43.1\\\",\",\n+      \"lines_added\": 23,\n+      \"lines_removed\": 17,\n+      \"is_binary\": false\n+    },\n+    {\n+      \"path\": \"project-utils/README.md\",\n+      \"status\": \"added\",\n+      \"diff\": \"diff --git a/project-utils/README.md b/project-utils/README.md\\nnew file mode 100644\\nindex 0000000..e19f929\\n--- /dev/null\\n+++ b/project-utils/README.md\\n@@ -0,0 +1,118 @@\\n+# Project Utils - Sistema de Automatización Completa\\n+\\n+## 🚀 Comandos de Workflow Automatizado\\n+\\n+### Comandos Individuales\\n+```bash\\n+# Commits automatizados\\n+npm run commit:auto           # Commit automático silencioso\\n+npm run commit:ui            # UI interactiva para commits  \\n+npm run commit:generate      # Solo generar propuesta\\n+\\n+# Versionado automatizado\\n+npm run version:auto         # Auto-detectar tipo de versión\\n+npm run version:patch        # Forzar versión patch\\n+npm run version:minor        # Forzar versión minor  \\n+npm run version:major        # Forzar versión major\\n+npm run version:alpha        # Versión alpha\\n+npm run version:beta         # Versión beta\\n+npm run version:stable       # Versión estable\\n+\\n+# GitHub Releases\\n+npm run release:github       # Crear release en GitHub\\n+npm run release:full         # Versión + Build + GitHub + Publish NPM\\n+npm run release:auto         # Release completa con AI\\n+```\\n+\\n+### Workflows Completos\\n+```bash\\n+npm run workflow:full        # Commit + Versión + Build + Release + Publish\\n+npm run workflow:commit      # Solo commit automático\\n+npm run workflow:version     # Versión + Build\\n+npm run workflow:release     # Versión + Build + GitHub Release\\n+```\\n+\\n+## 🔧 Parámetros de Automatización\\n+\\n+### commit-generator.ts\\n+```bash\\n+# Usar propuesta existente\\n+node project-utils/commit-generator.ts --proposal-file project-utils/.temp/commit-proposal-*.md --auto-approve\\n+\\n+# Configuración personalizada\\n+node project-utils/commit-generator.ts \\\\\\n+  --auto-approve \\\\\\n+  --quiet \\\\\\n+  --work-type feature \\\\\\n+  --affected-components \\\"core,styling\\\" \\\\\\n+  --output-dir custom/path\\n+```\\n+\\n+### version-manager.ts\\n+```bash\\n+# Versionado automático completo\\n+node project-utils/version-manager.ts --auto-approve --quiet --type minor\\n+```\\n+\\n+### github-release-manager.ts\\n+```bash\\n+# Release automática\\n+node project-utils/github-release-manager.ts --auto-approve --quiet\\n+```\\n+\\n+## 📁 Archivos Temporales\\n+\\n+Ubicación: `project-utils/.temp/`\\n+- `commit-proposal-YYYYMMDD-HHMMSS.md` - Propuestas de commit\\n+- `gemini-prompt.txt` - Prompts enviados a Gemini\\n+- `gemini-response.md` - Respuestas de Gemini\\n+- `analysis-context.json` - Contexto de análisis\\n+\\n+## 🔄 Reutilización de Propuestas\\n+\\n+1. Generar propuesta: `npm run commit:generate`\\n+2. Revisar en `project-utils/.temp/commit-proposal-*.md`\\n+3. Ejecutar: `node project-utils/commit-generator.ts --proposal-file <ruta> --auto-approve`\\n+\\n+## 🎯 Casos de Uso\\n+\\n+### Desarrollo Normal\\n+```bash\\n+# 1. Hacer cambios en código\\n+# 2. Commit automático\\n+npm run commit:auto\\n+\\n+# 3. Cuando esté listo para release\\n+npm run workflow:release\\n+```\\n+\\n+### CI/CD Pipeline\\n+```bash\\n+# Workflow completo automático\\n+npm run workflow:full\\n+```\\n+\\n+### Releases Manuales con Control\\n+```bash\\n+npm run commit:generate     # Revisar propuesta\\n+# Editar si necesario\\n+npm run commit:auto         # Ejecutar commits\\n+npm run version:minor       # Versión específica\\n+npm run release:github      # Solo GitHub release\\n+```\\n+\\n+## ⚙️ Configuración\\n+\\n+Todos los scripts respetan los parámetros:\\n+- `--auto-approve`: Ejecución automática sin confirmaciones\\n+- `--quiet`: Solo errores y resultados finales\\n+- `--no-push`: No hacer push (solo commits locales)\\n+- `--force`: Forzar operaciones (recrear releases, etc.)\\n+\\n+## 🔒 Validaciones de Seguridad\\n+\\n+- Solo funciona en rama `master`\\n+- Validación de conflictos antes de ejecutar  \\n+- Commits atómicos con rollback en caso de error\\n+- Logs completos de todas las operaciones\\n+- Validación de estado del repositorio antes de auto-approve\\n\\\\ No newline at end of file\",\n+      \"lines_added\": 118,\n+      \"lines_removed\": 0,\n+      \"is_binary\": false\n+    },\n+    {\n+      \"path\": \"project-utils/auto-release-gemini.ts\",\n+      \"status\": \"added\",\n+      \"diff\": \"diff --git a/project-utils/auto-release-gemini.ts b/project-utils/auto-release-gemini.ts\\nnew file mode 100755\\nindex 0000000..72a63ba\\n--- /dev/null\\n+++ b/project-utils/auto-release-gemini.ts\\n@@ -0,0 +1,743 @@\\n+#!/usr/bin/env node\\n+\\n+/**\\n+ * Auto-Release Manager con Integración Gemini para Better Logger\\n+ * Sistema avanzado que usa AI para generar documentación y commits inteligentes\\n+ */\\n+\\n+import { spawn } from 'child_process';\\n+import { readFileSync, writeFileSync, existsSync, mkdirSync, readdirSync, statSync } from 'fs';\\n+import { join, dirname } from 'path';\\n+import { createReleasePrompt, BETTER_LOGGER_PROJECT_CONFIG, type GeminiPromptConfig } from './prompt-templates';\\n+\\n+interface ChangelogData {\\n+  current_version: string;\\n+  versions: Array<{\\n+    version: string;\\n+    date: string;\\n+    type: string;\\n+    title: string;\\n+    changes: Array<{\\n+      type: string;\\n+      title: string;\\n+      description: string;\\n+    }>;\\n+    technical_notes: string;\\n+    breaking_changes: string[];\\n+    commit_hash: string;\\n+    prefix?: string;\\n+  }>;\\n+}\\n+\\n+interface ReleaseInfo {\\n+  version: string;\\n+  prefix: string;\\n+  major: number;\\n+  minor: number;\\n+  patch: number;\\n+}\\n+\\n+class AutoReleaseManagerAI {\\n+  private projectRoot: string;\\n+  private releaseDir: string;\\n+  private changelogPath: string;\\n+  private tempDir: string;\\n+  private forceMode: boolean;\\n+  private useAI: boolean;\\n+  private noGitHub: boolean;\\n+  \\n+  // Parámetros de contexto mejorados\\n+  private focusArea: string;\\n+  private targetPlatform: string;\\n+  private urgency: string;\\n+  private targetAudience: string;\\n+  private dependencies: string;\\n+\\n+  constructor() {\\n+    this.projectRoot = process.cwd();\\n+    this.releaseDir = join(this.projectRoot, 'dist');\\n+    this.changelogPath = join(this.projectRoot, 'CHANGELOG.json');\\n+    this.tempDir = join(this.projectRoot, 'project-utils/.temp');\\n+    this.forceMode = process.argv.includes('--force');\\n+    this.useAI = process.argv.includes('--ai') || !process.argv.includes('--no-ai');\\n+    this.noGitHub = process.argv.includes('--no-github');\\n+    \\n+    // Parsear parámetros de contexto mejorados\\n+    this.focusArea = this.getArgValue('--focus') || '';\\n+    this.targetPlatform = this.getArgValue('--target-platform') || 'universal';\\n+    this.urgency = this.getArgValue('--urgency') || 'normal';\\n+    this.targetAudience = this.getArgValue('--audience') || 'public';\\n+    this.dependencies = this.getArgValue('--dependencies') || 'both';\\n+    \\n+    // Crear directorio temporal si no existe\\n+    if (!existsSync(this.tempDir)) {\\n+      mkdirSync(this.tempDir, { recursive: true });\\n+    }\\n+  }\\n+\\n+  /**\\n+   * Obtiene valor de un argumento específico\\n+   */\\n+  private getArgValue(argName: string): string | undefined {\\n+    const args = process.argv;\\n+    const argIndex = args.indexOf(argName);\\n+    if (argIndex > -1 && args[argIndex + 1] && !args[argIndex + 1].startsWith('--')) {\\n+      return args[argIndex + 1];\\n+    }\\n+    return undefined;\\n+  }\\n+\\n+  async run(): Promise<void> {\\n+    console.log('🚀 Auto-Release Manager AI iniciado...\\\\n');\\n+    if (this.useAI) {\\n+      console.log('🤖 Modo AI activado - Generación inteligente habilitada');\\n+    } else {\\n+      console.log('📝 Modo básico - Sin generación AI');\\n+    }\\n+\\n+    try {\\n+      // Paso 1: Detectar cambios remotos y hacer pull\\n+      await this.pullRemoteChanges();\\n+\\n+      // Paso 2: Instalar dependencias\\n+      await this.installNodeDependencies();\\n+\\n+      // Paso 3: Verificar versión actual del changelog\\n+      const currentVersion = this.getCurrentVersion();\\n+      console.log(`📋 Versión actual: ${currentVersion}`);\\n+\\n+      // Paso 4: Verificar última release existente\\n+      const latestRelease = this.getLatestRelease();\\n+      console.log(`📦 Última release: ${latestRelease || 'ninguna'}`);\\n+\\n+      // Paso 5: Comparar versiones\\n+      if (latestRelease === currentVersion && !this.forceMode) {\\n+        console.log('✅ No hay nueva versión para compilar. Release ya existe.');\\n+        console.log('💡 Usa --force para forzar la recompilación.');\\n+        return;\\n+      }\\n+\\n+      if (this.forceMode && latestRelease === currentVersion) {\\n+        console.log('🔧 Modo forzado activado. Regenerando release existente...');\\n+      } else {\\n+        console.log(`🆕 Nueva versión detectada: ${currentVersion}`);\\n+      }\\n+      \\n+      console.log('⚡ Iniciando proceso de compilación y release...\\\\n');\\n+\\n+      // Paso 6: Compilar aplicación\\n+      await this.buildApplication();\\n+\\n+      // Paso 7: Crear estructura de release\\n+      const releaseInfo = this.parseVersion(currentVersion);\\n+      await this.createReleaseStructure(releaseInfo);\\n+\\n+      // Paso 8: Copiar archivos de distribución\\n+      await this.copyDistFiles(releaseInfo);\\n+\\n+      // Paso 9: Generar documentación (con AI si está disponible)\\n+      await this.generateReleaseDocumentation(releaseInfo);\\n+\\n+      // Paso 10: Commit y push con AI\\n+      await this.commitAndPushReleaseAI(releaseInfo);\\n+\\n+      // Paso 11: Crear GitHub Release (si está configurado)\\n+      await this.createGitHubRelease(releaseInfo);\\n+\\n+      // Paso 12: Actualizar sistema OTA\\n+      await this.updateOTASystem(currentVersion);\\n+\\n+      console.log('\\\\n✅ Auto-release AI completado exitosamente!');\\n+\\n+    } catch (error) {\\n+      console.error('❌ Error en auto-release:', error);\\n+      process.exit(1);\\n+    }\\n+  }\\n+\\n+  private async pullRemoteChanges(): Promise<void> {\\n+    console.log('🔄 Verificando cambios remotos...');\\n+    \\n+    try {\\n+      await this.runCommand('git', ['fetch', 'origin']);\\n+      const result = await this.runCommand('git', ['log', 'HEAD..origin/master', '--oneline']);\\n+      \\n+      if (result.stdout.trim()) {\\n+        console.log('📥 Cambios remotos detectados. Actualizando...');\\n+        \\n+        const statusResult = await this.runCommand('git', ['status', '--porcelain']);\\n+        if (statusResult.stdout.trim()) {\\n+          console.log('💾 Guardando cambios locales...');\\n+          await this.runCommand('git', ['stash', 'push', '-m', 'auto-release-stash']);\\n+        }\\n+        \\n+        await this.runCommand('git', ['pull', 'origin', 'master']);\\n+        console.log('✅ Actualización completa');\\n+      } else {\\n+        console.log('✅ Repositorio actualizado');\\n+      }\\n+    } catch (error) {\\n+      throw new Error(`Error al actualizar repositorio: ${error}`);\\n+    }\\n+  }\\n+\\n+  private async installNodeDependencies(): Promise<void> {\\n+    console.log('📦 Verificando dependencias...');\\n+    \\n+    try {\\n+      const result = await this.runCommand('npm', ['install']);\\n+      if (result.stdout.includes('up to date')) {\\n+        console.log('✅ Dependencias actualizadas');\\n+      } else {\\n+        console.log('✅ Dependencias instaladas/actualizadas');\\n+      }\\n+    } catch (error) {\\n+      throw new Error(`Error instalando dependencias: ${error}`);\\n+    }\\n+  }\\n+\\n+  private getCurrentVersion(): string {\\n+    try {\\n+      const changelog: ChangelogData = JSON.parse(readFileSync(this.changelogPath, 'utf8'));\\n+      return changelog.current_version;\\n+    } catch (error) {\\n+      throw new Error(`Error leyendo changelog: ${error}`);\\n+    }\\n+  }\\n+\\n+  private getLatestRelease(): string | null {\\n+    if (!existsSync(this.releaseDir)) {\\n+      return null;\\n+    }\\n+\\n+    const prefixes = readdirSync(this.releaseDir);\\n+    let latestVersion = null;\\n+    let latestDate = new Date(0);\\n+\\n+    for (const prefix of prefixes) {\\n+      const prefixDir = join(this.releaseDir, prefix);\\n+      if (!statSync(prefixDir).isDirectory()) continue;\\n+\\n+      const versions = readdirSync(prefixDir);\\n+      for (const version of versions) {\\n+        const versionDir = join(prefixDir, version);\\n+        if (!statSync(versionDir).isDirectory()) continue;\\n+\\n+        const stat = statSync(versionDir);\\n+        const modDate = stat.mtime;\\n+        \\n+        if (modDate > latestDate) {\\n+          latestDate = modDate;\\n+          latestVersion = `${prefix}-${version}`;\\n+        }\\n+      }\\n+    }\\n+\\n+    return latestVersion;\\n+  }\\n+\\n+  private parseVersion(version: string): ReleaseInfo {\\n+    const match = version.match(/^(pre-alpha-|alpha-|beta-|rc-)?(\\\\d+)\\\\.(\\\\d+)\\\\.(\\\\d+)$/);\\n+    if (!match) {\\n+      throw new Error(`Formato de versión inválido: ${version}`);\\n+    }\\n+\\n+    return {\\n+      version: version,\\n+      prefix: match[1] ? match[1].slice(0, -1) : 'stable',\\n+      major: parseInt(match[2]),\\n+      minor: parseInt(match[3]),\\n+      patch: parseInt(match[4])\\n+    };\\n+  }\\n+\\n+  private async buildApplication(): Promise<void> {\\n+    console.log('🔨 Compilando biblioteca...');\\n+    \\n+    try {\\n+      await this.runCommand('npm', ['run', 'clean']);\\n+      await this.runCommand('npm', ['run', 'build']);\\n+      console.log('✅ Compilación exitosa');\\n+      \\n+    } catch (error) {\\n+      throw new Error(`Error en compilación: ${error}`);\\n+    }\\n+  }\\n+\\n+  private async createReleaseStructure(releaseInfo: ReleaseInfo): Promise<void> {\\n+    const releaseDir = join(this.releaseDir, releaseInfo.prefix, `${releaseInfo.major}.${releaseInfo.minor}.${releaseInfo.patch}`);\\n+    \\n+    console.log(`📁 Creando estructura: ${releaseDir}`);\\n+    \\n+    if (!existsSync(releaseDir)) {\\n+      mkdirSync(releaseDir, { recursive: true });\\n+    }\\n+  }\\n+\\n+  private async copyDistFiles(releaseInfo: ReleaseInfo): Promise<void> {\\n+    const releaseDir = join(this.releaseDir, releaseInfo.prefix, `${releaseInfo.major}.${releaseInfo.minor}.${releaseInfo.patch}`);\\n+    const distDir = join(this.projectRoot, 'dist');\\n+\\n+    console.log('📋 Copiando archivos de distribución...');\\n+\\n+    try {\\n+      const files = readdirSync(distDir);\\n+      \\n+      for (const file of files) {\\n+        const sourceFile = join(distDir, file);\\n+        const destFile = join(releaseDir, file);\\n+        await this.runCommand('cp', [sourceFile, destFile]);\\n+      }\\n+\\n+      console.log('✅ Archivos de distribución copiados');\\n+\\n+    } catch (error) {\\n+      throw new Error(`Error copiando archivos de distribución: ${error}`);\\n+    }\\n+  }\\n+\\n+  private async generateReleaseDocumentation(releaseInfo: ReleaseInfo): Promise<void> {\\n+    console.log('📝 Generando documentación de release...');\\n+\\n+    if (this.useAI) {\\n+      await this.generateAIDocumentation(releaseInfo);\\n+    } else {\\n+      await this.generateBasicREADME(releaseInfo);\\n+    }\\n+  }\\n+\\n+  private async generateAIDocumentation(releaseInfo: ReleaseInfo): Promise<void> {\\n+    const releaseDir = join(this.releaseDir, releaseInfo.prefix, `${releaseInfo.major}.${releaseInfo.minor}.${releaseInfo.patch}`);\\n+    \\n+    console.log('🤖 Generando documentación con AI...');\\n+\\n+    try {\\n+      // Leer información del changelog\\n+      const changelog: ChangelogData = JSON.parse(readFileSync(this.changelogPath, 'utf8'));\\n+      const versionInfo = changelog.versions.find(v => v.version === releaseInfo.version);\\n+      \\n+      if (!versionInfo) {\\n+        throw new Error(`No se encontró información para la versión ${releaseInfo.version}`);\\n+      }\\n+\\n+      // Obtener información de archivos generados\\n+      const files = readdirSync(releaseDir);\\n+      const fileInfo = this.getFileInfo(releaseDir, files);\\n+\\n+      // Crear prompt para Gemini\\n+      const prompt = this.createDocumentationPrompt(releaseInfo, versionInfo, fileInfo);\\n+      \\n+      // Guardar el prompt\\n+      const promptPath = join(this.tempDir, 'release-doc-prompt.txt');\\n+      writeFileSync(promptPath, prompt);\\n+\\n+      try {\\n+        console.log('🚀 Consultando Gemini AI...');\\n+        const { spawn } = await import('child_process');\\n+        const geminiProcess = spawn('gemini', [], {\\n+          cwd: this.projectRoot,\\n+          stdio: ['pipe', 'pipe', 'pipe']\\n+        });\\n+        \\n+        geminiProcess.stdin?.write(prompt);\\n+        geminiProcess.stdin?.end();\\n+        \\n+        let aiResponse = '';\\n+        let errorOutput = '';\\n+        \\n+        geminiProcess.stdout?.on('data', (data) => {\\n+          aiResponse += data.toString();\\n+        });\\n+        \\n+        geminiProcess.stderr?.on('data', (data) => {\\n+          errorOutput += data.toString();\\n+        });\\n+        \\n+        const exitCode = await new Promise((resolve) => {\\n+          geminiProcess.on('exit', resolve);\\n+        });\\n+\\n+        if (exitCode !== 0) {\\n+          throw new Error(`Gemini CLI error: ${errorOutput || 'Gemini CLI failed'}`);\\n+        }\\n+        \\n+        // Guardar respuesta AI\\n+        const responsePath = join(this.tempDir, 'release-doc-response.md');\\n+        writeFileSync(responsePath, aiResponse);\\n+\\n+        // Procesar y usar la respuesta de AI\\n+        const processedREADME = this.processAIResponse(aiResponse, releaseInfo, versionInfo, fileInfo);\\n+        \\n+        const readmePath = join(releaseDir, 'README.md');\\n+        writeFileSync(readmePath, processedREADME, 'utf8');\\n+        \\n+        // Generar documentación adicional si AI lo sugiere\\n+        await this.generateAdditionalDocs(aiResponse, releaseDir, releaseInfo);\\n+        \\n+        console.log('✅ Documentación AI generada exitosamente');\\n+\\n+      } catch (aiError) {\\n+        console.warn('⚠️ Error con AI, usando generación básica:', aiError);\\n+        console.log('📝 Prompt guardado en:', promptPath);\\n+        await this.generateBasicREADME(releaseInfo);\\n+      }\\n+\\n+    } catch (error) {\\n+      throw new Error(`Error generando documentación AI: ${error}`);\\n+    }\\n+  }\\n+\\n+  private createDocumentationPrompt(releaseInfo: ReleaseInfo, versionInfo: any, fileInfo: any): string {\\n+    const config: GeminiPromptConfig = {\\n+      projectContext: {\\n+        name: BETTER_LOGGER_PROJECT_CONFIG.name,\\n+        description: BETTER_LOGGER_PROJECT_CONFIG.description,\\n+        version: releaseInfo.version,\\n+        techStack: [...BETTER_LOGGER_PROJECT_CONFIG.techStack],\\n+        targetPlatform: BETTER_LOGGER_PROJECT_CONFIG.targetPlatform,\\n+      },\\n+      analysisType: 'release',\\n+      specificContext: `Release ${releaseInfo.version} (${releaseInfo.prefix})`,\\n+      data: {\\n+        releaseInfo,\\n+        versionInfo,\\n+        fileInfo,\\n+        date: new Date().toISOString().split('T')[0]\\n+      }\\n+    };\\n+\\n+    return createReleasePrompt(config);\\n+\\n+  }\\n+\\n+  private getFileInfo(releaseDir: string, files: string[]): Record<string, string> {\\n+    const fileInfo: Record<string, string> = {};\\n+    \\n+    for (const file of files) {\\n+      if (file !== 'README.md') { // No incluir README que estamos generando\\n+        const filePath = join(releaseDir, file);\\n+        const stats = statSync(filePath);\\n+        const sizeMB = (stats.size / (1024 * 1024)).toFixed(1);\\n+        fileInfo[file] = `${sizeMB}MB`;\\n+      }\\n+    }\\n+    \\n+    return fileInfo;\\n+  }\\n+\\n+  private processAIResponse(aiResponse: string, releaseInfo: ReleaseInfo, versionInfo: any, fileInfo: any): string {\\n+    // Usar directamente la respuesta de AI como README\\n+    // En el futuro se puede añadir más procesamiento si es necesario\\n+    return aiResponse;\\n+  }\\n+\\n+  private async generateAdditionalDocs(aiResponse: string, releaseDir: string, releaseInfo: ReleaseInfo): Promise<void> {\\n+    // Placeholder para generar documentación adicional basada en respuesta AI\\n+    // Por ahora no genera documentación adicional\\n+    return Promise.resolve();\\n+  }\\n+\\n+  private async generateBasicREADME(releaseInfo: ReleaseInfo): Promise<void> {\\n+    // Fallback a generación básica si AI no está disponible\\n+    const releaseDir = join(this.releaseDir, releaseInfo.prefix, `${releaseInfo.major}.${releaseInfo.minor}.${releaseInfo.patch}`);\\n+    const changelog: ChangelogData = JSON.parse(readFileSync(this.changelogPath, 'utf8'));\\n+    const versionInfo = changelog.versions.find(v => v.version === releaseInfo.version);\\n+    \\n+    const date = new Date().toISOString().split('T')[0];\\n+    const files = readdirSync(releaseDir);\\n+    const fileInfo = this.getFileInfo(releaseDir, files);\\n+\\n+    const readme = `# EL Haido TPV - ${releaseInfo.prefix.charAt(0).toUpperCase() + releaseInfo.prefix.slice(1)} ${releaseInfo.major}.${releaseInfo.minor}.${releaseInfo.patch} - ARM64 Release\\n+\\n+## Información de la Release\\n+\\n+- **Versión**: ${releaseInfo.version}  \\n+- **Fecha**: ${date}\\n+- **Arquitectura**: ARM64 (aarch64)\\n+- **Plataforma objetivo**: Raspberry Pi 3B+\\n+- **Tipo de release**: ${versionInfo?.type} (${versionInfo?.title.toLowerCase()})\\n+\\n+## Archivos incluidos\\n+\\n+${Object.entries(fileInfo).map(([file, size]) => `- \\\\`${file}\\\\` - ${size}`).join('\\\\n')}\\n+\\n+## Instalación Rápida\\n+\\n+\\\\`\\\\`\\\\`bash\\n+sudo dpkg -i \\\"EL Haido TPV_${releaseInfo.major}.${releaseInfo.minor}.${releaseInfo.patch}_arm64.deb\\\"\\n+sudo apt-get install -f\\n+\\\\`\\\\`\\\\`\\n+\\n+---\\n+\\n+*Release generada automáticamente el ${date}*\\n+`;\\n+\\n+    const readmePath = join(releaseDir, 'README.md');\\n+    writeFileSync(readmePath, readme, 'utf8');\\n+    console.log('✅ README básico generado');\\n+  }\\n+\\n+  private async commitAndPushReleaseAI(releaseInfo: ReleaseInfo): Promise<void> {\\n+    console.log('📤 Realizando commit y push con AI...');\\n+\\n+    try {\\n+      const releaseDir = join(this.releaseDir, releaseInfo.prefix, `${releaseInfo.major}.${releaseInfo.minor}.${releaseInfo.patch}`);\\n+      \\n+      // Configurar git si es necesario\\n+      try {\\n+        await this.runCommand('git', ['config', 'user.name']);\\n+      } catch {\\n+        await this.runCommand('git', ['config', 'user.email', 'auto-release@build.local']);\\n+        await this.runCommand('git', ['config', 'user.name', 'Auto-Release AI System']);\\n+      }\\n+\\n+      // Añadir archivos\\n+      await this.runCommand('git', ['add', releaseDir]);\\n+      \\n+      // Añadir cambios en Cargo.toml si existen\\n+      const cargoPath = join(this.projectRoot, 'src-tauri/Cargo.toml');\\n+      const cargoLockPath = join(this.projectRoot, 'src-tauri/Cargo.lock');\\n+      \\n+      if (existsSync(cargoPath)) {\\n+        await this.runCommand('git', ['add', cargoPath]);\\n+      }\\n+      if (existsSync(cargoLockPath)) {\\n+        await this.runCommand('git', ['add', cargoLockPath]);\\n+      }\\n+\\n+      // Verificar si hay algo que commitear\\n+      const statusResult = await this.runCommand('git', ['status', '--porcelain']);\\n+      if (!statusResult.stdout.trim()) {\\n+        console.log('⚠️ No hay cambios para commitear.');\\n+        return;\\n+      }\\n+\\n+      if (this.useAI) {\\n+        // Usar commit-generator con contexto AI mejorado\\n+        console.log('🤖 Generando commit automático con AI avanzado...');\\n+        const extraContext = this.createCommitContext(releaseInfo);\\n+\\n+        try {\\n+          await this.runCommand('node', ['project-utils/commit-generator.ts'], {\\n+            env: {\\n+              ...process.env,\\n+              COMMIT_EXTRA_CONTEXT: extraContext\\n+            }\\n+          });\\n+          \\n+          console.log('✅ Commit AI generado exitosamente');\\n+        } catch (error) {\\n+          console.warn('⚠️ Error con commit AI, usando manual...');\\n+          const commitMessage = this.generateCommitMessage(releaseInfo);\\n+          await this.runCommand('git', ['commit', '-m', commitMessage]);\\n+        }\\n+      } else {\\n+        // Commit manual\\n+        const commitMessage = this.generateCommitMessage(releaseInfo);\\n+        await this.runCommand('git', ['commit', '-m', commitMessage]);\\n+      }\\n+\\n+      // Push\\n+      await this.runCommand('git', ['push', 'origin', 'master']);\\n+      console.log('✅ Push completado');\\n+\\n+    } catch (error) {\\n+      throw new Error(`Error en commit/push: ${error}`);\\n+    }\\n+  }\\n+\\n+  private createCommitContext(releaseInfo: ReleaseInfo): string {\\n+    const changelog: ChangelogData = JSON.parse(readFileSync(this.changelogPath, 'utf8'));\\n+    const versionInfo = changelog.versions.find(v => v.version === releaseInfo.version);\\n+    \\n+    return `AUTO-RELEASE CONTEXT - Version ${releaseInfo.version}\\n+\\n+Esto es un auto-release generado automáticamente para la versión ${releaseInfo.version}.\\n+Se han compilado y añadido binarios ARM64 optimizados para Raspberry Pi 3B+.\\n+\\n+ARCHIVOS INCLUIDOS:\\n+- Binario ejecutable nativo ARM64\\n+- Paquete Debian (.deb) para fácil instalación\\n+- Paquete RPM (.rpm) para distribuciones basadas en RPM\\n+- README detallado ${this.useAI ? 'generado con AI' : 'básico'}\\n+${this.useAI ? '- Documentación adicional generada por AI' : ''}\\n+\\n+CARACTERÍSTICAS DE ESTA VERSIÓN:\\n+${versionInfo?.changes.slice(0, 5).map(c => `- ${c.type}: ${c.title}`).join('\\\\n') || '- Versión de mantenimiento'}\\n+\\n+NOTAS TÉCNICAS:\\n+- Compilado nativamente en ARM64 con optimizaciones específicas\\n+- OpenSSL configurado para cross-compilation\\n+- Todos los tests pasaron exitosamente\\n+${this.useAI ? '- Documentación mejorada con inteligencia artificial' : ''}\\n+\\n+Por favor genera un commit tipo 'release(${releaseInfo.version})' que refleje adecuadamente:\\n+1. Que es un auto-release automatizado\\n+2. Las características principales de esta versión\\n+3. Que incluye binarios optimizados para RPi\\n+4. ${this.useAI ? 'Que usa AI para documentación mejorada' : 'Documentación estándar incluida'}\\n+\\n+Mantén el mensaje profesional pero informativo.`;\\n+  }\\n+\\n+  private generateCommitMessage(releaseInfo: ReleaseInfo): string {\\n+    const changelog: ChangelogData = JSON.parse(readFileSync(this.changelogPath, 'utf8'));\\n+    const versionInfo = changelog.versions.find(v => v.version === releaseInfo.version);\\n+    \\n+    const features = versionInfo?.changes\\n+      .filter(c => c.type === 'feature')\\n+      .slice(0, 3)\\n+      .map(c => `✨ ${c.title}`)\\n+      .join('\\\\n') || '';\\n+\\n+    const improvements = versionInfo?.changes\\n+      .filter(c => c.type === 'improvement')\\n+      .slice(0, 2) \\n+      .map(c => `⚙️ ${c.title}`)\\n+      .join('\\\\n') || '';\\n+\\n+    return `release(${releaseInfo.version}): auto-release ARM64 ${this.useAI ? 'con AI' : 'binarios'}\\n+\\n+- Binario ejecutable principal\\n+- Paquete Debian (.deb)\\n+- Paquete RPM (.rpm)  \\n+- README ${this.useAI ? 'generado con AI' : 'automático'}\\n+${this.useAI ? '- Documentación adicional AI' : ''}\\n+\\n+${features ? 'Nuevas características:\\\\n' + features : ''}\\n+${improvements ? '\\\\nMejoras:\\\\n' + improvements : ''}\\n+\\n+${this.useAI ? 'Generado por Auto-Release Manager AI con Gemini.' : 'Generado por Auto-Release Manager.'}\\n+Compilado nativamente en ARM64 para RPi3+ con optimizaciones.`;\\n+  }\\n+\\n+  /**\\n+   * Crea GitHub Release usando el GitHub Release Manager\\n+   */\\n+  private async createGitHubRelease(releaseInfo: ReleaseInfo): Promise<void> {\\n+    if (this.noGitHub) {\\n+      console.log('⏭️ GitHub Release deshabilitado por --no-github');\\n+      return;\\n+    }\\n+\\n+    console.log(`🚀 Creando GitHub Release ${this.useAI ? 'con documentación AI' : 'con documentación básica'}...`);\\n+\\n+    try {\\n+      // Verificar que GitHub CLI esté disponible\\n+      await this.runCommand('gh', ['--version']);\\n+      \\n+      // Ejecutar GitHub Release Manager con configuraciones apropiadas\\n+      const ghArgs = process.argv.includes('--force') ? ['--force'] : [];\\n+      await this.runCommand('node', ['project-utils/github-release-manager.ts', ...ghArgs]);\\n+      \\n+      console.log(`✅ GitHub Release creado exitosamente ${this.useAI ? '(con mejoras AI)' : ''}`);\\n+      \\n+    } catch (error) {\\n+      console.warn('⚠️ No se pudo crear GitHub Release:', error);\\n+      console.log('💡 Verifica que gh CLI esté instalado y autenticado');\\n+      console.log('💡 O usa --no-github para deshabilitar GitHub releases');\\n+    }\\n+  }\\n+\\n+  /**\\n+   * Actualiza el sistema OTA después de un release exitoso\\n+   * Sincroniza la nueva versión con los canales OTA apropiados\\n+   */\\n+  private async updateOTASystem(version: string): Promise<void> {\\n+    console.log(`🔄 Actualizando sistema OTA para versión ${version}...`);\\n+    \\n+    try {\\n+      // El version-manager.ts ya sincroniza automáticamente con OTA,\\n+      // pero podemos hacer validaciones adicionales aquí\\n+      \\n+      // Verificar que package.json fue actualizado correctamente\\n+      const packagePath = join(this.projectRoot, 'package.json');\\n+      if (!existsSync(packagePath)) {\\n+        console.warn('⚠️ package.json no existe');\\n+        return;\\n+      }\\n+\\n+      const packageData = JSON.parse(readFileSync(packagePath, 'utf-8'));\\n+      \\n+      if (packageData.version === version) {\\n+        console.log(`✅ package.json actualizado correctamente: ${version}`);\\n+      } else {\\n+        console.warn(`⚠️ Posible desincronización en package.json:`);\\n+        console.warn(`   Esperado: ${version}`);\\n+        console.warn(`   Actual: ${packageData.version || 'N/A'}`);\\n+      }\\n+      \\n+    } catch (error) {\\n+      console.warn(`⚠️ Error verificando package.json: ${error}`);\\n+      console.warn('El release continuará sin verificación');\\n+    }\\n+  }\\n+\\n+  private async runCommand(command: string, args: string[] = [], options: any = {}): Promise<any> {\\n+    return new Promise((resolve, reject) => {\\n+      const proc = spawn(command, args, {\\n+        cwd: options.cwd || this.projectRoot,\\n+        env: options.env || process.env,\\n+        stdio: ['pipe', 'pipe', 'pipe']\\n+      });\\n+\\n+      let stdout = '';\\n+      let stderr = '';\\n+\\n+      proc.stdout?.on('data', (data) => {\\n+        stdout += data.toString();\\n+      });\\n+\\n+      proc.stderr?.on('data', (data) => {\\n+        stderr += data.toString();\\n+      });\\n+\\n+      proc.on('exit', (code) => {\\n+        if (code !== 0) {\\n+          reject(new Error(`Command failed: ${command} ${args.join(' ')}\\\\n${stderr}`));\\n+        } else {\\n+          resolve({ stdout, stderr });\\n+        }\\n+      });\\n+\\n+      proc.on('error', (error) => {\\n+        reject(error);\\n+      });\\n+    });\\n+  }\\n+}\\n+\\n+// Ejecutar si se llama directamente\\n+if (import.meta.main) {\\n+  const args = process.argv.slice(2);\\n+  \\n+  if (args.includes('--help') || args.includes('-h')) {\\n+    console.log(`\\n+🚀 Auto-Release Manager AI para Better Logger\\n+\\n+Automatiza el proceso completo con AI para documentación inteligente y commits mejorados.\\n+\\n+Uso:\\n+  node project-utils/auto-release-gemini.ts [opciones]\\n+\\n+Opciones:\\n+  --ai            Activar generación con AI (por defecto)\\n+  --no-ai         Deshabilitar AI, usar generación básica\\n+  --force         Forzar recompilación aunque la release ya exista\\n+  --no-github     Deshabilitar creación automática de GitHub releases\\n+  --help, -h      Mostrar esta ayuda\\n+\\n+Ejemplos:\\n+  node project-utils/auto-release-gemini.ts --ai\\n+  node project-utils/auto-release-gemini.ts --no-ai\\n+  node project-utils/auto-release-gemini.ts --force --no-github\\n+`);\\n+    process.exit(0);\\n+  }\\n+  \\n+  const manager = new AutoReleaseManagerAI();\\n+  await manager.run();\\n+}\\n+\\n+export { AutoReleaseManagerAI };\",\n+      \"lines_added\": 743,\n+      \"lines_removed\": 0,\n+      \"is_binary\": false\n+    },\n+    {\n+      \"path\": \"project-utils/commit-generator.ts\",\n+      \"status\": \"added\",\n+      \"diff\": \"diff --git a/project-utils/commit-generator.ts b/project-utils/commit-generator.ts\\nnew file mode 100755\\nindex 0000000..1e0df07\\n--- /dev/null\\n+++ b/project-utils/commit-generator.ts\\n@@ -0,0 +1,858 @@\\n+#!/usr/bin/env node\\n+\\n+/**\\n+ * Generador Automático de Commits con Gemini CLI\\n+ * Analiza todos los cambios del repositorio y genera commits coherentes\\n+ * siguiendo los patrones establecidos para el proyecto Better Logger\\n+ */\\n+\\n+import { spawn } from 'child_process';\\n+import { readFileSync, writeFileSync, existsSync } from 'fs';\\n+import { createCommitPrompt, GeminiResponseParser, BETTER_LOGGER_PROJECT_CONFIG, type GeminiPromptConfig } from './prompt-templates';\\n+import { join } from 'path';\\n+\\n+interface FileChange {\\n+  path: string;\\n+  status: 'modified' | 'added' | 'deleted' | 'renamed' | 'untracked';\\n+  diff?: string;\\n+  lines_added?: number;\\n+  lines_removed?: number;\\n+  is_binary?: boolean;\\n+}\\n+\\n+interface GitStats {\\n+  total_files: number;\\n+  total_additions: number;\\n+  total_deletions: number;\\n+  files_by_extension: Record<string, number>;\\n+  directories_affected: string[];\\n+}\\n+\\n+interface CommitAnalysis {\\n+  files: FileChange[];\\n+  stats: GitStats;\\n+  project_context: {\\n+    name: string;\\n+    description: string;\\n+    tech_stack: string[];\\n+    target_platform: string;\\n+  };\\n+  commit_patterns: string;\\n+}\\n+\\n+interface CommitProposal {\\n+  title: string;\\n+  description: string;\\n+  technical: string;\\n+  changelog: string;\\n+  files?: string[];\\n+}\\n+\\n+class CommitGenerator {\\n+  private projectRoot: string;\\n+  private tempDir: string;\\n+  private autoApprove: boolean;\\n+  private noPush: boolean;\\n+  private quiet: boolean;\\n+  private proposalFile?: string;\\n+  private outputDir?: string;\\n+\\n+  constructor() {\\n+    this.projectRoot = process.cwd();\\n+    this.tempDir = this.getArgValue('--output-dir') || join(this.projectRoot, 'project-utils/.temp');\\n+    this.autoApprove = process.argv.includes('--auto-approve');\\n+    this.noPush = process.argv.includes('--no-push');\\n+    this.quiet = process.argv.includes('--quiet');\\n+    this.proposalFile = this.getArgValue('--proposal-file');\\n+    this.outputDir = this.getArgValue('--output-dir');\\n+    this.ensureTempDir();\\n+  }\\n+  \\n+  private getArgValue(argName: string): string | undefined {\\n+    const args = process.argv;\\n+    const argIndex = args.indexOf(argName);\\n+    if (argIndex > -1 && args[argIndex + 1] && !args[argIndex + 1].startsWith('--')) {\\n+      return args[argIndex + 1];\\n+    }\\n+    return undefined;\\n+  }\\n+\\n+  private ensureTempDir(): void {\\n+    if (!existsSync(this.tempDir)) {\\n+      const { spawnSync } = require('child_process');\\n+      spawnSync('mkdir', ['-p', this.tempDir], { stdio: 'ignore' });\\n+    }\\n+  }\\n+  \\n+  private log(message: string): void {\\n+    if (!this.quiet) {\\n+      console.log(message);\\n+    }\\n+  }\\n+  \\n+  private logInfo(message: string): void {\\n+    if (!this.quiet) {\\n+      console.log(message);\\n+    }\\n+  }\\n+\\n+  /**\\n+   * Ejecuta un comando git y devuelve el resultado\\n+   */\\n+  private async gitCommand(args: string[]): Promise<string> {\\n+    const { spawnSync } = await import('child_process');\\n+    const result = spawnSync('git', args, {\\n+      cwd: this.projectRoot,\\n+      encoding: 'utf-8',\\n+      stdio: ['pipe', 'pipe', 'pipe']\\n+    });\\n+\\n+    if (result.status !== 0) {\\n+      const error = result.stderr || 'Git command failed';\\n+      throw new Error(`Git error: ${error}`);\\n+    }\\n+\\n+    return (result.stdout || '').trim();\\n+  }\\n+\\n+  /**\\n+   * Agrega todos los cambios al staging area\\n+   */\\n+  private async stageAllChanges(): Promise<void> {\\n+    this.log('📦 Agregando todos los cambios al staging area...');\\n+    await this.gitCommand(['add', '-A']);\\n+  }\\n+\\n+  /**\\n+   * Obtiene el estado actual del repositorio\\n+   */\\n+  private async getRepositoryStatus(): Promise<FileChange[]> {\\n+    this.log('🔍 Analizando estado del repositorio...');\\n+    \\n+    const statusOutput = await this.gitCommand(['status', '--porcelain']);\\n+    const files: FileChange[] = [];\\n+\\n+    for (const line of statusOutput.split('\\\\n').filter(l => l.trim())) {\\n+      const status = line.substring(0, 2);\\n+      const filePath = line.substring(3);\\n+\\n+      let fileStatus: FileChange['status'];\\n+      if (status.includes('A')) fileStatus = 'added';\\n+      else if (status.includes('M')) fileStatus = 'modified';\\n+      else if (status.includes('D')) fileStatus = 'deleted';\\n+      else if (status.includes('R')) fileStatus = 'renamed';\\n+      else fileStatus = 'untracked';\\n+\\n+      files.push({\\n+        path: filePath,\\n+        status: fileStatus,\\n+      });\\n+    }\\n+\\n+    return files;\\n+  }\\n+\\n+  /**\\n+   * Obtiene el diff de un archivo específico\\n+   */\\n+  private async getFileDiff(filePath: string, isStaged: boolean = true): Promise<string> {\\n+    try {\\n+      const diffArgs = isStaged \\n+        ? ['diff', '--cached', '--', filePath]\\n+        : ['diff', '--', filePath];\\n+      \\n+      return await this.gitCommand(diffArgs);\\n+    } catch (error) {\\n+      // Si es un archivo nuevo o binario, devolver información básica\\n+      try {\\n+        const showArgs = ['show', `HEAD:${filePath}`];\\n+        await this.gitCommand(showArgs);\\n+        return `New file: ${filePath}`;\\n+      } catch {\\n+        return `Binary or new file: ${filePath}`;\\n+      }\\n+    }\\n+  }\\n+\\n+  /**\\n+   * Obtiene estadísticas del repositorio\\n+   */\\n+  private async getGitStats(): Promise<GitStats> {\\n+    this.log('📊 Calculando estadísticas de cambios...');\\n+    \\n+    try {\\n+      const diffStat = await this.gitCommand(['diff', '--cached', '--stat']);\\n+      const lines = diffStat.split('\\\\n').filter(l => l.trim());\\n+      \\n+      let totalFiles = 0;\\n+      let totalAdditions = 0;\\n+      let totalDeletions = 0;\\n+      const filesByExtension: Record<string, number> = {};\\n+      const directoriesAffected = new Set<string>();\\n+\\n+      for (const line of lines) {\\n+        if (line.includes('|')) {\\n+          totalFiles++;\\n+          const filePath = line.split('|')[0].trim();\\n+          \\n+          // Extraer extensión\\n+          const ext = filePath.split('.').pop() || 'no-ext';\\n+          filesByExtension[ext] = (filesByExtension[ext] || 0) + 1;\\n+          \\n+          // Extraer directorio\\n+          const dir = filePath.split('/')[0];\\n+          directoriesAffected.add(dir);\\n+          \\n+          // Extraer adiciones y eliminaciones\\n+          const stats = line.split('|')[1];\\n+          const plusCount = (stats.match(/\\\\+/g) || []).length;\\n+          const minusCount = (stats.match(/\\\\-/g) || []).length;\\n+          totalAdditions += plusCount;\\n+          totalDeletions += minusCount;\\n+        }\\n+      }\\n+\\n+      return {\\n+        total_files: totalFiles,\\n+        total_additions: totalAdditions,\\n+        total_deletions: totalDeletions,\\n+        files_by_extension: filesByExtension,\\n+        directories_affected: Array.from(directoriesAffected),\\n+      };\\n+    } catch (error) {\\n+      return {\\n+        total_files: 0,\\n+        total_additions: 0,\\n+        total_deletions: 0,\\n+        files_by_extension: {},\\n+        directories_affected: [],\\n+      };\\n+    }\\n+  }\\n+\\n+  /**\\n+   * Genera el contexto completo para Gemini CLI\\n+   */\\n+  private async generateAnalysisContext(): Promise<CommitAnalysis> {\\n+    this.log('🧠 Generando contexto de análisis...');\\n+\\n+    await this.stageAllChanges();\\n+    \\n+    const files = await this.getRepositoryStatus();\\n+    const stats = await this.getGitStats();\\n+\\n+    // Obtener diffs para cada archivo\\n+    for (const file of files) {\\n+      if (file.status !== 'deleted') {\\n+        try {\\n+          file.diff = await this.getFileDiff(file.path);\\n+          \\n+          // Calcular líneas agregadas/eliminadas del diff\\n+          if (file.diff) {\\n+            file.lines_added = (file.diff.match(/^\\\\+[^+]/gm) || []).length;\\n+            file.lines_removed = (file.diff.match(/^-[^-]/gm) || []).length;\\n+            file.is_binary = file.diff.includes('Binary files differ');\\n+          }\\n+        } catch (error) {\\n+          file.diff = `Error getting diff: ${error}`;\\n+        }\\n+      }\\n+    }\\n+\\n+    // Cargar patrones de commit\\n+    const patternsPath = join(this.projectRoot, 'commit-templates/commit-patterns.md');\\n+    const commitPatterns = existsSync(patternsPath) \\n+      ? readFileSync(patternsPath, 'utf-8')\\n+      : 'No commit patterns found';\\n+\\n+    return {\\n+      files,\\n+      stats,\\n+      project_context: {\\n+        name: 'OpenTUI',\\n+        description: 'Modern Terminal User Interface Framework',\\n+        tech_stack: ['TypeScript', 'Node.js', 'Terminal UI', 'CLI'],\\n+        target_platform: 'Cross-platform (macOS, Linux, Windows)',\\n+      },\\n+      commit_patterns: commitPatterns,\\n+    };\\n+  }\\n+\\n+  private createStandardPrompt(analysis: CommitAnalysis, extraContext: string = ''): string {\\n+    const config: GeminiPromptConfig = {\\n+      projectContext: {\\n+        name: BETTER_LOGGER_PROJECT_CONFIG.name,\\n+        description: BETTER_LOGGER_PROJECT_CONFIG.description,\\n+        version: BETTER_LOGGER_PROJECT_CONFIG.version,\\n+        techStack: [...BETTER_LOGGER_PROJECT_CONFIG.techStack],\\n+        targetPlatform: BETTER_LOGGER_PROJECT_CONFIG.targetPlatform,\\n+      },\\n+      analysisType: 'commit',\\n+      specificContext: extraContext,\\n+      data: {\\n+        stats: analysis.stats,\\n+        files: analysis.files.map(file => ({\\n+          path: file.path,\\n+          status: file.status,\\n+          lines_added: file.lines_added,\\n+          lines_removed: file.lines_removed,\\n+          is_binary: file.is_binary,\\n+          diff_preview: file.diff?.substring(0, 1500) || 'No diff available'\\n+        })),\\n+        patterns: analysis.commit_patterns\\n+      }\\n+    };\\n+\\n+    return createCommitPrompt(config);\\n+  }\\n+\\n+  private createExhaustivePrompt(analysis: CommitAnalysis, extraContext: string = ''): string {\\n+    const config: GeminiPromptConfig = {\\n+      projectContext: {\\n+        name: BETTER_LOGGER_PROJECT_CONFIG.name,\\n+        description: BETTER_LOGGER_PROJECT_CONFIG.description,\\n+        version: BETTER_LOGGER_PROJECT_CONFIG.version,\\n+        techStack: [...BETTER_LOGGER_PROJECT_CONFIG.techStack],\\n+        targetPlatform: BETTER_LOGGER_PROJECT_CONFIG.targetPlatform,\\n+      },\\n+      analysisType: 'commit',\\n+      specificContext: `MODO EXHAUSTIVO: Análisis profundo requerido.\\\\n${extraContext}`,\\n+      data: {\\n+        mode: 'exhaustive',\\n+        stats: analysis.stats,\\n+        files: analysis.files.map(file => ({\\n+          path: file.path,\\n+          status: file.status,\\n+          lines_added: file.lines_added,\\n+          lines_removed: file.lines_removed,\\n+          is_binary: file.is_binary,\\n+          diff_preview: file.diff?.substring(0, 2000) || 'No diff available'\\n+        })),\\n+        patterns: analysis.commit_patterns\\n+      }\\n+    };\\n+\\n+    return createCommitPrompt(config);\\n+  }\\n+\\n+  /**\\n+   * Construye contexto mejorado con parámetros adicionales\\n+   */\\n+  private buildEnhancedContext(\\n+    extraContext: string,\\n+    contextDescription: string,\\n+    workType: string,\\n+    affectedComponents: string,\\n+    performanceImpact: string,\\n+    breakingChanges: string\\n+  ): string {\\n+    let enhancedContext = extraContext;\\n+\\n+    const contextParts = [];\\n+\\n+    if (contextDescription) {\\n+      contextParts.push(`**Descripción del trabajo**: ${contextDescription}`);\\n+    }\\n+\\n+    if (workType) {\\n+      const workTypeDescriptions = {\\n+        'feature': 'Nueva funcionalidad o capacidad',\\n+        'bugfix': 'Corrección de error o fallo',\\n+        'refactor': 'Mejora del código sin cambios de funcionalidad',\\n+        'docs': 'Actualización de documentación',\\n+        'performance': 'Optimización de rendimiento',\\n+        'ui': 'Cambios en interfaz de usuario',\\n+        'api': 'Modificaciones en API o endpoints',\\n+        'security': 'Mejoras de seguridad',\\n+        'test': 'Adición o modificación de tests'\\n+      };\\n+      contextParts.push(`**Tipo de trabajo**: ${workType} - ${workTypeDescriptions[workType] || workType}`);\\n+    }\\n+\\n+    if (affectedComponents) {\\n+      contextParts.push(`**Componentes afectados**: ${affectedComponents}`);\\n+    }\\n+\\n+    if (performanceImpact) {\\n+      const performanceDescriptions = {\\n+        'mejora': 'Este cambio mejora el rendimiento del sistema',\\n+        'neutro': 'Este cambio no afecta significativamente el rendimiento',\\n+        'regresion': 'Este cambio puede impactar negativamente el rendimiento (justificado por otros beneficios)'\\n+      };\\n+      contextParts.push(`**Impacto en rendimiento**: ${performanceImpact} - ${performanceDescriptions[performanceImpact] || performanceImpact}`);\\n+    }\\n+\\n+    if (breakingChanges) {\\n+      const breakingDescription = breakingChanges.toLowerCase() === 'si' \\n+        ? 'Este cambio introduce cambios que rompen compatibilidad hacia atrás'\\n+        : 'Este cambio mantiene compatibilidad hacia atrás';\\n+      contextParts.push(`**Cambios incompatibles**: ${breakingChanges} - ${breakingDescription}`);\\n+    }\\n+\\n+    if (contextParts.length > 0) {\\n+      const contextSection = contextParts.join('\\\\n');\\n+      enhancedContext = enhancedContext \\n+        ? `${enhancedContext}\\\\n\\\\n## Contexto Estructurado\\\\n\\\\n${contextSection}`\\n+        : `## Contexto Estructurado\\\\n\\\\n${contextSection}`;\\n+    }\\n+\\n+    return enhancedContext;\\n+  }\\n+\\n+  /**\\n+   * Invoca Gemini CLI con el contexto de análisis\\n+   */\\n+  private async analyzeWithGemini(analysis: CommitAnalysis, exhaustive: boolean = false, extraContext: string = ''): Promise<string> {\\n+    this.log(`🤖 Analizando cambios con Gemini CLI... ${exhaustive ? '(Modo Exhaustivo)' : ''}`);\\n+\\n+    const prompt = exhaustive\\n+      ? this.createExhaustivePrompt(analysis, extraContext)\\n+      : this.createStandardPrompt(analysis, extraContext);\\n+\\n+    // Guardar el contexto en un archivo temporal\\n+    const contextPath = join(this.tempDir, 'analysis-context.json');\\n+    writeFileSync(contextPath, JSON.stringify(analysis, null, 2));\\n+\\n+    // Guardar el prompt en un archivo temporal\\n+    const promptPath = join(this.tempDir, 'gemini-prompt.txt');\\n+    writeFileSync(promptPath, prompt);\\n+\\n+    try {\\n+      // Ejecutar Gemini CLI\\n+      const geminiResult = Bun.spawnSync(['gemini'], {\\n+        cwd: this.projectRoot,\\n+        stdin: Buffer.from(prompt) as any,\\n+        stdout: 'pipe',\\n+        stderr: 'pipe',\\n+      });\\n+\\n+      if (geminiResult.exitCode !== 0) {\\n+        const error = geminiResult.stderr?.toString() || 'Gemini CLI failed';\\n+        throw new Error(`Gemini CLI error: ${error}`);\\n+      }\\n+\\n+      const response = geminiResult.stdout?.toString() || '';\\n+      \\n+      // Guardar la respuesta\\n+      const responsePath = join(this.tempDir, 'gemini-response.md');\\n+      writeFileSync(responsePath, response);\\n+\\n+      return response;\\n+    } catch (error) {\\n+      console.error('❌ Error ejecutando Gemini CLI:', error);\\n+      console.error('💡 Verifica que Gemini CLI esté instalado y configurado');\\n+      console.log('📝 Contexto guardado en:', contextPath);\\n+      console.log('📝 Prompt guardado en:', promptPath);\\n+      throw error;\\n+    }\\n+  }\\n+\\n+  /**\\n+   * Guarda la propuesta de commits\\n+   */\\n+  private saveCommitProposal(analysis: string): string {\\n+    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');\\n+    const proposalPath = join(this.tempDir, `commit-proposal-${timestamp}.md`);\\n+    \\n+    writeFileSync(proposalPath, analysis);\\n+    return proposalPath;\\n+  }\\n+\\n+  /**\\n+   * Parsea propuestas de commit de la respuesta de Gemini\\n+   */\\n+  private parseCommitProposals(aiResponse: string): CommitProposal[] {\\n+    // Usar el parser estandarizado\\n+    const parsedProposals = GeminiResponseParser.parseCommitProposals(aiResponse);\\n+    \\n+    // Convertir al formato interno\\n+    return parsedProposals.map(proposal => ({\\n+      title: proposal.title,\\n+      description: proposal.description,\\n+      technical: proposal.technical,\\n+      changelog: proposal.changelog,\\n+      files: [] // Usar todos los archivos disponibles\\n+    }));\\n+  }\\n+\\n+  /**\\n+   * Ejecuta un commit individual\\n+   */\\n+  private async executeCommit(proposal: CommitProposal, allFiles: FileChange[]): Promise<boolean> {\\n+    this.log(`\\\\n🔨 Ejecutando commit: ${proposal.title}`);\\n+    \\n+    try {\\n+      // Si no hay archivos específicos, usar todos los archivos disponibles (excluyendo temp files)\\n+      const targetFiles = proposal.files && proposal.files.length > 0 \\n+        ? proposal.files \\n+        : allFiles\\n+            .map(f => f.path)\\n+            .filter(path => !path.includes('.temp/') && !path.startsWith('.release-notes-'));\\n+      \\n+      // Agregar archivos específicos al staging area\\n+      for (const file of targetFiles) {\\n+        try {\\n+          await this.gitCommand(['add', file]);\\n+          this.log(`  ✓ Agregado: ${file}`);\\n+        } catch (error) {\\n+          console.warn(`  ⚠️ No se pudo agregar ${file}:`, error);\\n+        }\\n+      }\\n+      \\n+      // Verificar que hay algo para commitear\\n+      try {\\n+        const statusResult = await this.gitCommand(['diff', '--cached', '--name-only']);\\n+        if (!statusResult.trim()) {\\n+          console.warn(`  ⚠️ No hay cambios staged para este commit`);\\n+          return false;\\n+        }\\n+      } catch (error) {\\n+        // Fallback si diff --cached no funciona\\n+        this.log(`  🔍 Verificando staging area...`);\\n+      }\\n+      \\n+      // Crear mensaje de commit\\n+      let commitMessage = proposal.title;\\n+      if (proposal.description) {\\n+        commitMessage += `\\\\n\\\\n${proposal.description}`;\\n+      }\\n+      if (proposal.technical) {\\n+        commitMessage += `\\\\n\\\\n<technical>\\\\n${proposal.technical}\\\\n</technical>`;\\n+      }\\n+      if (proposal.changelog) {\\n+        commitMessage += `\\\\n\\\\n<changelog>\\\\n${proposal.changelog}\\\\n</changelog>`;\\n+      }\\n+      \\n+      // Ejecutar commit\\n+      await this.gitCommand(['commit', '-m', commitMessage]);\\n+      this.log(`  ✅ Commit exitoso`);\\n+      return true;\\n+      \\n+    } catch (error) {\\n+      console.error(`  ❌ Error en commit:`, error);\\n+      return false;\\n+    }\\n+  }\\n+\\n+  /**\\n+   * Ejecuta push de todos los commits\\n+   */\\n+  private async pushCommits(): Promise<void> {\\n+    if (this.noPush) {\\n+      this.log('⏭️ Push deshabilitado por --no-push');\\n+      return;\\n+    }\\n+    \\n+    this.log('\\\\n📤 Pushing commits to remote...');\\n+    \\n+    try {\\n+      await this.gitCommand(['push', 'origin', 'master']);\\n+      this.log('✅ Push completado exitosamente');\\n+    } catch (error) {\\n+      console.error('❌ Error en push:', error);\\n+      this.log('💡 Los commits están en tu repositorio local');\\n+    }\\n+  }\\n+\\n+  /**\\n+   * Valida que auto-approve es seguro de ejecutar\\n+   */\\n+  private async validateAutoApprove(): Promise<boolean> {\\n+    try {\\n+      // Verificar que estamos en la rama correcta\\n+      const currentBranch = await this.gitCommand(['branch', '--show-current']);\\n+      if (currentBranch !== 'master') {\\n+        console.warn(`⚠️ No estás en la rama master (actual: ${currentBranch})`);\\n+        return false;\\n+      }\\n+      \\n+      // Verificar que el repositorio está limpio (sin conflictos)\\n+      const statusOutput = await this.gitCommand(['status', '--porcelain']);\\n+      const conflicts = statusOutput.split('\\\\n').filter(line => line.startsWith('UU'));\\n+      if (conflicts.length > 0) {\\n+        console.error('❌ Hay conflictos de merge sin resolver');\\n+        return false;\\n+      }\\n+      \\n+      return true;\\n+    } catch (error) {\\n+      console.error('❌ Error validando repositorio:', error);\\n+      return false;\\n+    }\\n+  }\\n+\\n+  /**\\n+   * Ejecuta commits desde un archivo de propuesta existente\\n+   */\\n+  private async executeFromProposalFile(proposalPath: string): Promise<void> {\\n+    this.log(`📂 Cargando propuesta desde: ${proposalPath}`);\\n+    \\n+    try {\\n+      const proposalContent = readFileSync(proposalPath, 'utf-8');\\n+      const proposals = this.parseCommitProposals(proposalContent);\\n+      \\n+      if (proposals.length === 0) {\\n+        console.error('❌ No se encontraron commits válidos en el archivo de propuesta');\\n+        return;\\n+      }\\n+      \\n+      this.log(`📦 Encontrados ${proposals.length} commits en la propuesta:`);\\n+      proposals.forEach((p, i) => {\\n+        this.log(`  ${i + 1}. ${p.title}`);\\n+      });\\n+      \\n+      if (!this.autoApprove) {\\n+        console.log('\\\\n💡 Usa --auto-approve para ejecutar estos commits automáticamente');\\n+        return;\\n+      }\\n+      \\n+      // Obtener archivos actuales para el contexto\\n+      const files = await this.getRepositoryStatus();\\n+      \\n+      let successfulCommits = 0;\\n+      \\n+      for (let i = 0; i < proposals.length; i++) {\\n+        const proposal = proposals[i];\\n+        const success = await this.executeCommit(proposal, files);\\n+        if (success) {\\n+          successfulCommits++;\\n+        } else {\\n+          console.error(`❌ Falló commit ${i + 1}: ${proposal.title}`);\\n+        }\\n+      }\\n+      \\n+      this.log(`\\\\n📊 Resultados: ${successfulCommits}/${proposals.length} commits exitosos`);\\n+      \\n+      if (successfulCommits > 0) {\\n+        await this.pushCommits();\\n+      }\\n+      \\n+      this.log('\\\\n✅ Ejecución desde archivo completada');\\n+      \\n+    } catch (error) {\\n+      console.error('❌ Error leyendo archivo de propuesta:', error);\\n+      throw error;\\n+    }\\n+  }\\n+\\n+  /**\\n+   * Ejecuta el generador completo\\n+   */\\n+  async generate(): Promise<void> {\\n+    // Si se especifica un archivo de propuesta existente, usarlo directamente\\n+    if (this.proposalFile && existsSync(this.proposalFile)) {\\n+      return this.executeFromProposalFile(this.proposalFile);\\n+    }\\n+\\n+    this.log(`🚀 Iniciando generador de commits...${this.autoApprove ? ' (AUTO-APPROVE MODE)' : ''}\\\\n`);\\n+\\n+    const args = process.argv.slice(2);\\n+    const isExhaustive = args.includes('-exhaustive');\\n+\\n+    // Parsear parámetros de contexto mejorados\\n+    let extraContext = '';\\n+    let workType = '';\\n+    let contextDescription = '';\\n+    let affectedComponents = '';\\n+    let performanceImpact = '';\\n+    let breakingChanges = '';\\n+\\n+    const extraIndex = args.indexOf('--extra');\\n+    if (extraIndex > -1 && args[extraIndex + 1]) {\\n+        extraContext = args[extraIndex + 1];\\n+        this.log(`💬 Contexto extra proporcionado por el usuario.`);\\n+    } else if (extraIndex > -1) {\\n+        console.warn('⚠️ El parámetro --extra requiere un valor de texto después.');\\n+    }\\n+\\n+    const contextIndex = args.indexOf('--context');\\n+    if (contextIndex > -1 && args[contextIndex + 1]) {\\n+        contextDescription = args[contextIndex + 1];\\n+        this.log(`📋 Contexto del trabajo: ${contextDescription}`);\\n+    }\\n+\\n+    const workTypeIndex = args.indexOf('--work-type');\\n+    if (workTypeIndex > -1 && args[workTypeIndex + 1]) {\\n+        workType = args[workTypeIndex + 1];\\n+        this.log(`🏷️ Tipo de trabajo: ${workType}`);\\n+    }\\n+\\n+    const componentsIndex = args.indexOf('--affected-components');\\n+    if (componentsIndex > -1 && args[componentsIndex + 1]) {\\n+        affectedComponents = args[componentsIndex + 1];\\n+        this.log(`🎯 Componentes afectados: ${affectedComponents}`);\\n+    }\\n+\\n+    const perfIndex = args.indexOf('--performance-impact');\\n+    if (perfIndex > -1 && args[perfIndex + 1]) {\\n+        performanceImpact = args[perfIndex + 1];\\n+        this.log(`⚡ Impacto en rendimiento: ${performanceImpact}`);\\n+    }\\n+\\n+    const breakingIndex = args.indexOf('--breaking-changes');\\n+    if (breakingIndex > -1 && args[breakingIndex + 1]) {\\n+        breakingChanges = args[breakingIndex + 1];\\n+        this.log(`⚠️ Cambios que rompen compatibilidad: ${breakingChanges}`);\\n+    }\\n+\\n+    try {\\n+      // Verificar que estamos en un repositorio git\\n+      await this.gitCommand(['status']);\\n+\\n+      // Generar análisis completo\\n+      const analysis = await this.generateAnalysisContext();\\n+      \\n+      if (analysis.files.length === 0) {\\n+        this.log('✅ No hay cambios para procesar');\\n+        return;\\n+      }\\n+\\n+      const fileCount = analysis.files.length;\\n+      const exhaustiveMode = isExhaustive || fileCount > 50;\\n+\\n+      this.log(`📋 Encontrados ${fileCount} archivos modificados`);\\n+      this.log(`📊 Estadísticas: +${analysis.stats.total_additions} -${analysis.stats.total_deletions} líneas`);\\n+      if (exhaustiveMode) {\\n+        this.log('⚡️ Activado modo de análisis exhaustivo.');\\n+      }\\n+\\n+      // Preparar contexto completo mejorado\\n+      const enhancedContext = this.buildEnhancedContext(\\n+        extraContext,\\n+        contextDescription,\\n+        workType,\\n+        affectedComponents,\\n+        performanceImpact,\\n+        breakingChanges\\n+      );\\n+\\n+      // Analizar con Gemini\\n+      const commitProposal = await this.analyzeWithGemini(analysis, exhaustiveMode, enhancedContext);\\n+      \\n+      // Guardar propuesta\\n+      const proposalPath = this.saveCommitProposal(commitProposal);\\n+      \\n+      if (this.autoApprove) {\\n+        // Validar que es seguro ejecutar auto-approve\\n+        const isValid = await this.validateAutoApprove();\\n+        if (!isValid) {\\n+          console.error('❌ Auto-approve cancelado por validaciones de seguridad');\\n+          return;\\n+        }\\n+        \\n+        // Parsear y ejecutar commits\\n+        this.log('\\\\n🤖 Ejecutando commits automáticamente...');\\n+        const proposals = this.parseCommitProposals(commitProposal);\\n+        \\n+        if (proposals.length === 0) {\\n+          console.warn('⚠️ No se encontraron commits válidos para ejecutar');\\n+          console.log('📋 Revisa la propuesta manualmente:');\\n+          console.log(commitProposal);\\n+          return;\\n+        }\\n+        \\n+        this.log(`📦 Encontrados ${proposals.length} commits para ejecutar:`);\\n+        proposals.forEach((p, i) => {\\n+          this.log(`  ${i + 1}. ${p.title}`);\\n+        });\\n+        \\n+        let successfulCommits = 0;\\n+        \\n+        // Ejecutar cada commit secuencialmente\\n+        for (let i = 0; i < proposals.length; i++) {\\n+          const proposal = proposals[i];\\n+          const success = await this.executeCommit(proposal, analysis.files);\\n+          if (success) {\\n+            successfulCommits++;\\n+          } else {\\n+            console.error(`❌ Falló commit ${i + 1}: ${proposal.title}`);\\n+            // Continuar con los siguientes commits\\n+          }\\n+        }\\n+        \\n+        this.log(`\\\\n📊 Resultados: ${successfulCommits}/${proposals.length} commits exitosos`);\\n+        \\n+        if (successfulCommits > 0) {\\n+          await this.pushCommits();\\n+        }\\n+        \\n+        this.log('\\\\n✅ Auto-approve completado');\\n+        \\n+      } else {\\n+        // Modo normal - solo mostrar propuesta\\n+        this.log('\\\\n✅ Análisis completado');\\n+        console.log(`📄 Propuesta guardada en: ${proposalPath}`);\\n+        if (!this.quiet) {\\n+          console.log('\\\\n📋 Propuesta de commits:');\\n+          console.log('─'.repeat(60));\\n+          console.log(commitProposal);\\n+          console.log('─'.repeat(60));\\n+          console.log('\\\\n💡 Usa --auto-approve para ejecutar automáticamente los commits');\\n+          console.log('💡 O usa --proposal-file <ruta> para reutilizar esta propuesta');\\n+        }\\n+      }\\n+\\n+    } catch (error) {\\n+      console.error('❌ Error en el generador:', error);\\n+      process.exit(1);\\n+    }\\n+  }\\n+}\\n+\\n+// Ejecutar el generador si se llama directamente\\n+if (import.meta.main) {\\n+  const args = process.argv.slice(2);\\n+  \\n+  if (args.includes('--help') || args.includes('-h')) {\\n+    console.log(`\\n+🚀 Generador Automático de Commits con Gemini CLI\\n+\\n+Analiza cambios del repositorio y genera commits coherentes siguiendo los patrones del proyecto.\\n+\\n+Uso:\\n+  node project-utils/commit-generator.ts [opciones]\\n+\\n+Opciones principales:\\n+  --auto-approve                Ejecutar automáticamente los commits propuestos y hacer push\\n+  --proposal-file <ruta>        Usar propuesta existente (ej: project-utils/.temp/commit-proposal-*.md)\\n+  --quiet                       Ejecución silenciosa (solo errores y resultados finales)\\n+  --output-dir <directorio>     Directorio personalizado para archivos temporales\\n+\\n+Opciones de configuración:\\n+  --no-push                    Con --auto-approve, no hacer push (solo commits locales)\\n+  --extra <texto>              Contexto adicional para mejorar el análisis\\n+  --context <descripción>      Descripción del trabajo actual\\n+  --work-type <tipo>           Tipo: feature|fix|refactor|docs|test\\n+  --affected-components <lista> Componentes afectados (ej: \\\"core,styling,exports\\\")\\n+  --performance-impact <tipo>  Impacto: none|minor|major\\n+  --breaking-changes <si|no>   Si introduce cambios incompatibles\\n+  --exhaustive                 Análisis exhaustivo para proyectos complejos\\n+  --help, -h                   Mostrar esta ayuda\\n+\\n+Ejemplos:\\n+  node project-utils/commit-generator.ts                     # Generar propuesta básica\\n+  node project-utils/commit-generator.ts --auto-approve      # Ejecutar automáticamente\\n+  node project-utils/commit-generator.ts --quiet --auto-approve # Ejecución silenciosa\\n+  node project-utils/commit-generator.ts --proposal-file project-utils/.temp/commit-proposal-20240101-120000.md --auto-approve\\n+  node project-utils/commit-generator.ts --context \\\"logger functionality\\\" --work-type feature\\n+  node project-utils/commit-generator.ts --work-type fix --affected-components \\\"core,exports\\\"\\n+\\n+Modo Auto-Approve:\\n+- Valida estado del repositorio (rama master, sin conflictos)\\n+- Parsea commits propuestos por Gemini AI\\n+- Ejecuta cada commit secuencialmente con archivos apropiados\\n+- Hace push automático a origin/master (excepto con --no-push)\\n+- Manejo de errores y rollback en caso de fallos\\n+\\n+Seguridad:\\n+- Solo funciona en rama master\\n+- Validación de conflictos antes de ejecutar\\n+- Commits atómicos con manejo de errores individual\\n+- Logs completos de todas las operaciones\\n+`);\\n+    process.exit(0);\\n+  }\\n+  \\n+  const generator = new CommitGenerator();\\n+  await generator.generate();\\n+}\\n\\\\ No newline at end of file\",\n+      \"lines_added\": 858,\n+      \"lines_removed\": 0,\n+      \"is_binary\": true\n+    },\n+    {\n+      \"path\": \"project-utils/commit-ui.ts\",\n+      \"status\": \"added\",\n+      \"diff\": \"diff --git a/project-utils/commit-ui.ts b/project-utils/commit-ui.ts\\nnew file mode 100755\\nindex 0000000..bb63e24\\n--- /dev/null\\n+++ b/project-utils/commit-ui.ts\\n@@ -0,0 +1,246 @@\\n+#!/usr/bin/env node\\n+\\n+import { execSync } from \\\"child_process\\\"\\n+import { platform } from \\\"os\\\"\\n+\\n+interface CommitOptions {\\n+  context: string\\n+  workType: string\\n+  affectedComponents: string[]\\n+  scope?: string\\n+  breakingChange?: boolean\\n+  performanceImpact?: string\\n+}\\n+\\n+class CommitUI {\\n+  private platform = platform()\\n+\\n+  async collectCommitInfo(): Promise<CommitOptions> {\\n+    console.log(\\\"🚀 Interactive Commit Generator\\\")\\n+    console.log(\\\"================================\\\")\\n+\\n+    try {\\n+      if (this.platform === \\\"darwin\\\") {\\n+        return await this.macOSDialog()\\n+      } else if (this.platform === \\\"linux\\\") {\\n+        return await this.linuxDialog()\\n+      } else {\\n+        return await this.fallbackDialog()\\n+      }\\n+    } catch (error) {\\n+      console.log(\\\"⚠️ GUI not available, falling back to text input\\\")\\n+      return await this.fallbackDialog()\\n+    }\\n+  }\\n+\\n+  private async macOSDialog(): Promise<CommitOptions> {\\n+    // Create a unified form using AppleScript\\n+    const formScript = `\\n+      const app = Application.currentApplication()\\n+      app.includeStandardAdditions = true\\n+      \\n+      // First get the context text\\n+      const contextResult = app.displayDialog(\\\"📝 Commit Generator\\\\\\\\n\\\\\\\\nDescribe what you implemented/fixed:\\\", {\\n+        defaultAnswer: \\\"\\\",\\n+        withTitle: \\\"🚀 Interactive Commit\\\",\\n+        buttons: [\\\"Cancel\\\", \\\"Next →\\\"],\\n+        defaultButton: \\\"Next →\\\"\\n+      })\\n+      \\n+      const context = contextResult.textReturned\\n+      \\n+      // Then get work type\\n+      const workTypes = [\\\"feature\\\", \\\"fix\\\", \\\"refactor\\\", \\\"docs\\\", \\\"test\\\"]\\n+      const workTypeResult = app.chooseFromList(workTypes, {\\n+        withTitle: \\\"🚀 Interactive Commit - Work Type\\\",\\n+        withPrompt: \\\"Context: \\\" + context + \\\"\\\\\\\\n\\\\\\\\nSelect work type:\\\",\\n+        defaultItems: [\\\"feature\\\"]\\n+      })\\n+      \\n+      if (workTypeResult === false) {\\n+        throw new Error(\\\"Cancelled\\\")\\n+      }\\n+      \\n+      const workType = workTypeResult[0]\\n+      \\n+      // Then get components\\n+      const components = [\\\"core\\\", \\\"styling\\\", \\\"exports\\\", \\\"cli\\\", \\\"docs\\\", \\\"tests\\\", \\\"examples\\\"]\\n+      const componentsResult = app.chooseFromList(components, {\\n+        withTitle: \\\"🚀 Interactive Commit - Components\\\",\\n+        withPrompt: \\\"Context: \\\" + context + \\\"\\\\\\\\nType: \\\" + workType + \\\"\\\\\\\\n\\\\\\\\nSelect affected components:\\\",\\n+        multipleSelectionsAllowed: true,\\n+        defaultItems: [\\\"core\\\"]\\n+      })\\n+      \\n+      if (componentsResult === false) {\\n+        throw new Error(\\\"Cancelled\\\")\\n+      }\\n+      \\n+      const affectedComponents = componentsResult.join(\\\",\\\")\\n+      \\n+      // Finally get performance impact\\n+      const impacts = [\\\"none\\\", \\\"minor\\\", \\\"major\\\"]\\n+      const performanceResult = app.chooseFromList(impacts, {\\n+        withTitle: \\\"🚀 Interactive Commit - Performance\\\",\\n+        withPrompt: \\\"Context: \\\" + context + \\\"\\\\\\\\nType: \\\" + workType + \\\"\\\\\\\\nComponents: \\\" + affectedComponents + \\\"\\\\\\\\n\\\\\\\\nPerformance impact:\\\",\\n+        defaultItems: [\\\"none\\\"]\\n+      })\\n+      \\n+      const performanceImpact = performanceResult === false ? \\\"none\\\" : performanceResult[0]\\n+      \\n+      // Return all values as JSON\\n+      JSON.stringify({\\n+        context: context,\\n+        workType: workType,\\n+        affectedComponents: affectedComponents,\\n+        performanceImpact: performanceImpact\\n+      })\\n+    `\\n+    \\n+    const result = execSync(`osascript -l JavaScript -e '${formScript}'`, { encoding: 'utf-8' }).trim()\\n+    const parsed = JSON.parse(result)\\n+\\n+    return {\\n+      context: parsed.context,\\n+      workType: parsed.workType,\\n+      affectedComponents: parsed.affectedComponents.split(\\\",\\\"),\\n+      performanceImpact: parsed.performanceImpact\\n+    }\\n+  }\\n+\\n+  private async linuxDialog(): Promise<CommitOptions> {\\n+    // Check if zenity is available\\n+    try {\\n+      execSync(\\\"which zenity\\\", { stdio: 'ignore' })\\n+    } catch {\\n+      throw new Error(\\\"zenity not available\\\")\\n+    }\\n+\\n+    // Context Input first\\n+    const context = execSync(`zenity --entry --title=\\\"🚀 Interactive Commit\\\" --text=\\\"📝 Describe what you implemented/fixed:\\\" --width=400`, { encoding: 'utf-8' }).trim()\\n+\\n+    // Work Type Selection with context shown\\n+    const workType = execSync(`zenity --list --title=\\\"🚀 Interactive Commit - Work Type\\\" --text=\\\"Context: ${context}\\\\\\\\n\\\\\\\\nSelect work type:\\\" --radiolist --column=\\\"Select\\\" --column=\\\"Type\\\" --column=\\\"Description\\\" --width=450 --height=300 \\\\\\\\\\n+      TRUE \\\"feature\\\" \\\"New functionality\\\" \\\\\\\\\\n+      FALSE \\\"fix\\\" \\\"Bug fixes\\\" \\\\\\\\\\n+      FALSE \\\"refactor\\\" \\\"Code refactoring\\\" \\\\\\\\\\n+      FALSE \\\"docs\\\" \\\"Documentation\\\" \\\\\\\\\\n+      FALSE \\\"test\\\" \\\"Tests\\\"`, { encoding: 'utf-8' }).trim()\\n+\\n+    // Components Selection with previous values shown\\n+    const componentsResult = execSync(`zenity --list --title=\\\"🚀 Interactive Commit - Components\\\" --text=\\\"Context: ${context}\\\\\\\\nType: ${workType}\\\\\\\\n\\\\\\\\nSelect affected components:\\\" --checklist --column=\\\"Select\\\" --column=\\\"Component\\\" --width=450 --height=300 \\\\\\\\\\n+      TRUE \\\"core\\\" \\\\\\\\\\n+      FALSE \\\"styling\\\" \\\\\\\\\\n+      FALSE \\\"exports\\\" \\\\\\\\\\n+      FALSE \\\"cli\\\" \\\\\\\\\\n+      FALSE \\\"docs\\\" \\\\\\\\\\n+      FALSE \\\"tests\\\" \\\\\\\\\\n+      FALSE \\\"examples\\\"`, { encoding: 'utf-8' }).trim()\\n+    \\n+    const affectedComponents = componentsResult.split(\\\"|\\\").filter(Boolean)\\n+\\n+    // Performance Impact with summary\\n+    const performanceImpact = execSync(`zenity --list --title=\\\"🚀 Interactive Commit - Performance\\\" --text=\\\"Context: ${context}\\\\\\\\nType: ${workType}\\\\\\\\nComponents: ${affectedComponents.join(', ')}\\\\\\\\n\\\\\\\\nSelect performance impact:\\\" --radiolist --column=\\\"Select\\\" --column=\\\"Impact\\\" --width=450 --height=250 \\\\\\\\\\n+      TRUE \\\"none\\\" \\\\\\\\\\n+      FALSE \\\"minor\\\" \\\\\\\\\\n+      FALSE \\\"major\\\"`, { encoding: 'utf-8' }).trim()\\n+\\n+    return {\\n+      context,\\n+      workType,\\n+      affectedComponents,\\n+      performanceImpact\\n+    }\\n+  }\\n+\\n+  private async fallbackDialog(): Promise<CommitOptions> {\\n+    const readline = require('readline').createInterface({\\n+      input: process.stdin,\\n+      output: process.stdout\\n+    })\\n+\\n+    const question = (prompt: string): Promise<string> => {\\n+      return new Promise((resolve) => {\\n+        readline.question(prompt, resolve)\\n+      })\\n+    }\\n+\\n+    console.log(\\\"\\\\n📝 Text-based commit input\\\")\\n+    \\n+    const workType = await question(\\\"Work type (feature/fix/refactor/docs/test): \\\") || \\\"feature\\\"\\n+    const context = await question(\\\"Describe what you implemented/fixed: \\\")\\n+    const componentsInput = await question(\\\"Components changed (core,styling,exports,cli,docs,tests,examples): \\\") || \\\"core\\\"\\n+    const affectedComponents = componentsInput.split(\\\",\\\").map(c => c.trim())\\n+    const performanceImpact = await question(\\\"Performance impact (none/minor/major): \\\") || \\\"none\\\"\\n+\\n+    readline.close()\\n+\\n+    return {\\n+      context,\\n+      workType,\\n+      affectedComponents,\\n+      performanceImpact\\n+    }\\n+  }\\n+\\n+  async generateCommit(options: CommitOptions): Promise<void> {\\n+    const args = [\\n+      \\\"--context\\\", `\\\"${options.context}\\\"`,\\n+      \\\"--work-type\\\", options.workType,\\n+      \\\"--affected-components\\\", options.affectedComponents.join(\\\",\\\")\\n+    ]\\n+\\n+    if (options.performanceImpact && options.performanceImpact !== \\\"none\\\") {\\n+      args.push(\\\"--performance-impact\\\", options.performanceImpact)\\n+    }\\n+\\n+    console.log(\\\"\\\\n🔄 Generating commit...\\\")\\n+    console.log(`📋 Context: ${options.context}`)\\n+    console.log(`🏷️ Type: ${options.workType}`)\\n+    console.log(`📦 Components: ${options.affectedComponents.join(\\\", \\\")}`)\\n+    console.log(`⚡ Performance: ${options.performanceImpact}`)\\n+\\n+    const command = `node src/commit-generator.ts ${args.join(\\\" \\\")} --auto-approve`\\n+    console.log(`\\\\n🚀 Running: ${command}`)\\n+    \\n+    try {\\n+      execSync(command, { stdio: 'inherit' })\\n+      console.log(\\\"✅ Commits executed successfully!\\\")\\n+    } catch (error) {\\n+      console.error(\\\"❌ Error executing commits:\\\", error)\\n+      process.exit(1)\\n+    }\\n+  }\\n+}\\n+\\n+async function main() {\\n+  const ui = new CommitUI()\\n+  \\n+  // Check for quick mode\\n+  if (process.argv.includes(\\\"--quick\\\")) {\\n+    const quickOptions: CommitOptions = {\\n+      context: \\\"Quick commit via UI\\\",\\n+      workType: \\\"feature\\\",\\n+      affectedComponents: [\\\"core\\\"],\\n+      performanceImpact: \\\"none\\\"\\n+    }\\n+    await ui.generateCommit(quickOptions)\\n+    return\\n+  }\\n+  \\n+  try {\\n+    const options = await ui.collectCommitInfo()\\n+    await ui.generateCommit(options)\\n+  } catch (error) {\\n+    if (error instanceof Error && error.message === \\\"Cancelled\\\") {\\n+      console.log(\\\"❌ Commit cancelled by user\\\")\\n+      process.exit(0)\\n+    }\\n+    console.error(\\\"❌ Error:\\\", error)\\n+    process.exit(1)\\n+  }\\n+}\\n+\\n+if (import.meta.main) {\\n+  main()\\n+}\\n\\\\ No newline at end of file\",\n+      \"lines_added\": 246,\n+      \"lines_removed\": 0,\n+      \"is_binary\": false\n+    },\n+    {\n+      \"path\": \"project-utils/git-utils.ts\",\n+      \"status\": \"added\",\n+      \"diff\": \"diff --git a/project-utils/git-utils.ts b/project-utils/git-utils.ts\\nnew file mode 100644\\nindex 0000000..d1b860f\\n--- /dev/null\\n+++ b/project-utils/git-utils.ts\\n@@ -0,0 +1,199 @@\\n+/**\\n+ * Utilidades para manejo de Git\\n+ * Funciones auxiliares para el generador de commits\\n+ */\\n+\\n+export interface GitFileStatus {\\n+  path: string;\\n+  staged: boolean;\\n+  unstaged: boolean;\\n+  untracked: boolean;\\n+  deleted: boolean;\\n+  renamed?: string;\\n+}\\n+\\n+export interface CommitInfo {\\n+  hash: string;\\n+  message: string;\\n+  author: string;\\n+  date: string;\\n+}\\n+\\n+/**\\n+ * Parsea la salida de git status --porcelain\\n+ */\\n+export function parseGitStatus(statusOutput: string): GitFileStatus[] {\\n+  const files: GitFileStatus[] = [];\\n+  \\n+  for (const line of statusOutput.split('\\\\n').filter(l => l.trim())) {\\n+    const staged = line[0];\\n+    const unstaged = line[1];\\n+    const filePath = line.substring(3);\\n+\\n+    files.push({\\n+      path: filePath,\\n+      staged: staged !== ' ' && staged !== '?',\\n+      unstaged: unstaged !== ' ',\\n+      untracked: staged === '?' && unstaged === '?',\\n+      deleted: staged === 'D' || unstaged === 'D',\\n+      renamed: staged === 'R' ? filePath.split(' -> ')[1] : undefined,\\n+    });\\n+  }\\n+\\n+  return files;\\n+}\\n+\\n+/**\\n+ * Determina el área funcional de un archivo basado en su ruta\\n+ */\\n+export function getFileArea(filePath: string): string {\\n+  const areas = [\\n+    { pattern: /^src\\\\/components\\\\/|^src\\\\/layouts\\\\//, area: 'ui' },\\n+    { pattern: /^src-tauri\\\\//, area: 'backend' },\\n+    { pattern: /^src\\\\/models\\\\/|types|interfaces/, area: 'types' },\\n+    { pattern: /^src\\\\/stores\\\\/|state/, area: 'state' },\\n+    { pattern: /^src\\\\/pages\\\\/|routing|navigation/, area: 'navigation' },\\n+    { pattern: /^src\\\\/styles\\\\/|\\\\.css$|theme/, area: 'theme' },\\n+    { pattern: /config|\\\\.json$|\\\\.toml$|package\\\\.json/, area: 'config' },\\n+    { pattern: /^project-utils\\\\/|tools|scripts/, area: 'tools' },\\n+    { pattern: /database|migration|sql/, area: 'database' },\\n+    { pattern: /test|spec|\\\\.test\\\\.|\\\\.spec\\\\./, area: 'testing' },\\n+    { pattern: /doc|readme|\\\\.md$/, area: 'docs' },\\n+  ];\\n+\\n+  for (const { pattern, area } of areas) {\\n+    if (pattern.test(filePath.toLowerCase())) {\\n+      return area;\\n+    }\\n+  }\\n+\\n+  return 'misc';\\n+}\\n+\\n+/**\\n+ * Determina si los archivos están relacionados funcionalmente\\n+ */\\n+export function areFilesRelated(files: string[]): boolean {\\n+  if (files.length <= 1) return true;\\n+  \\n+  const areas = files.map(getFileArea);\\n+  const uniqueAreas = [...new Set(areas)];\\n+  \\n+  // Si todos están en la misma área, están relacionados\\n+  if (uniqueAreas.length === 1) return true;\\n+  \\n+  // Áreas que suelen ir juntas\\n+  const relatedAreas = [\\n+    ['ui', 'theme', 'navigation'],\\n+    ['backend', 'database', 'types'],\\n+    ['config', 'tools', 'docs'],\\n+    ['types', 'state'],\\n+  ];\\n+  \\n+  for (const group of relatedAreas) {\\n+    if (uniqueAreas.every(area => group.includes(area))) {\\n+      return true;\\n+    }\\n+  }\\n+  \\n+  return false;\\n+}\\n+\\n+/**\\n+ * Sugiere el tipo de commit basado en los cambios\\n+ */\\n+export function suggestCommitType(files: GitFileStatus[]): 'feat' | 'fix' | 'refactor' | 'feat-phase' {\\n+  const hasNewFiles = files.some(f => f.untracked);\\n+  const hasDeletedFiles = files.some(f => f.deleted);\\n+  const modifiedFiles = files.filter(f => f.staged || f.unstaged);\\n+  \\n+  // Si hay muchos archivos nuevos, probablemente es una feature\\n+  if (hasNewFiles && files.length > 3) {\\n+    return 'feat-phase';\\n+  }\\n+  \\n+  // Si hay archivos nuevos pero pocos, es feature completa\\n+  if (hasNewFiles) {\\n+    return 'feat';\\n+  }\\n+  \\n+  // Si solo se modificaron archivos existentes, probablemente es fix o refactor\\n+  if (modifiedFiles.length > 0 && !hasNewFiles) {\\n+    // Si los cambios son grandes, es refactor\\n+    if (modifiedFiles.length > 5) {\\n+      return 'refactor';\\n+    }\\n+    // Si son pocos cambios, probablemente es fix\\n+    return 'fix';\\n+  }\\n+  \\n+  return 'feat';\\n+}\\n+\\n+/**\\n+ * Extrae información relevante del diff de un archivo\\n+ */\\n+export function analyzeDiff(diff: string): {\\n+  addedLines: number;\\n+  removedLines: number;\\n+  hasNewFunctions: boolean;\\n+  hasNewTypes: boolean;\\n+  hasNewImports: boolean;\\n+  hasFixes: boolean;\\n+} {\\n+  const lines = diff.split('\\\\n');\\n+  const addedLines = lines.filter(l => l.startsWith('+')).length;\\n+  const removedLines = lines.filter(l => l.startsWith('-')).length;\\n+  \\n+  const addedCode = lines.filter(l => l.startsWith('+')).join('\\\\n');\\n+  const removedCode = lines.filter(l => l.startsWith('-')).join('\\\\n');\\n+  \\n+  return {\\n+    addedLines,\\n+    removedLines,\\n+    hasNewFunctions: /function\\\\s+\\\\w+|const\\\\s+\\\\w+\\\\s*=|async\\\\s+function/.test(addedCode),\\n+    hasNewTypes: /interface\\\\s+\\\\w+|type\\\\s+\\\\w+|enum\\\\s+\\\\w+/.test(addedCode),\\n+    hasNewImports: /import\\\\s+.*from/.test(addedCode),\\n+    hasFixes: /fix|error|bug|issue|problem/i.test(addedCode) || removedCode.includes('TODO') || removedCode.includes('FIXME'),\\n+  };\\n+}\\n+\\n+/**\\n+ * Genera un resumen técnico basado en los archivos modificados\\n+ */\\n+export function generateTechnicalSummary(files: GitFileStatus[], diffs: Record<string, string>): string {\\n+  const summary: string[] = [];\\n+  \\n+  for (const file of files) {\\n+    const area = getFileArea(file.path);\\n+    const diff = diffs[file.path];\\n+    \\n+    if (!diff) continue;\\n+    \\n+    const analysis = analyzeDiff(diff);\\n+    const changes: string[] = [];\\n+    \\n+    if (file.untracked) {\\n+      changes.push(`Creado ${file.path}`);\\n+    } else if (file.deleted) {\\n+      changes.push(`Eliminado ${file.path}`);\\n+    } else {\\n+      if (analysis.hasNewFunctions) changes.push('nuevas funciones');\\n+      if (analysis.hasNewTypes) changes.push('nuevos tipos');\\n+      if (analysis.hasNewImports) changes.push('nuevas dependencias');\\n+      if (analysis.hasFixes) changes.push('correcciones');\\n+      \\n+      if (changes.length > 0) {\\n+        changes.unshift(`Modificado ${file.path} con`);\\n+      } else {\\n+        changes.push(`Actualizado ${file.path}`);\\n+      }\\n+    }\\n+    \\n+    if (changes.length > 0) {\\n+      summary.push(`- ${changes.join(' ')}`);\\n+    }\\n+  }\\n+  \\n+  return summary.join('\\\\n');\\n+}\\n\\\\ No newline at end of file\",\n+      \"lines_added\": 199,\n+      \"lines_removed\": 0,\n+      \"is_binary\": false\n+    },\n+    {\n+      \"path\": \"project-utils/github-release-manager.ts\",\n+      \"status\": \"added\",\n+      \"diff\": \"diff --git a/project-utils/github-release-manager.ts b/project-utils/github-release-manager.ts\\nnew file mode 100644\\nindex 0000000..83dac00\\n--- /dev/null\\n+++ b/project-utils/github-release-manager.ts\\n@@ -0,0 +1,458 @@\\n+#!/usr/bin/env node\\n+\\n+/**\\n+ * GitHub Release Manager para Better Logger\\n+ * Crea releases automáticamente en GitHub con los archivos de distribución\\n+ */\\n+\\n+import { readFileSync, existsSync, readdirSync, statSync } from 'fs';\\n+import { join, basename } from 'path';\\n+\\n+interface ReleaseInfo {\\n+  version: string;\\n+  prefix?: string;\\n+  baseVersion: string;\\n+  path: string;\\n+  files: string[];\\n+  readme: string;\\n+  isPrerelease: boolean;\\n+}\\n+\\n+interface ChangelogEntry {\\n+  type: 'feature' | 'fix' | 'improvement' | 'breaking';\\n+  title: string;\\n+  description: string;\\n+}\\n+\\n+interface VersionData {\\n+  version: string;\\n+  date: string;\\n+  type: 'initial' | 'major' | 'minor' | 'patch';\\n+  title: string;\\n+  changes: ChangelogEntry[];\\n+  technical_notes: string;\\n+  breaking_changes: string[];\\n+}\\n+\\n+class GitHubReleaseManager {\\n+  private projectRoot: string;\\n+  private releasesDir: string;\\n+  private changelogPath: string;\\n+\\n+  constructor() {\\n+    this.projectRoot = process.cwd();\\n+    this.releasesDir = join(this.projectRoot, 'dist');\\n+    this.changelogPath = join(this.projectRoot, 'CHANGELOG.json');\\n+  }\\n+\\n+  /**\\n+   * Ejecuta comando gh CLI\\n+   */\\n+  private async ghCommand(args: string[]): Promise<string> {\\n+    const { spawn } = await import('child_process');\\n+    \\n+    return new Promise((resolve, reject) => {\\n+      const proc = spawn('gh', args, {\\n+        cwd: this.projectRoot,\\n+        stdio: ['pipe', 'pipe', 'pipe']\\n+      });\\n+\\n+      let stdout = '';\\n+      let stderr = '';\\n+\\n+      proc.stdout?.on('data', (data) => {\\n+        stdout += data.toString();\\n+      });\\n+\\n+      proc.stderr?.on('data', (data) => {\\n+        stderr += data.toString();\\n+      });\\n+\\n+      proc.on('exit', (code) => {\\n+        if (code !== 0) {\\n+          reject(new Error(`GitHub CLI error: ${stderr || 'gh command failed'}`));\\n+        } else {\\n+          resolve(stdout.trim());\\n+        }\\n+      });\\n+\\n+      proc.on('error', (error) => {\\n+        reject(error);\\n+      });\\n+    });\\n+  }\\n+\\n+  /**\\n+   * Verifica si gh CLI está instalado y autenticado\\n+   */\\n+  private async checkGitHubCLI(): Promise<void> {\\n+    try {\\n+      await this.ghCommand(['auth', 'status']);\\n+      console.log('✅ GitHub CLI autenticado correctamente');\\n+    } catch (error) {\\n+      console.error('❌ GitHub CLI no está instalado o no estás autenticado');\\n+      console.log('💡 Instala gh CLI: https://cli.github.com/');\\n+      console.log('💡 Autentica con: gh auth login');\\n+      throw error;\\n+    }\\n+  }\\n+\\n+  /**\\n+   * Obtiene todas las releases existentes en GitHub\\n+   */\\n+  private async getExistingReleases(): Promise<Set<string>> {\\n+    try {\\n+      const output = await this.ghCommand(['release', 'list', '--json', 'tagName']);\\n+      const releases = JSON.parse(output);\\n+      return new Set(releases.map((r: any) => r.tagName));\\n+    } catch (error) {\\n+      console.warn('⚠️ No se pudieron obtener releases existentes:', error);\\n+      return new Set();\\n+    }\\n+  }\\n+\\n+  /**\\n+   * Obtiene información de la release actual desde package.json y dist/\\n+   */\\n+  private getCurrentRelease(): ReleaseInfo | null {\\n+    try {\\n+      // Leer versión de package.json\\n+      const packagePath = join(this.projectRoot, 'package.json');\\n+      if (!existsSync(packagePath)) {\\n+        console.warn('⚠️ package.json no existe');\\n+        return null;\\n+      }\\n+      \\n+      const packageData = JSON.parse(readFileSync(packagePath, 'utf-8'));\\n+      const version = packageData.version;\\n+      \\n+      if (!existsSync(this.releasesDir)) {\\n+        console.warn('⚠️ Directorio dist/ no existe');\\n+        return null;\\n+      }\\n+\\n+      // Obtener archivos de la distribución\\n+      const files = readdirSync(this.releasesDir)\\n+        .map(file => join(this.releasesDir, file));\\n+\\n+      // Determinar si es prerelease\\n+      const isPrerelease = version.includes('-alpha') || version.includes('-beta') || version.includes('-rc') || version.includes('-pre');\\n+      \\n+      // Extraer prefix y base version\\n+      const match = version.match(/^(.*?)(-alpha|-beta|-rc|-pre)?(.*)$/);\\n+      const baseVersion = match ? match[1] + (match[3] || '') : version;\\n+      const prefix = match && match[2] ? match[2].substring(1) : undefined;\\n+      return {\\n+        version,\\n+        prefix,\\n+        baseVersion,\\n+        path: this.releasesDir,\\n+        files,\\n+        readme: this.generateREADME(version),\\n+        isPrerelease\\n+      };\\n+    } catch (error) {\\n+      console.error('❌ Error obteniendo release actual:', error);\\n+      return null;\\n+    }\\n+  }\\n+\\n+  /**\\n+   * Genera README básico para la release\\n+   */\\n+  private generateREADME(version: string): string {\\n+    const date = new Date().toISOString().split('T')[0];\\n+    return `# Better Logger v${version}\\n+    \\n+## Instalación\\n+\\n+\\\\`\\\\`\\\\`bash\\n+npm install @mks2508/better-logger@${version}\\n+\\\\`\\\\`\\\\`\\n+\\n+## Uso\\n+\\n+\\\\`\\\\`\\\\`javascript\\n+import { Logger } from '@mks2508/better-logger';\\n+\\n+const logger = new Logger();\\n+logger.info('¡Hola mundo!');\\n+\\\\`\\\\`\\\\`\\n+\\n+---\\n+\\n+*Release generada automáticamente el ${date}*`;\\n+  }\\n+\\n+  /**\\n+   * Carga información del changelog para una versión específica\\n+   */\\n+  private getChangelogForVersion(version: string): VersionData | null {\\n+    try {\\n+      const changelogData = JSON.parse(readFileSync(this.changelogPath, 'utf-8'));\\n+      return changelogData.versions.find((v: VersionData) => v.version === version) || null;\\n+    } catch (error) {\\n+      console.warn(`⚠️ No se pudo cargar changelog para ${version}`);\\n+      return null;\\n+    }\\n+  }\\n+\\n+  /**\\n+   * Genera las release notes basadas en changelog y README\\n+   */\\n+  private generateReleaseNotes(release: ReleaseInfo): string {\\n+    const changelog = this.getChangelogForVersion(release.version);\\n+    \\n+    let notes = `# Better Logger - ${release.version}\\\\n\\\\n`;\\n+    \\n+    if (changelog) {\\n+      notes += `## 📋 Resumen\\\\n${changelog.title}\\\\n\\\\n`;\\n+      \\n+      // Agrupar cambios por tipo\\n+      const features = changelog.changes.filter(c => c.type === 'feature');\\n+      const fixes = changelog.changes.filter(c => c.type === 'fix');\\n+      const improvements = changelog.changes.filter(c => c.type === 'improvement');\\n+      const breaking = changelog.changes.filter(c => c.type === 'breaking');\\n+      \\n+      if (features.length > 0) {\\n+        notes += `## ✨ Nuevas Funcionalidades\\\\n`;\\n+        features.forEach(f => notes += `- ${f.title}\\\\n`);\\n+        notes += '\\\\n';\\n+      }\\n+      \\n+      if (fixes.length > 0) {\\n+        notes += `## 🐛 Correcciones\\\\n`;\\n+        fixes.forEach(f => notes += `- ${f.title}\\\\n`);\\n+        notes += '\\\\n';\\n+      }\\n+      \\n+      if (improvements.length > 0) {\\n+        notes += `## 🚀 Mejoras\\\\n`;\\n+        improvements.forEach(i => notes += `- ${i.title}\\\\n`);\\n+        notes += '\\\\n';\\n+      }\\n+      \\n+      if (breaking.length > 0) {\\n+        notes += `## 💥 Cambios Importantes\\\\n`;\\n+        breaking.forEach(b => notes += `- ${b.title}\\\\n`);\\n+        notes += '\\\\n';\\n+      }\\n+    }\\n+    \\n+    // Agregar información de instalación del README\\n+    const readmeLines = release.readme.split('\\\\n');\\n+    const installIndex = readmeLines.findIndex(line => line.includes('## Instalación'));\\n+    const compatIndex = readmeLines.findIndex(line => line.includes('## Compatibilidad'));\\n+    \\n+    if (installIndex !== -1) {\\n+      notes += `## 📦 Instalación\\\\n\\\\n`;\\n+      const endIndex = compatIndex !== -1 ? compatIndex : readmeLines.length;\\n+      const installSection = readmeLines.slice(installIndex + 1, endIndex);\\n+      notes += installSection.join('\\\\n') + '\\\\n\\\\n';\\n+    }\\n+    \\n+    // Información de archivos\\n+    notes += `## 📁 Archivos de la Release\\\\n\\\\n`;\\n+    release.files.forEach(file => {\\n+      const fileName = basename(file);\\n+      const stats = statSync(file);\\n+      const sizeMB = (stats.size / 1024 / 1024).toFixed(1);\\n+      notes += `- **${fileName}** (${sizeMB} MB)\\\\n`;\\n+    });\\n+    \\n+    notes += `\\\\n---\\\\n\\\\n`;\\n+    notes += `🏗️ **Plataforma objetivo**: Universal (Browser/Node.js)\\\\n`;\\n+    notes += `🗓️ **Fecha**: ${changelog?.date || new Date().toISOString().split('T')[0]}\\\\n`;\\n+    \\n+    if (release.isPrerelease) {\\n+      notes += `\\\\n⚠️ **Nota**: Esta es una versión ${release.prefix} en desarrollo. No recomendada para producción.\\\\n`;\\n+    }\\n+\\n+    return notes;\\n+  }\\n+\\n+  /**\\n+   * Crea una release en GitHub\\n+   */\\n+  private async createGitHubRelease(release: ReleaseInfo): Promise<void> {\\n+    console.log(`🚀 Creando release ${release.version}...`);\\n+    \\n+    const tagName = `v${release.version}`;\\n+    const title = `Better Logger v${release.version}`;\\n+    const notes = this.generateReleaseNotes(release);\\n+    \\n+    // Crear archivo temporal con las release notes\\n+    const notesFile = join(this.projectRoot, `.release-notes-${release.version}.md`);\\n+    const { writeFileSync } = await import('fs');\\n+    writeFileSync(notesFile, notes, 'utf-8');\\n+    \\n+    try {\\n+      // Crear la release\\n+      const args = [\\n+        'release', 'create', tagName,\\n+        '--title', title,\\n+        '--notes-file', notesFile,\\n+        ...release.files\\n+      ];\\n+      \\n+      if (release.isPrerelease) {\\n+        args.push('--prerelease');\\n+      }\\n+      \\n+      await this.ghCommand(args);\\n+      console.log(`✅ Release ${release.version} creada exitosamente`);\\n+      \\n+      // Limpiar archivo temporal\\n+      const { unlinkSync } = await import('fs');\\n+      try { unlinkSync(notesFile); } catch {}\\n+      \\n+    } catch (error) {\\n+      console.error(`❌ Error creando release ${release.version}:`, error);\\n+      throw error;\\n+    }\\n+  }\\n+\\n+  /**\\n+   * Procesa todas las releases\\n+   */\\n+  async processReleases(force = false): Promise<void> {\\n+    console.log('🔍 GitHub Release Manager iniciado\\\\n');\\n+    \\n+    try {\\n+      await this.checkGitHubCLI();\\n+      \\n+      const currentRelease = this.getCurrentRelease();\\n+      \\n+      if (!currentRelease) {\\n+        console.log('❌ No se pudo obtener información de la release actual');\\n+        return;\\n+      }\\n+      \\n+      console.log(`📦 Release actual: ${currentRelease.version}`);\\n+      \\n+      const existingReleases = await this.getExistingReleases();\\n+      console.log(`📋 ${existingReleases.size} releases ya existen en GitHub`);\\n+      \\n+      const tagName = `v${currentRelease.version}`;\\n+      \\n+      if (existingReleases.has(tagName) && !force) {\\n+        console.log(`⏭️ Release ${currentRelease.version} ya existe, omitiendo`);\\n+        console.log('💡 Usa --force para forzar recreación');\\n+        return;\\n+      }\\n+      \\n+      if (force && existingReleases.has(tagName)) {\\n+        console.log(`🔄 Eliminando release existente ${currentRelease.version}...`);\\n+        try {\\n+          await this.ghCommand(['release', 'delete', tagName, '--yes']);\\n+        } catch (error) {\\n+          console.warn(`⚠️ No se pudo eliminar release ${tagName}:`, error);\\n+        }\\n+      }\\n+      \\n+      await this.createGitHubRelease(currentRelease);\\n+      console.log(`\\\\n✅ Procesamiento completado: Release ${currentRelease.version} creada exitosamente`);\\n+      \\n+    } catch (error) {\\n+      console.error('❌ Error en el procesamiento:', error);\\n+      throw error;\\n+    }\\n+  }\\n+\\n+  /**\\n+   * Monitorea el directorio releases para cambios\\n+   */\\n+  async watchForNewReleases(): Promise<void> {\\n+    console.log('👀 Monitoreando directorio releases para nuevas versiones...');\\n+    // Implementación futura con file watchers\\n+    console.log('💡 Funcionalidad de monitoreo en desarrollo');\\n+  }\\n+}\\n+\\n+// Función helper para obtener releases existentes (fix de scope)\\n+async function getExistingReleases(): Promise<Set<string>> {\\n+  try {\\n+    const { spawn } = await import('child_process');\\n+    \\n+    return new Promise((resolve, reject) => {\\n+      const proc = spawn('gh', ['release', 'list', '--json', 'tagName'], {\\n+        stdio: ['pipe', 'pipe', 'pipe']\\n+      });\\n+\\n+      let stdout = '';\\n+      let stderr = '';\\n+\\n+      proc.stdout?.on('data', (data) => {\\n+        stdout += data.toString();\\n+      });\\n+\\n+      proc.stderr?.on('data', (data) => {\\n+        stderr += data.toString();\\n+      });\\n+\\n+      proc.on('exit', (code) => {\\n+        if (code !== 0) {\\n+          resolve(new Set());\\n+        } else {\\n+          try {\\n+            const releases = JSON.parse(stdout);\\n+            resolve(new Set(releases.map((r: any) => r.tagName)));\\n+          } catch {\\n+            resolve(new Set());\\n+          }\\n+        }\\n+      });\\n+\\n+      proc.on('error', () => {\\n+        resolve(new Set());\\n+      });\\n+    });\\n+  } catch (error) {\\n+    return new Set();\\n+  }\\n+}\\n+\\n+// Ejecutar script\\n+if (import.meta.main) {\\n+  const manager = new GitHubReleaseManager();\\n+  \\n+  const args = process.argv.slice(2);\\n+  const force = args.includes('--force') || args.includes('-f');\\n+  const watch = args.includes('--watch') || args.includes('-w');\\n+  const autoApprove = args.includes('--auto-approve');\\n+  const quiet = args.includes('--quiet');\\n+  \\n+  if (args.includes('--help') || args.includes('-h')) {\\n+    console.log(`\\n+🚀 GitHub Release Manager para Better Logger\\n+\\n+Uso:\\n+  node project-utils/github-release-manager.ts [opciones]\\n+\\n+Opciones:\\n+  --auto-approve  Crear release automáticamente sin confirmación\\n+  --force, -f     Recrear releases existentes\\n+  --quiet         Ejecución silenciosa (solo errores y resultados)\\n+  --watch, -w     Monitorear cambios (en desarrollo)\\n+  --help, -h      Mostrar esta ayuda\\n+\\n+Ejemplos:\\n+  node project-utils/github-release-manager.ts                    # Release interactiva\\n+  node project-utils/github-release-manager.ts --auto-approve     # Release automática\\n+  node project-utils/github-release-manager.ts --force --auto-approve  # Forzar recreación\\n+  node project-utils/github-release-manager.ts --quiet --auto-approve   # Para workflows\\n+`);\\n+    process.exit(0);\\n+  }\\n+  \\n+  try {\\n+    if (watch) {\\n+      await manager.watchForNewReleases();\\n+    } else {\\n+      await manager.processReleases(force);\\n+    }\\n+  } catch (error) {\\n+    console.error('❌ Error:', error);\\n+    process.exit(1);\\n+  }\\n+}\\n\\\\ No newline at end of file\",\n+      \"lines_added\": 458,\n+      \"lines_removed\": 0,\n+      \"is_binary\": false\n+    },\n+    {\n+      \"path\": \"project-utils/prompt-templates.js\",\n+      \"status\": \"added\",\n+      \"diff\": \"diff --git a/project-utils/prompt-templates.js b/project-utils/prompt-templates.js\\nnew file mode 100644\\nindex 0000000..504b6d7\\n--- /dev/null\\n+++ b/project-utils/prompt-templates.js\\n@@ -0,0 +1,345 @@\\n+/**\\n+ * Plantillas de prompts estandarizadas para Gemini CLI\\n+ * @description Asegura respuestas consistentes y parseables en todos los scripts\\n+ * @author TPV EL Haido\\n+ */\\n+/**\\n+ * Configuración base del proyecto OpenTUI\\n+ */\\n+export const TPV_PROJECT_CONFIG = {\\n+    name: 'OpenTUI',\\n+    description: 'Modern Terminal User Interface Framework',\\n+    version: '0.1.0',\\n+    techStack: ['TypeScript', 'Node.js', 'Terminal UI', 'CLI'],\\n+    targetPlatform: 'Cross-platform (macOS, Linux, Windows)',\\n+};\\n+/**\\n+ * Prefijo estándar para todos los prompts de Gemini\\n+ */\\n+const STANDARD_PROMPT_PREFIX = `# Sistema de Análisis Inteligente - OpenTUI\\n+\\n+Eres un asistente especializado en análisis de código y automatización para el proyecto OpenTUI. Tu función es proporcionar respuestas estructuradas, precisas y consistentes que puedan ser parseadas automáticamente.\\n+\\n+## REGLAS CRÍTICAS DE FORMATO\\n+\\n+1. **FORMATO DE RESPUESTA OBLIGATORIO**: Todas tus respuestas deben seguir exactamente el formato especificado más abajo.\\n+2. **CONSISTENCIA**: Mantén la misma estructura sin importar la complejidad del análisis.\\n+3. **PARSEABLE**: El formato debe ser fácil de procesar automáticamente con expresiones regulares.\\n+4. **BLOQUES MARKDOWN**: Usa \\\\`\\\\`\\\\`markdown para bloques de código cuando se especifique.\\n+5. **SECCIONES TÉCNICAS**: Siempre incluye las secciones <technical> y <changelog> cuando sea aplicable.\\n+\\n+## Contexto del Proyecto\\n+**Nombre**: ${TPV_PROJECT_CONFIG.name}\\n+**Descripción**: ${TPV_PROJECT_CONFIG.description}\\n+**Versión Actual**: ${TPV_PROJECT_CONFIG.version}\\n+**Stack Tecnológico**: ${TPV_PROJECT_CONFIG.techStack.join(', ')}\\n+**Plataforma Objetivo**: ${TPV_PROJECT_CONFIG.targetPlatform}\\n+\\n+---\\n+`;\\n+/**\\n+ * Sufijo estándar con instrucciones de formato\\n+ */\\n+const STANDARD_PROMPT_SUFFIX = `\\n+\\n+---\\n+\\n+## INSTRUCCIONES FINALES\\n+\\n+1. **Lee cuidadosamente** toda la información proporcionada\\n+2. **Analiza el contexto** y los datos específicos\\n+3. **Genera una respuesta** siguiendo EXACTAMENTE el formato especificado\\n+4. **Mantén consistencia** en la estructura y sintaxis\\n+5. **No desvíes** del formato requerido bajo ninguna circunstancia\\n+\\n+**IMPORTANTE**: La respuesta debe ser parseada automáticamente. Cualquier desviación del formato especificado causará errores en el sistema.`;\\n+/**\\n+ * Genera prompt para análisis de commits\\n+ */\\n+export function createCommitPrompt(config) {\\n+    const { data, specificContext } = config;\\n+    return `${STANDARD_PROMPT_PREFIX}\\n+\\n+# ANÁLISIS DE COMMITS\\n+\\n+## Datos del Análisis\\n+${JSON.stringify(data, null, 2)}\\n+\\n+## Contexto Adicional\\n+${specificContext || 'Ninguno proporcionado'}\\n+\\n+---\\n+\\n+## FORMATO DE RESPUESTA REQUERIDO\\n+\\n+Tu respuesta debe seguir EXACTAMENTE esta estructura:\\n+\\n+### **ANÁLISIS PRINCIPAL**\\n+\\n+[Descripción general de los cambios detectados]\\n+\\n+---\\n+\\n+### **Propuesta de Commit #1**\\n+\\n+\\\\`\\\\`\\\\`markdown\\n+[prefijo](área - descripción breve)\\n+\\n+[Descripción completa en castellano de QUÉ se logró y POR QUÉ]\\n+\\n+<technical>\\n+[Detalles técnicos específicos: archivos modificados, funciones añadidas, refactorizaciones, etc.]\\n+</technical>\\n+\\n+<changelog>\\n+## [Tipo] [Emoji]\\n+[Entrada para changelog de la app, optimizada para mostrar al usuario]\\n+</changelog>\\n+\\\\`\\\\`\\\\`\\n+\\n+### **Propuesta de Commit #2** (solo si es necesario)\\n+\\n+[Repetir formato anterior]\\n+\\n+---\\n+\\n+**DECISIÓN**: [Explicación breve de por qué uno o múltiples commits]\\n+\\n+${STANDARD_PROMPT_SUFFIX}`;\\n+}\\n+/**\\n+ * Genera prompt para asistente de workflow\\n+ */\\n+export function createWorkflowPrompt(config) {\\n+    const { data, specificContext } = config;\\n+    return `${STANDARD_PROMPT_PREFIX}\\n+\\n+# ASISTENTE DE WORKFLOW\\n+\\n+## Solicitud del Usuario\\n+\\\"${specificContext}\\\"\\n+\\n+## Contexto del Proyecto Actual\\n+${JSON.stringify(data, null, 2)}\\n+\\n+---\\n+\\n+## FORMATO DE RESPUESTA REQUERIDO\\n+\\n+\\\\`\\\\`\\\\`markdown\\n+🎯 **ANÁLISIS**: [Descripción del tipo de trabajo detectado]\\n+📊 **IMPACTO**: [Áreas afectadas y alcance del cambio]\\n+🚀 **RECOMENDACIÓN**: [Tipo de versión y estrategia recomendada]\\n+\\n+## 🖥️ COMANDOS PARA macOS\\n+\\\\`\\\\`\\\\`bash\\n+# [Descripción del primer comando]\\n+[comando exacto con parámetros]\\n+\\n+# [Descripción del segundo comando]  \\n+[segundo comando exacto]\\n+\\\\`\\\\`\\\\`\\n+\\n+## 🐧 COMANDOS PARA LINUX ARM (después de macOS)\\n+\\\\`\\\\`\\\\`bash\\n+# SSH y preparación\\n+ssh user@raspberry-pi\\n+git pull origin master && bun install\\n+\\n+# [Descripción del build ARM]\\n+[comandos específicos de ARM]\\n+\\\\`\\\\`\\\\`\\n+\\n+## ✅ VERIFICACIONES AUTOMÁTICAS\\n+- [Lista de verificaciones que se ejecutarán]\\n+\\\\`\\\\`\\\\`\\n+\\n+${STANDARD_PROMPT_SUFFIX}`;\\n+}\\n+/**\\n+ * Genera prompt para releases automáticas\\n+ */\\n+export function createReleasePrompt(config) {\\n+    const { data, specificContext } = config;\\n+    return `${STANDARD_PROMPT_PREFIX}\\n+\\n+# ANÁLISIS DE RELEASE\\n+\\n+## Información de la Release\\n+${JSON.stringify(data, null, 2)}\\n+\\n+## Contexto Específico\\n+${specificContext || 'Release automática'}\\n+\\n+---\\n+\\n+## FORMATO DE RESPUESTA REQUERIDO\\n+\\n+\\\\`\\\\`\\\\`markdown\\n+# 📦 ANÁLISIS DE RELEASE\\n+\\n+## 🎯 RESUMEN\\n+[Descripción de los cambios principales incluidos en esta release]\\n+\\n+## 📋 CHANGELOG GENERADO\\n+\\n+### ✨ Features\\n+[Lista de nuevas funcionalidades]\\n+\\n+### 🐛 Fixes\\n+[Lista de correcciones de bugs]\\n+\\n+### 🚀 Improvements\\n+[Lista de mejoras]\\n+\\n+### 🔧 Technical\\n+[Cambios técnicos internos]\\n+\\n+## 🏷️ INFORMACIÓN DE VERSIÓN\\n+- **Versión**: [versión calculada]\\n+- **Prefijo**: [alpha/beta/rc/stable]\\n+- **Canal OTA**: [dev/beta/stable]\\n+- **Tipo de cambio**: [major/minor/patch]\\n+\\n+## 📝 NOTAS DE RELEASE\\n+[Texto descriptivo para usuarios finales]\\n+\\\\`\\\\`\\\\`\\n+\\n+${STANDARD_PROMPT_SUFFIX}`;\\n+}\\n+/**\\n+ * Parser genérico para respuestas de Gemini\\n+ */\\n+export class GeminiResponseParser {\\n+    /**\\n+     * Extrae múltiples propuestas de commit del formato estándar\\n+     */\\n+    static parseCommitProposals(response) {\\n+        const proposals = [];\\n+        // Buscar todas las propuestas con el formato: ### **Propuesta de Commit #N**\\n+        const proposalPattern = /###\\\\s*\\\\*\\\\*Propuesta de Commit #\\\\d+\\\\*\\\\*/g;\\n+        const proposalMatches = Array.from(response.matchAll(proposalPattern));\\n+        if (proposalMatches.length === 0) {\\n+            // Formato de un solo commit sin numeración\\n+            const codeBlock = this.extractCodeBlock(response);\\n+            if (codeBlock) {\\n+                const parsed = this.parseCommitContent(codeBlock);\\n+                if (parsed)\\n+                    proposals.push(parsed);\\n+            }\\n+        }\\n+        else {\\n+            // Múltiples propuestas numeradas\\n+            for (let i = 0; i < proposalMatches.length; i++) {\\n+                const startIndex = proposalMatches[i].index;\\n+                const endIndex = proposalMatches[i + 1]?.index || response.length;\\n+                const proposalSection = response.substring(startIndex, endIndex);\\n+                const codeBlock = this.extractCodeBlock(proposalSection);\\n+                if (codeBlock) {\\n+                    const parsed = this.parseCommitContent(codeBlock);\\n+                    if (parsed)\\n+                        proposals.push(parsed);\\n+                }\\n+            }\\n+        }\\n+        return proposals;\\n+    }\\n+    /**\\n+     * Extrae bloque de código markdown\\n+     */\\n+    static extractCodeBlock(text) {\\n+        const patterns = [\\n+            /```markdown\\\\s*\\\\n([\\\\s\\\\S]*?)\\\\n```/, // ```markdown\\n+            /```\\\\s*\\\\n([\\\\s\\\\S]*?)\\\\n```/, // ``` genérico  \\n+            /```([\\\\s\\\\S]*?)```/ // sin saltos\\n+        ];\\n+        for (const pattern of patterns) {\\n+            const match = text.match(pattern);\\n+            if (match)\\n+                return match[1].trim();\\n+        }\\n+        return null;\\n+    }\\n+    /**\\n+     * Parsea el contenido de un commit individual\\n+     */\\n+    static parseCommitContent(content) {\\n+        const lines = content.split('\\\\n');\\n+        // Título (primera línea no vacía)\\n+        let title = '';\\n+        let titleIndex = 0;\\n+        for (let i = 0; i < lines.length; i++) {\\n+            if (lines[i].trim()) {\\n+                title = lines[i].trim();\\n+                titleIndex = i;\\n+                break;\\n+            }\\n+        }\\n+        if (!title)\\n+            return null;\\n+        // Extraer secciones\\n+        let description = '';\\n+        let technical = '';\\n+        let changelog = '';\\n+        let currentSection = 'description';\\n+        for (let i = titleIndex + 1; i < lines.length; i++) {\\n+            const line = lines[i];\\n+            if (line.includes('<technical>')) {\\n+                currentSection = 'technical';\\n+                continue;\\n+            }\\n+            else if (line.includes('</technical>')) {\\n+                currentSection = 'none';\\n+                continue;\\n+            }\\n+            else if (line.includes('<changelog>')) {\\n+                currentSection = 'changelog';\\n+                continue;\\n+            }\\n+            else if (line.includes('</changelog>')) {\\n+                currentSection = 'none';\\n+                continue;\\n+            }\\n+            if (currentSection === 'description' && line.trim()) {\\n+                description += line + '\\\\n';\\n+            }\\n+            else if (currentSection === 'technical') {\\n+                technical += line + '\\\\n';\\n+            }\\n+            else if (currentSection === 'changelog') {\\n+                changelog += line + '\\\\n';\\n+            }\\n+        }\\n+        return {\\n+            title,\\n+            description: description.trim(),\\n+            technical: technical.trim(),\\n+            changelog: changelog.trim()\\n+        };\\n+    }\\n+    /**\\n+     * Parsea respuesta de workflow en formato estándar\\n+     */\\n+    static parseWorkflowResponse(response) {\\n+        const analysisMatch = response.match(/🎯\\\\s*\\\\*\\\\*ANÁLISIS\\\\*\\\\*:\\\\s*(.+)/);\\n+        const impactMatch = response.match(/📊\\\\s*\\\\*\\\\*IMPACTO\\\\*\\\\*:\\\\s*(.+)/);\\n+        const recommendationMatch = response.match(/🚀\\\\s*\\\\*\\\\*RECOMENDACIÓN\\\\*\\\\*:\\\\s*(.+)/);\\n+        // Extraer comandos macOS\\n+        const macosSection = response.match(/##\\\\s*🖥️\\\\s*COMANDOS PARA macOS\\\\s*```bash\\\\s*([\\\\s\\\\S]*?)\\\\s*```/);\\n+        const macosCommands = macosSection ? macosSection[1].split('\\\\n').filter(line => line.trim() && !line.startsWith('#')) : [];\\n+        // Extraer comandos Linux ARM\\n+        const linuxSection = response.match(/##\\\\s*🐧\\\\s*COMANDOS PARA LINUX ARM[\\\\s\\\\S]*?```bash\\\\s*([\\\\s\\\\S]*?)\\\\s*```/);\\n+        const linuxCommands = linuxSection ? linuxSection[1].split('\\\\n').filter(line => line.trim() && !line.startsWith('#')) : [];\\n+        // Extraer verificaciones\\n+        const verificationsSection = response.match(/##\\\\s*✅\\\\s*VERIFICACIONES AUTOMÁTICAS\\\\s*([\\\\s\\\\S]*?)```/);\\n+        const verifications = verificationsSection ? verificationsSection[1].split('\\\\n').filter(line => line.trim().startsWith('-')).map(line => line.replace(/^-\\\\s*/, '')) : [];\\n+        return {\\n+            analysis: analysisMatch?.[1] || 'No disponible',\\n+            impact: impactMatch?.[1] || 'No disponible',\\n+            recommendation: recommendationMatch?.[1] || 'No disponible',\\n+            macosCommands,\\n+            linuxCommands,\\n+            verifications\\n+        };\\n+    }\\n+}\",\n+      \"lines_added\": 345,\n+      \"lines_removed\": 0,\n+      \"is_binary\": false\n+    },\n+    {\n+      \"path\": \"project-utils/prompt-templates.ts\",\n+      \"status\": \"added\",\n+      \"diff\": \"diff --git a/project-utils/prompt-templates.ts b/project-utils/prompt-templates.ts\\nnew file mode 100644\\nindex 0000000..8cee1c5\\n--- /dev/null\\n+++ b/project-utils/prompt-templates.ts\\n@@ -0,0 +1,422 @@\\n+/**\\n+ * Plantillas de prompts estandarizadas para Gemini CLI\\n+ * @description Asegura respuestas consistentes y parseables en todos los scripts\\n+ * @author TPV EL Haido\\n+ */\\n+\\n+export interface GeminiPromptConfig {\\n+  /** Contexto base del proyecto */\\n+  projectContext: {\\n+    name: string;\\n+    description: string;\\n+    version: string;\\n+    techStack: string[];\\n+    targetPlatform: string;\\n+  };\\n+  /** Tipo de análisis requerido */\\n+  analysisType: 'commit' | 'workflow' | 'release';\\n+  /** Contexto adicional específico */\\n+  specificContext?: string;\\n+  /** Datos estructurados para el análisis */\\n+  data?: any;\\n+}\\n+\\n+export interface StandardResponseFormat {\\n+  /** Análisis o resumen principal */\\n+  analysis: string;\\n+  /** Recomendaciones o acciones */\\n+  recommendations: string;\\n+  /** Datos estructurados (commits, comandos, etc.) */\\n+  structured_data: any[];\\n+}\\n+\\n+/**\\n+ * Configuración base del proyecto Better Logger\\n+ */\\n+export const BETTER_LOGGER_PROJECT_CONFIG = {\\n+  name: 'Better Logger',\\n+  description: 'State-of-the-art console logger with advanced CSS styling, SVG support, animations, and CLI interface',\\n+  version: '0.0.3-alpha.0',\\n+  techStack: ['TypeScript', 'Vite', 'Browser', 'CSS-in-JS', 'SVG'] as const,\\n+  targetPlatform: 'Browser (Chrome, Firefox, Safari, Edge)',\\n+} as const;\\n+\\n+// Alias para compatibilidad\\n+export const TPV_PROJECT_CONFIG = BETTER_LOGGER_PROJECT_CONFIG;\\n+\\n+/**\\n+ * Prefijo estándar para todos los prompts de Gemini\\n+ */\\n+const STANDARD_PROMPT_PREFIX = `# Sistema de Análisis Inteligente - Better Logger\\n+\\n+Eres un asistente especializado en análisis de código y automatización para el proyecto Better Logger. Tu función es proporcionar respuestas estructuradas, precisas y consistentes que puedan ser parseadas automáticamente.\\n+\\n+## REGLAS CRÍTICAS DE FORMATO\\n+\\n+1. **FORMATO DE RESPUESTA OBLIGATORIO**: Todas tus respuestas deben seguir exactamente el formato especificado más abajo.\\n+2. **CONSISTENCIA**: Mantén la misma estructura sin importar la complejidad del análisis.\\n+3. **PARSEABLE**: El formato debe ser fácil de procesar automáticamente con expresiones regulares.\\n+4. **BLOQUES MARKDOWN**: Usa \\\\`\\\\`\\\\`markdown para bloques de código cuando se especifique.\\n+5. **SECCIONES TÉCNICAS**: Siempre incluye las secciones <technical> y <changelog> cuando sea aplicable.\\n+\\n+## Contexto del Proyecto\\n+**Nombre**: ${BETTER_LOGGER_PROJECT_CONFIG.name}\\n+**Descripción**: ${BETTER_LOGGER_PROJECT_CONFIG.description}\\n+**Versión Actual**: ${BETTER_LOGGER_PROJECT_CONFIG.version}\\n+**Stack Tecnológico**: ${BETTER_LOGGER_PROJECT_CONFIG.techStack.join(', ')}\\n+**Plataforma Objetivo**: ${BETTER_LOGGER_PROJECT_CONFIG.targetPlatform}\\n+\\n+---\\n+`;\\n+\\n+/**\\n+ * Sufijo estándar con instrucciones de formato\\n+ */\\n+const STANDARD_PROMPT_SUFFIX = `\\n+\\n+---\\n+\\n+## INSTRUCCIONES FINALES\\n+\\n+1. **Lee cuidadosamente** toda la información proporcionada\\n+2. **Analiza el contexto** y los datos específicos\\n+3. **Genera una respuesta** siguiendo EXACTAMENTE el formato especificado\\n+4. **Mantén consistencia** en la estructura y sintaxis\\n+5. **No desvíes** del formato requerido bajo ninguna circunstancia\\n+\\n+**IMPORTANTE**: La respuesta debe ser parseada automáticamente. Cualquier desviación del formato especificado causará errores en el sistema.`;\\n+\\n+/**\\n+ * Genera prompt para análisis de commits\\n+ */\\n+export function createCommitPrompt(config: GeminiPromptConfig): string {\\n+  const { data, specificContext } = config;\\n+  \\n+  return `${STANDARD_PROMPT_PREFIX}\\n+\\n+# ANÁLISIS DE COMMITS\\n+\\n+## Datos del Análisis\\n+${JSON.stringify(data, null, 2)}\\n+\\n+## Contexto Adicional\\n+${specificContext || 'Ninguno proporcionado'}\\n+\\n+---\\n+\\n+## FORMATO DE RESPUESTA REQUERIDO\\n+\\n+Tu respuesta debe seguir EXACTAMENTE esta estructura:\\n+\\n+### **ANÁLISIS PRINCIPAL**\\n+\\n+[Descripción general de los cambios detectados]\\n+\\n+---\\n+\\n+### **Propuesta de Commit #1**\\n+\\n+\\\\`\\\\`\\\\`markdown\\n+[prefijo](área - descripción breve)\\n+\\n+[Descripción completa en castellano de QUÉ se logró y POR QUÉ]\\n+\\n+<technical>\\n+[Detalles técnicos específicos: archivos modificados, funciones añadidas, refactorizaciones, etc.]\\n+</technical>\\n+\\n+<changelog>\\n+## [Tipo] [Emoji]\\n+[Entrada para changelog de la app, optimizada para mostrar al usuario]\\n+</changelog>\\n+\\\\`\\\\`\\\\`\\n+\\n+### **Propuesta de Commit #2** (solo si es necesario)\\n+\\n+[Repetir formato anterior]\\n+\\n+---\\n+\\n+**DECISIÓN**: [Explicación breve de por qué uno o múltiples commits]\\n+\\n+${STANDARD_PROMPT_SUFFIX}`;\\n+}\\n+\\n+/**\\n+ * Genera prompt para asistente de workflow\\n+ */\\n+export function createWorkflowPrompt(config: GeminiPromptConfig): string {\\n+  const { data, specificContext } = config;\\n+  \\n+  return `${STANDARD_PROMPT_PREFIX}\\n+\\n+# ASISTENTE DE WORKFLOW\\n+\\n+## Solicitud del Usuario\\n+\\\"${specificContext}\\\"\\n+\\n+## Contexto del Proyecto Actual\\n+${JSON.stringify(data, null, 2)}\\n+\\n+---\\n+\\n+## FORMATO DE RESPUESTA REQUERIDO\\n+\\n+\\\\`\\\\`\\\\`markdown\\n+🎯 **ANÁLISIS**: [Descripción del tipo de trabajo detectado]\\n+📊 **IMPACTO**: [Áreas afectadas y alcance del cambio]\\n+🚀 **RECOMENDACIÓN**: [Tipo de versión y estrategia recomendada]\\n+\\n+## 🖥️ COMANDOS PARA macOS\\n+\\\\`\\\\`\\\\`bash\\n+# [Descripción del primer comando]\\n+[comando exacto con parámetros]\\n+\\n+# [Descripción del segundo comando]  \\n+[segundo comando exacto]\\n+\\\\`\\\\`\\\\`\\n+\\n+## 🐧 COMANDOS PARA LINUX ARM (después de macOS)\\n+\\\\`\\\\`\\\\`bash\\n+# SSH y preparación\\n+ssh user@raspberry-pi\\n+git pull origin master && bun install\\n+\\n+# [Descripción del build ARM]\\n+[comandos específicos de ARM]\\n+\\\\`\\\\`\\\\`\\n+\\n+## ✅ VERIFICACIONES AUTOMÁTICAS\\n+- [Lista de verificaciones que se ejecutarán]\\n+\\\\`\\\\`\\\\`\\n+\\n+${STANDARD_PROMPT_SUFFIX}`;\\n+}\\n+\\n+/**\\n+ * Genera prompt para releases automáticas\\n+ */\\n+export function createReleasePrompt(config: GeminiPromptConfig): string {\\n+  const { data, specificContext } = config;\\n+  \\n+  return `${STANDARD_PROMPT_PREFIX}\\n+\\n+# ANÁLISIS DE RELEASE\\n+\\n+## Información de la Release\\n+${JSON.stringify(data, null, 2)}\\n+\\n+## Contexto Específico\\n+${specificContext || 'Release automática'}\\n+\\n+---\\n+\\n+## FORMATO DE RESPUESTA REQUERIDO\\n+\\n+\\\\`\\\\`\\\\`markdown\\n+# 📦 ANÁLISIS DE RELEASE\\n+\\n+## 🎯 RESUMEN\\n+[Descripción de los cambios principales incluidos en esta release]\\n+\\n+## 📋 CHANGELOG GENERADO\\n+\\n+### ✨ Features\\n+[Lista de nuevas funcionalidades]\\n+\\n+### 🐛 Fixes\\n+[Lista de correcciones de bugs]\\n+\\n+### 🚀 Improvements\\n+[Lista de mejoras]\\n+\\n+### 🔧 Technical\\n+[Cambios técnicos internos]\\n+\\n+## 🏷️ INFORMACIÓN DE VERSIÓN\\n+- **Versión**: [versión calculada]\\n+- **Prefijo**: [alpha/beta/rc/stable]\\n+- **Canal OTA**: [dev/beta/stable]\\n+- **Tipo de cambio**: [major/minor/patch]\\n+\\n+## 📝 NOTAS DE RELEASE\\n+[Texto descriptivo para usuarios finales]\\n+\\\\`\\\\`\\\\`\\n+\\n+${STANDARD_PROMPT_SUFFIX}`;\\n+}\\n+\\n+/**\\n+ * Parser genérico para respuestas de Gemini\\n+ */\\n+export class GeminiResponseParser {\\n+  /**\\n+   * Extrae múltiples propuestas de commit del formato estándar\\n+   */\\n+  static parseCommitProposals(response: string): Array<{\\n+    title: string;\\n+    description: string;\\n+    technical: string;\\n+    changelog: string;\\n+  }> {\\n+    const proposals: Array<{\\n+      title: string;\\n+      description: string; \\n+      technical: string;\\n+      changelog: string;\\n+    }> = [];\\n+\\n+    // Buscar todas las propuestas con el formato: ### **Propuesta de Commit #N**\\n+    const proposalPattern = /###\\\\s*\\\\*\\\\*Propuesta de Commit #\\\\d+\\\\*\\\\*/g;\\n+    const proposalMatches = Array.from(response.matchAll(proposalPattern));\\n+    \\n+    if (proposalMatches.length === 0) {\\n+      // Formato de un solo commit sin numeración\\n+      const codeBlock = this.extractCodeBlock(response);\\n+      if (codeBlock) {\\n+        const parsed = this.parseCommitContent(codeBlock);\\n+        if (parsed) proposals.push(parsed);\\n+      }\\n+    } else {\\n+      // Múltiples propuestas numeradas\\n+      for (let i = 0; i < proposalMatches.length; i++) {\\n+        const startIndex = proposalMatches[i].index!;\\n+        const endIndex = proposalMatches[i + 1]?.index || response.length;\\n+        const proposalSection = response.substring(startIndex, endIndex);\\n+        \\n+        const codeBlock = this.extractCodeBlock(proposalSection);\\n+        if (codeBlock) {\\n+          const parsed = this.parseCommitContent(codeBlock);\\n+          if (parsed) proposals.push(parsed);\\n+        }\\n+      }\\n+    }\\n+\\n+    return proposals;\\n+  }\\n+\\n+  /**\\n+   * Extrae bloque de código markdown\\n+   */\\n+  private static extractCodeBlock(text: string): string | null {\\n+    const patterns = [\\n+      /```markdown\\\\s*\\\\n([\\\\s\\\\S]*?)\\\\n```/,  // ```markdown\\n+      /```\\\\s*\\\\n([\\\\s\\\\S]*?)\\\\n```/,        // ``` genérico  \\n+      /```([\\\\s\\\\S]*?)```/                 // sin saltos\\n+    ];\\n+    \\n+    for (const pattern of patterns) {\\n+      const match = text.match(pattern);\\n+      if (match) return match[1].trim();\\n+    }\\n+    \\n+    return null;\\n+  }\\n+\\n+  /**\\n+   * Parsea el contenido de un commit individual\\n+   */\\n+  private static parseCommitContent(content: string): {\\n+    title: string;\\n+    description: string;\\n+    technical: string;\\n+    changelog: string;\\n+  } | null {\\n+    const lines = content.split('\\\\n');\\n+    \\n+    // Título (primera línea no vacía)\\n+    let title = '';\\n+    let titleIndex = 0;\\n+    for (let i = 0; i < lines.length; i++) {\\n+      if (lines[i].trim()) {\\n+        title = lines[i].trim();\\n+        titleIndex = i;\\n+        break;\\n+      }\\n+    }\\n+\\n+    if (!title) return null;\\n+\\n+    // Extraer secciones\\n+    let description = '';\\n+    let technical = '';\\n+    let changelog = '';\\n+    let currentSection = 'description';\\n+\\n+    for (let i = titleIndex + 1; i < lines.length; i++) {\\n+      const line = lines[i];\\n+\\n+      if (line.includes('<technical>')) {\\n+        currentSection = 'technical';\\n+        continue;\\n+      } else if (line.includes('</technical>')) {\\n+        currentSection = 'none';\\n+        continue;\\n+      } else if (line.includes('<changelog>')) {\\n+        currentSection = 'changelog';\\n+        continue;\\n+      } else if (line.includes('</changelog>')) {\\n+        currentSection = 'none';\\n+        continue;\\n+      }\\n+\\n+      if (currentSection === 'description' && line.trim()) {\\n+        description += line + '\\\\n';\\n+      } else if (currentSection === 'technical') {\\n+        technical += line + '\\\\n';\\n+      } else if (currentSection === 'changelog') {\\n+        changelog += line + '\\\\n';\\n+      }\\n+    }\\n+\\n+    return {\\n+      title,\\n+      description: description.trim(),\\n+      technical: technical.trim(),\\n+      changelog: changelog.trim()\\n+    };\\n+  }\\n+\\n+  /**\\n+   * Parsea respuesta de workflow en formato estándar\\n+   */\\n+  static parseWorkflowResponse(response: string): {\\n+    analysis: string;\\n+    impact: string;\\n+    recommendation: string;\\n+    macosCommands: string[];\\n+    linuxCommands: string[];\\n+    verifications: string[];\\n+  } {\\n+    const analysisMatch = response.match(/🎯\\\\s*\\\\*\\\\*ANÁLISIS\\\\*\\\\*:\\\\s*(.+)/);\\n+    const impactMatch = response.match(/📊\\\\s*\\\\*\\\\*IMPACTO\\\\*\\\\*:\\\\s*(.+)/);\\n+    const recommendationMatch = response.match(/🚀\\\\s*\\\\*\\\\*RECOMENDACIÓN\\\\*\\\\*:\\\\s*(.+)/);\\n+\\n+    // Extraer comandos macOS\\n+    const macosSection = response.match(/##\\\\s*🖥️\\\\s*COMANDOS PARA macOS\\\\s*```bash\\\\s*([\\\\s\\\\S]*?)\\\\s*```/);\\n+    const macosCommands = macosSection ? macosSection[1].split('\\\\n').filter(line => \\n+      line.trim() && !line.startsWith('#')\\n+    ) : [];\\n+\\n+    // Extraer comandos Linux ARM\\n+    const linuxSection = response.match(/##\\\\s*🐧\\\\s*COMANDOS PARA LINUX ARM[\\\\s\\\\S]*?```bash\\\\s*([\\\\s\\\\S]*?)\\\\s*```/);\\n+    const linuxCommands = linuxSection ? linuxSection[1].split('\\\\n').filter(line => \\n+      line.trim() && !line.startsWith('#')\\n+    ) : [];\\n+\\n+    // Extraer verificaciones\\n+    const verificationsSection = response.match(/##\\\\s*✅\\\\s*VERIFICACIONES AUTOMÁTICAS\\\\s*([\\\\s\\\\S]*?)```/);\\n+    const verifications = verificationsSection ? verificationsSection[1].split('\\\\n').filter(line =>\\n+      line.trim().startsWith('-')\\n+    ).map(line => line.replace(/^-\\\\s*/, '')) : [];\\n+\\n+    return {\\n+      analysis: analysisMatch?.[1] || 'No disponible',\\n+      impact: impactMatch?.[1] || 'No disponible', \\n+      recommendation: recommendationMatch?.[1] || 'No disponible',\\n+      macosCommands,\\n+      linuxCommands,\\n+      verifications\\n+    };\\n+  }\\n+}\\n\\\\ No newline at end of file\",\n+      \"lines_added\": 422,\n+      \"lines_removed\": 0,\n+      \"is_binary\": false\n+    },\n+    {\n+      \"path\": \"project-utils/version-manager.ts\",\n+      \"status\": \"added\",\n+      \"diff\": \"diff --git a/project-utils/version-manager.ts b/project-utils/version-manager.ts\\nnew file mode 100644\\nindex 0000000..b9639b2\\n--- /dev/null\\n+++ b/project-utils/version-manager.ts\\n@@ -0,0 +1,967 @@\\n+#!/usr/bin/env node\\n+\\n+/**\\n+ * Version Manager para Better Logger\\n+ * Analiza commits, extrae changelog, asigna versiones y actualiza archivos\\n+ */\\n+\\n+import { readFileSync, writeFileSync, existsSync } from 'fs';\\n+import { join } from 'path';\\n+\\n+interface ChangelogEntry {\\n+  type: 'feature' | 'fix' | 'improvement' | 'breaking';\\n+  title: string;\\n+  description: string;\\n+}\\n+\\n+interface Version {\\n+  version: string;\\n+  date: string;\\n+  type: 'initial' | 'major' | 'minor' | 'patch';\\n+  title: string;\\n+  changes: ChangelogEntry[];\\n+  technical_notes: string;\\n+  breaking_changes: string[];\\n+  commit_hash: string;\\n+  prefix?: string; // pre-alpha, alpha, beta, rc, o undefined para stable\\n+}\\n+\\n+interface ChangelogData {\\n+  current_version: string;\\n+  versions: Version[];\\n+}\\n+\\n+interface CommitInfo {\\n+  hash: string;\\n+  date: string;\\n+  title: string;\\n+  description: string;\\n+  technical_section?: string;\\n+  changelog_section?: string;\\n+}\\n+\\n+class VersionManager {\\n+  private projectRoot: string;\\n+  private changelogPath: string;\\n+  private packageJsonPath: string;\\n+  private tauriConfigPath: string;\\n+  private cargoTomlPath: string;\\n+\\n+  constructor() {\\n+    this.projectRoot = process.cwd();\\n+    this.changelogPath = join(this.projectRoot, 'CHANGELOG.json');\\n+    this.packageJsonPath = join(this.projectRoot, 'package.json');\\n+  }\\n+\\n+  /**\\n+   * Ejecuta comando git y devuelve resultado\\n+   */\\n+  private async gitCommand(args: string[]): Promise<string> {\\n+    const { spawn } = await import('child_process');\\n+    \\n+    return new Promise((resolve, reject) => {\\n+      const proc = spawn('git', args, {\\n+        cwd: this.projectRoot,\\n+        stdio: ['pipe', 'pipe', 'pipe']\\n+      });\\n+\\n+      let stdout = '';\\n+      let stderr = '';\\n+\\n+      proc.stdout?.on('data', (data) => {\\n+        stdout += data.toString();\\n+      });\\n+\\n+      proc.stderr?.on('data', (data) => {\\n+        stderr += data.toString();\\n+      });\\n+\\n+      proc.on('exit', (code) => {\\n+        if (code !== 0) {\\n+          reject(new Error(`Git error: ${stderr || 'Git command failed'}`));\\n+        } else {\\n+          resolve(stdout.trim());\\n+        }\\n+      });\\n+\\n+      proc.on('error', (error) => {\\n+        reject(error);\\n+      });\\n+    });\\n+  }\\n+\\n+  /**\\n+   * Obtiene todos los commits desde un hash específico\\n+   */\\n+  private async getCommitsSince(sinceHash?: string): Promise<CommitInfo[]> {\\n+    const args = ['log', '--pretty=format:%H|%ci|%s', '--reverse'];\\n+    if (sinceHash) {\\n+      args.push(`${sinceHash}..HEAD`);\\n+    }\\n+\\n+    const output = await this.gitCommand(args);\\n+    if (!output) return [];\\n+\\n+    const commits: CommitInfo[] = [];\\n+    \\n+    for (const line of output.split('\\\\n')) {\\n+      const [hash, date, title] = line.split('|');\\n+      if (!hash) continue;\\n+\\n+      // Obtener el mensaje completo del commit\\n+      try {\\n+        const fullMessage = await this.gitCommand(['log', '-1', '--pretty=format:%B', hash]);\\n+        const sections = this.parseCommitMessage(fullMessage);\\n+        \\n+        commits.push({\\n+          hash,\\n+          date: new Date(date).toISOString().split('T')[0],\\n+          title,\\n+          description: fullMessage,\\n+          technical_section: sections.technical,\\n+          changelog_section: sections.changelog\\n+        });\\n+      } catch (error) {\\n+        console.warn(`⚠️ No se pudo obtener mensaje completo para commit ${hash}: ${error}`);\\n+        commits.push({\\n+          hash,\\n+          date: new Date(date).toISOString().split('T')[0],\\n+          title,\\n+          description: title\\n+        });\\n+      }\\n+    }\\n+\\n+    return commits;\\n+  }\\n+\\n+  /**\\n+   * Extrae secciones <technical> y <changelog> de un mensaje de commit\\n+   */\\n+  private parseCommitMessage(message: string): { technical?: string; changelog?: string } {\\n+    const technicalMatch = message.match(/<technical>([\\\\s\\\\S]*?)<\\\\/technical>/);\\n+    const changelogMatch = message.match(/<changelog>([\\\\s\\\\S]*?)<\\\\/changelog>/);\\n+\\n+    return {\\n+      technical: technicalMatch?.[1]?.trim(),\\n+      changelog: changelogMatch?.[1]?.trim()\\n+    };\\n+  }\\n+\\n+  /**\\n+   * Convierte sección de changelog en entradas estructuradas\\n+   */\\n+  private parseChangelogSection(changelog: string): ChangelogEntry[] {\\n+    if (!changelog) return [];\\n+\\n+    const entries: ChangelogEntry[] = [];\\n+    const lines = changelog.split('\\\\n').map(line => line.trim()).filter(line => line);\\n+\\n+    let currentSection = '';\\n+    let currentEntries: string[] = [];\\n+\\n+    for (const line of lines) {\\n+      if (line.startsWith('##')) {\\n+        // Procesar sección anterior\\n+        if (currentSection && currentEntries.length > 0) {\\n+          entries.push(...this.processSectionEntries(currentSection, currentEntries));\\n+        }\\n+\\n+        // Nueva sección\\n+        currentSection = line.replace(/^##\\\\s*/, '').toLowerCase();\\n+        currentEntries = [];\\n+      } else if (line.startsWith('-')) {\\n+        currentEntries.push(line.replace(/^-\\\\s*/, ''));\\n+      }\\n+    }\\n+\\n+    // Procesar última sección\\n+    if (currentSection && currentEntries.length > 0) {\\n+      entries.push(...this.processSectionEntries(currentSection, currentEntries));\\n+    }\\n+\\n+    return entries;\\n+  }\\n+\\n+  /**\\n+   * Procesa entradas de una sección específica del changelog\\n+   */\\n+  private processSectionEntries(section: string, entries: string[]): ChangelogEntry[] {\\n+    let type: ChangelogEntry['type'] = 'improvement';\\n+\\n+    if (section.includes('fix') || section.includes('🐛')) {\\n+      type = 'fix';\\n+    } else if (section.includes('feature') || section.includes('✨')) {\\n+      type = 'feature';\\n+    } else if (section.includes('breaking')) {\\n+      type = 'breaking';\\n+    }\\n+\\n+    return entries.map(entry => ({\\n+      type,\\n+      title: entry.split('.')[0] || entry,\\n+      description: entry\\n+    }));\\n+  }\\n+\\n+  /**\\n+   * Determina el tipo de versión basado en los cambios\\n+   */\\n+  private determineVersionType(commits: CommitInfo[]): Version['type'] {\\n+    const hasBreaking = commits.some(c => \\n+      c.changelog_section?.includes('breaking') || \\n+      c.title.toLowerCase().includes('breaking')\\n+    );\\n+    \\n+    if (hasBreaking) return 'major';\\n+\\n+    const hasFeature = commits.some(c => \\n+      c.title.startsWith('feat(') || \\n+      c.changelog_section?.includes('✨') ||\\n+      c.changelog_section?.toLowerCase().includes('feature')\\n+    );\\n+    \\n+    if (hasFeature) return 'minor';\\n+\\n+    return 'patch';\\n+  }\\n+\\n+  /**\\n+   * Incrementa versión según el tipo, considerando prefijos\\n+   */\\n+  private incrementVersion(\\n+    currentVersion: string, \\n+    type: Version['type'], \\n+    targetPrefix?: string,\\n+    overrideType?: Version['type']\\n+  ): string {\\n+    // Extraer prefix y versión base\\n+    const { prefix, baseVersion } = this.parseVersionString(currentVersion);\\n+    const [major, minor, patch] = baseVersion.split('.').map(Number);\\n+\\n+    // Si se especifica un targetPrefix, usarlo; si no, mantener el actual\\n+    const newPrefix = targetPrefix !== undefined ? targetPrefix : prefix;\\n+\\n+    // Si se especifica un override del tipo, usarlo\\n+    const actualType = overrideType || type;\\n+\\n+    let newBaseVersion: string;\\n+    switch (actualType) {\\n+      case 'major':\\n+        newBaseVersion = `${major + 1}.0.0`;\\n+        break;\\n+      case 'minor':\\n+        newBaseVersion = `${major}.${minor + 1}.0`;\\n+        break;\\n+      case 'patch':\\n+        newBaseVersion = `${major}.${minor}.${patch + 1}`;\\n+        break;\\n+      default:\\n+        newBaseVersion = baseVersion;\\n+    }\\n+\\n+    return this.buildVersionString(newPrefix, newBaseVersion);\\n+  }\\n+\\n+  /**\\n+   * Parsea una versión con posible prefijo\\n+   */\\n+  private parseVersionString(version: string): { prefix?: string; baseVersion: string } {\\n+    const prefixMatch = version.match(/^(pre-alpha-|alpha-|beta-|rc-)?(.+)$/);\\n+    if (prefixMatch) {\\n+      return {\\n+        prefix: prefixMatch[1]?.replace(/-$/, ''), // Remover el guión final\\n+        baseVersion: prefixMatch[2]\\n+      };\\n+    }\\n+    return { baseVersion: version };\\n+  }\\n+\\n+  /**\\n+   * Construye una versión con prefijo\\n+   */\\n+  private buildVersionString(prefix?: string, baseVersion?: string): string {\\n+    if (!baseVersion) return '1.0.0';\\n+    if (!prefix) return baseVersion; // Sin prefijo = estable\\n+    return `${prefix}-${baseVersion}`;\\n+  }\\n+\\n+  /**\\n+   * Valida que la transición de prefijo sea lógica\\n+   */\\n+  private validatePrefixTransition(currentVersion: string, targetPrefix?: string): void {\\n+    const { prefix: currentPrefix } = this.parseVersionString(currentVersion);\\n+    \\n+    // Definir orden de prefijos (undefined = stable)\\n+    const prefixOrder = ['pre-alpha', 'alpha', 'beta', 'rc', undefined];\\n+    const currentIndex = prefixOrder.indexOf(currentPrefix);\\n+    const targetIndex = prefixOrder.indexOf(targetPrefix);\\n+\\n+    // Permitir cualquier transición, pero advertir sobre regresiones\\n+    if (currentIndex !== -1 && targetIndex !== -1 && targetIndex < currentIndex) {\\n+      console.warn(`⚠️ Advertencia: Transición de prefijo regresiva ${currentPrefix || 'stable'} → ${targetPrefix || 'stable'}`);\\n+      console.warn('   Esto podría confundir a los usuarios sobre el estado de estabilidad.');\\n+    }\\n+\\n+    // Validar prefijos válidos\\n+    const validPrefixes = ['pre-alpha', 'alpha', 'beta', 'rc'];\\n+    if (targetPrefix && !validPrefixes.includes(targetPrefix)) {\\n+      throw new Error(`❌ Prefijo inválido: ${targetPrefix}. Válidos: ${validPrefixes.join(', ')}, o sin prefijo para stable`);\\n+    }\\n+  }\\n+\\n+  /**\\n+   * Carga datos actuales del changelog\\n+   */\\n+  private loadChangelogData(): ChangelogData {\\n+    if (existsSync(this.changelogPath)) {\\n+      try {\\n+        const content = readFileSync(this.changelogPath, 'utf-8');\\n+        return JSON.parse(content);\\n+      } catch (error) {\\n+        console.warn('⚠️ Error leyendo changelog.json, creando nuevo');\\n+      }\\n+    }\\n+\\n+    return {\\n+      current_version: '0.1.0',\\n+      versions: []\\n+    };\\n+  }\\n+\\n+  /**\\n+   * Obtiene el último commit versionado\\n+   */\\n+  private getLastVersionedCommit(data: ChangelogData): string | undefined {\\n+    const sortedVersions = [...data.versions].sort((a, b) => \\n+      new Date(b.date).getTime() - new Date(a.date).getTime()\\n+    );\\n+    \\n+    return sortedVersions[0]?.commit_hash;\\n+  }\\n+\\n+  /**\\n+   * Analiza commits y genera nueva versión\\n+   */\\n+  async analyzeAndVersion(options: {\\n+    type?: Version['type'];\\n+    prefix?: string;\\n+  } = {}): Promise<void> {\\n+    console.log('🚀 Iniciando análisis de versionado...\\\\n');\\n+\\n+    try {\\n+      // Cargar datos existentes\\n+      const changelogData = this.loadChangelogData();\\n+      console.log(`📋 Versión actual: ${changelogData.current_version}`);\\n+\\n+      // Obtener último commit versionado\\n+      const lastVersionedCommit = this.getLastVersionedCommit(changelogData);\\n+      console.log(`🔍 Último commit versionado: ${lastVersionedCommit || 'ninguno'}`);\\n+\\n+      // Obtener commits nuevos\\n+      const newCommits = await this.getCommitsSince(lastVersionedCommit);\\n+      console.log(`📝 Encontrados ${newCommits.length} commits nuevos`);\\n+\\n+      if (newCommits.length === 0) {\\n+        console.log('✅ No hay commits nuevos para versionar');\\n+        return;\\n+      }\\n+\\n+      // Mostrar commits que se van a versionar\\n+      console.log('\\\\n📋 Commits que se incluirán en la nueva versión:');\\n+      newCommits.forEach(commit => {\\n+        console.log(`  • ${commit.hash.slice(0, 7)} - ${commit.title}`);\\n+      });\\n+\\n+      // Determinar tipo de versión\\n+      const detectedVersionType = this.determineVersionType(newCommits);\\n+      const finalVersionType = options.type || detectedVersionType;\\n+      \\n+      // Si se especifica un prefix, validarlo\\n+      if (options.prefix !== undefined) {\\n+        this.validatePrefixTransition(changelogData.current_version, options.prefix);\\n+      }\\n+\\n+      const newVersion = this.incrementVersion(\\n+        changelogData.current_version, \\n+        detectedVersionType, \\n+        options.prefix,\\n+        finalVersionType\\n+      );\\n+      \\n+      console.log(`\\\\n🏷️ Nueva versión: ${changelogData.current_version} → ${newVersion}`);\\n+      console.log(`📊 Tipo detectado: ${detectedVersionType}${options.type ? ` → Forzado: ${options.type}` : ''}`);\\n+      if (options.prefix !== undefined) {\\n+        const { prefix: currentPrefix } = this.parseVersionString(changelogData.current_version);\\n+        console.log(`🏷️ Prefix: ${currentPrefix || 'stable'} → ${options.prefix || 'stable'}`);\\n+      }\\n+\\n+      // Procesar cambios\\n+      const allChanges: ChangelogEntry[] = [];\\n+      let technicalNotes = '';\\n+\\n+      for (const commit of newCommits) {\\n+        if (commit.changelog_section) {\\n+          const changes = this.parseChangelogSection(commit.changelog_section);\\n+          allChanges.push(...changes);\\n+        } else {\\n+          // Generar entrada básica desde el título del commit\\n+          let type: ChangelogEntry['type'] = 'improvement';\\n+          if (commit.title.startsWith('feat(')) type = 'feature';\\n+          else if (commit.title.startsWith('fix(')) type = 'fix';\\n+\\n+          allChanges.push({\\n+            type,\\n+            title: commit.title.replace(/^(feat|fix|refactor)\\\\([^)]+\\\\)\\\\s*-\\\\s*/, ''),\\n+            description: commit.title\\n+          });\\n+        }\\n+\\n+        if (commit.technical_section) {\\n+          technicalNotes += `\\\\n${commit.technical_section}`;\\n+        }\\n+      }\\n+\\n+      // Crear nueva versión\\n+      const { prefix } = this.parseVersionString(newVersion);\\n+      const newVersionEntry: Version = {\\n+        version: newVersion,\\n+        date: new Date().toISOString().split('T')[0],\\n+        type: finalVersionType,\\n+        title: this.generateVersionTitle(allChanges, finalVersionType, prefix),\\n+        changes: allChanges,\\n+        technical_notes: technicalNotes.trim(),\\n+        breaking_changes: allChanges\\n+          .filter(c => c.type === 'breaking')\\n+          .map(c => c.description),\\n+        commit_hash: newCommits[newCommits.length - 1].hash,\\n+        prefix\\n+      };\\n+\\n+      // Actualizar datos\\n+      changelogData.current_version = newVersion;\\n+      changelogData.versions.unshift(newVersionEntry); // Agregar al principio\\n+\\n+      // Guardar changelog actualizado\\n+      writeFileSync(this.changelogPath, JSON.stringify(changelogData, null, 2));\\n+      console.log(`💾 Changelog actualizado: ${this.changelogPath}`);\\n+\\n+      // Actualizar todos los archivos de configuración\\n+      await this.updateAllVersionFiles(newVersion);\\n+\\n+      console.log(`\\\\n✅ Versionado completado exitosamente!`);\\n+      console.log(`📦 Nueva versión: ${newVersion}`);\\n+      console.log(`📋 Cambios incluidos: ${allChanges.length}`);\\n+      console.log(`📝 Commits procesados: ${newCommits.length}`);\\n+      \\n+      // Sugerir creación de release si hay archivos de distribución disponibles\\n+      const distDir = join(this.projectRoot, 'dist');\\n+      if (existsSync(distDir)) {\\n+        console.log(`\\\\n💡 Archivos de distribución detectados en ${distDir}`);\\n+        console.log(`🚀 Para crear release en GitHub ejecuta:`);\\n+        console.log(`   npm run release:github`);\\n+      }\\n+\\n+    } catch (error) {\\n+      console.error('❌ Error durante el versionado:', error);\\n+      throw error;\\n+    }\\n+  }\\n+\\n+  /**\\n+   * Genera título descriptivo para la versión\\n+   */\\n+  private generateVersionTitle(changes: ChangelogEntry[], type: Version['type'], prefix?: string): string {\\n+    const features = changes.filter(c => c.type === 'feature');\\n+    const fixes = changes.filter(c => c.type === 'fix');\\n+    const improvements = changes.filter(c => c.type === 'improvement');\\n+\\n+    // Prefijo para el título\\n+    const prefixLabel = prefix ? \\n+      `Versión ${prefix.charAt(0).toUpperCase() + prefix.slice(1)} - ` : '';\\n+\\n+    if (type === 'major') {\\n+      return `${prefixLabel}Actualización mayor con cambios significativos`;\\n+    }\\n+\\n+    if (features.length > 0) {\\n+      const mainFeature = features[0].title;\\n+      if (features.length === 1) {\\n+        return `${prefixLabel}Nueva funcionalidad: ${mainFeature}`;\\n+      }\\n+      return `${prefixLabel}Nuevas funcionalidades incluyendo ${mainFeature} y ${features.length - 1} más`;\\n+    }\\n+\\n+    if (fixes.length > 0) {\\n+      if (fixes.length === 1) {\\n+        return `${prefixLabel}Corrección: ${fixes[0].title}`;\\n+      }\\n+      return `${prefixLabel}Correcciones y mejoras (${fixes.length} fixes, ${improvements.length} mejoras)`;\\n+    }\\n+\\n+    return `${prefixLabel}Mejoras y optimizaciones`;\\n+  }\\n+\\n+  /**\\n+   * Actualiza versión en todos los archivos de configuración\\n+   */\\n+  private async updateAllVersionFiles(version: string): Promise<void> {\\n+    console.log(`🔄 Sincronizando versión ${version} en todos los archivos...`);\\n+    \\n+    // Actualizar package.json\\n+    await this.updatePackageVersion(version);\\n+    \\n+    // No hay archivos adicionales que actualizar para Better Logger\\n+    \\n+    // Better Logger no requiere sincronización OTA\\n+    \\n+    console.log(`✅ Todas las versiones sincronizadas en ${version}`);\\n+  }\\n+\\n+  /**\\n+   * Actualiza versión en package.json\\n+   */\\n+  private async updatePackageVersion(version: string): Promise<void> {\\n+    const packageJson = JSON.parse(readFileSync(this.packageJsonPath, 'utf-8'));\\n+    packageJson.version = version;\\n+    writeFileSync(this.packageJsonPath, JSON.stringify(packageJson, null, 2) + '\\\\n');\\n+    console.log(`📦 Actualizado package.json → ${version}`);\\n+  }\\n+\\n+  /**\\n+   * Actualiza versión en tauri.conf.json\\n+   * Tauri requiere versionado semántico estricto (sin prefijos)\\n+   */\\n+  private async updateTauriVersion(version: string): Promise<void> {\\n+    const tauriConfig = JSON.parse(readFileSync(this.tauriConfigPath, 'utf-8'));\\n+    \\n+    // Extraer solo la versión base para Tauri (sin prefijos)\\n+    const { baseVersion } = this.parseVersionString(version);\\n+    tauriConfig.version = baseVersion;\\n+    \\n+    writeFileSync(this.tauriConfigPath, JSON.stringify(tauriConfig, null, 2) + '\\\\n');\\n+    console.log(`🦀 Actualizado tauri.conf.json → ${baseVersion} (sin prefijo para semver)`);\\n+  }\\n+\\n+  /**\\n+   * Actualiza versión en Cargo.toml\\n+   * Cargo también requiere versionado semántico estricto (sin prefijos)\\n+   */\\n+  private async updateCargoVersion(version: string): Promise<void> {\\n+    const cargoContent = readFileSync(this.cargoTomlPath, 'utf-8');\\n+    \\n+    // Extraer solo la versión base para Cargo (sin prefijos)\\n+    const { baseVersion } = this.parseVersionString(version);\\n+    const updatedContent = cargoContent.replace(\\n+      /^version\\\\s*=\\\\s*\\\"[^\\\"]*\\\"/m,\\n+      `version = \\\"${baseVersion}\\\"`\\n+    );\\n+    \\n+    writeFileSync(this.cargoTomlPath, updatedContent);\\n+    console.log(`🦀 Actualizado Cargo.toml → ${baseVersion} (sin prefijo para semver)`);\\n+  }\\n+\\n+  /**\\n+   * Sincroniza la nueva versión con el sistema OTA\\n+   * Actualiza versions.json y mapea prefijos a canales OTA\\n+   */\\n+  private async syncWithOTASystem(version: string): Promise<void> {\\n+    const versionsPath = join(this.projectRoot, 'versions.json');\\n+    \\n+    try {\\n+      // Extraer información de la versión\\n+      const { prefix, baseVersion } = this.parseVersionString(version);\\n+      \\n+      // Mapear prefix a canal OTA\\n+      let targetChannel = 'stable';\\n+      if (prefix === 'alpha' || prefix === 'beta') {\\n+        targetChannel = 'beta';\\n+      } else if (prefix === 'pre-alpha' || prefix === 'rc') {\\n+        targetChannel = 'dev';\\n+      }\\n+      \\n+      if (!existsSync(versionsPath)) {\\n+        console.log('⚠️ versions.json no existe, creando estructura inicial...');\\n+        await this.createInitialVersionsFile(baseVersion, targetChannel);\\n+        return;\\n+      }\\n+\\n+      // Leer versions.json actual\\n+      const versionsData = JSON.parse(readFileSync(versionsPath, 'utf-8'));\\n+      const currentDate = new Date().toISOString();\\n+      const buildNumber = currentDate.replace(/[-:.TZ]/g, '').slice(0, 12);\\n+\\n+      // Actualizar versiones principales\\n+      versionsData.frontend.version = baseVersion;\\n+      versionsData.frontend.build = buildNumber;\\n+      versionsData.frontend.lastUpdated = currentDate;\\n+      \\n+      versionsData.backend.version = baseVersion;\\n+      versionsData.backend.build = buildNumber; \\n+      versionsData.backend.lastUpdated = currentDate;\\n+\\n+      // Actualizar canal OTA correspondiente\\n+      versionsData.updateChannels[targetChannel].frontend = version;\\n+      versionsData.updateChannels[targetChannel].backend = version;\\n+\\n+      // Agregar entrada de changelog OTA\\n+      const changelogEntry = {\\n+        version: baseVersion,\\n+        date: new Date().toISOString().split('T')[0],\\n+        changes: [`Actualización automática desde version-manager (${version})`]\\n+      };\\n+\\n+      // Agregar al inicio del changelog (más reciente primero)\\n+      if (!versionsData.frontend.changelog.find((entry: any) => entry.version === baseVersion)) {\\n+        versionsData.frontend.changelog.unshift(changelogEntry);\\n+        versionsData.backend.changelog.unshift(changelogEntry);\\n+      }\\n+\\n+      // Actualizar matriz de compatibilidad\\n+      const compatibilityEntry = versionsData.compatibility.matrix.find((entry: any) => \\n+        entry.backend === baseVersion\\n+      );\\n+      \\n+      if (!compatibilityEntry) {\\n+        versionsData.compatibility.matrix.unshift({\\n+          backend: baseVersion,\\n+          frontend: [baseVersion]\\n+        });\\n+      }\\n+\\n+      // Guardar versions.json actualizado\\n+      writeFileSync(versionsPath, JSON.stringify(versionsData, null, 2));\\n+      console.log(`🔄 Sistema OTA sincronizado → ${baseVersion} (canal: ${targetChannel})`);\\n+      \\n+    } catch (error) {\\n+      console.warn(`⚠️ Error sincronizando sistema OTA: ${error}`);\\n+      console.warn('El versionado principal continuará sin sincronización OTA');\\n+    }\\n+  }\\n+\\n+  /**\\n+   * Crea archivo versions.json inicial cuando no existe\\n+   */\\n+  private async createInitialVersionsFile(version: string, channel: string): Promise<void> {\\n+    const currentDate = new Date().toISOString();\\n+    const buildNumber = currentDate.replace(/[-:.TZ]/g, '').slice(0, 12);\\n+    \\n+    const initialVersions = {\\n+      frontend: {\\n+        version,\\n+        build: buildNumber,\\n+        lastUpdated: currentDate,\\n+        changelog: [{\\n+          version,\\n+          date: new Date().toISOString().split('T')[0],\\n+          changes: ['Inicialización automática del sistema OTA']\\n+        }]\\n+      },\\n+      backend: {\\n+        version,\\n+        build: buildNumber,\\n+        lastUpdated: currentDate,\\n+        minimumFrontend: version,\\n+        changelog: [{\\n+          version,\\n+          date: new Date().toISOString().split('T')[0], \\n+          changes: ['Inicialización automática del sistema OTA']\\n+        }]\\n+      },\\n+      compatibility: {\\n+        matrix: [{\\n+          backend: version,\\n+          frontend: [version]\\n+        }]\\n+      },\\n+      updateChannels: {\\n+        stable: { frontend: version, backend: version },\\n+        beta: { frontend: version, backend: version },\\n+        dev: { frontend: version, backend: version }\\n+      }\\n+    };\\n+\\n+    const versionsPath = join(this.projectRoot, 'versions.json');\\n+    writeFileSync(versionsPath, JSON.stringify(initialVersions, null, 2));\\n+    console.log(`🆕 Archivo versions.json creado con versión inicial: ${version}`);\\n+  }\\n+\\n+  /**\\n+   * Sincroniza todos los archivos de configuración con la versión actual del changelog\\n+   */\\n+  async syncVersionFiles(): Promise<void> {\\n+    console.log('🔄 Sincronizando archivos de configuración con versión actual...\\\\n');\\n+\\n+    try {\\n+      // Cargar datos del changelog\\n+      const changelogData = this.loadChangelogData();\\n+      const currentVersion = changelogData.current_version;\\n+      \\n+      console.log(`📋 Versión actual en changelog: ${currentVersion}`);\\n+\\n+      // Actualizar todos los archivos de configuración\\n+      await this.updateAllVersionFiles(currentVersion);\\n+\\n+      console.log(`\\\\n✅ Sincronización completada exitosamente!`);\\n+      console.log(`📦 Todos los archivos actualizados a: ${currentVersion}`);\\n+\\n+    } catch (error) {\\n+      console.error('❌ Error durante la sincronización:', error);\\n+      throw error;\\n+    }\\n+  }\\n+\\n+  /**\\n+   * Procesa todos los commits existentes (para inicialización)\\n+   */\\n+  async initializeFromHistory(): Promise<void> {\\n+    console.log('🔄 Inicializando changelog desde historial completo...\\\\n');\\n+\\n+    try {\\n+      // Obtener TODOS los commits\\n+      const allCommits = await this.getCommitsSince();\\n+      console.log(`📝 Encontrados ${allCommits.length} commits totales en el historial`);\\n+\\n+      if (allCommits.length === 0) {\\n+        console.log('✅ No hay commits para procesar');\\n+        return;\\n+      }\\n+\\n+      // Agrupar commits por tipo y fecha para crear versiones lógicas\\n+      const versionGroups = this.groupCommitsIntoVersions(allCommits);\\n+      console.log(`📊 Agrupados en ${versionGroups.length} versiones lógicas`);\\n+\\n+      const changelogData: ChangelogData = {\\n+        current_version: '0.1.0',\\n+        versions: []\\n+      };\\n+\\n+      // Procesar cada grupo como una versión\\n+      for (let i = 0; i < versionGroups.length; i++) {\\n+        const group = versionGroups[i];\\n+        const versionNumber = this.generateVersionNumber(i, versionGroups.length);\\n+        \\n+        const allChanges: ChangelogEntry[] = [];\\n+        let technicalNotes = '';\\n+\\n+        for (const commit of group.commits) {\\n+          if (commit.changelog_section) {\\n+            const changes = this.parseChangelogSection(commit.changelog_section);\\n+            allChanges.push(...changes);\\n+          } else {\\n+            let type: ChangelogEntry['type'] = 'improvement';\\n+            if (commit.title.startsWith('feat(')) type = 'feature';\\n+            else if (commit.title.startsWith('fix(')) type = 'fix';\\n+\\n+            allChanges.push({\\n+              type,\\n+              title: commit.title.replace(/^(feat|fix|refactor)\\\\([^)]+\\\\)\\\\s*-\\\\s*/, ''),\\n+              description: commit.title\\n+            });\\n+          }\\n+\\n+          if (commit.technical_section) {\\n+            technicalNotes += `\\\\n${commit.technical_section}`;\\n+          }\\n+        }\\n+\\n+        const version: Version = {\\n+          version: versionNumber,\\n+          date: group.date,\\n+          type: group.type,\\n+          title: group.title,\\n+          changes: allChanges,\\n+          technical_notes: technicalNotes.trim(),\\n+          breaking_changes: allChanges\\n+            .filter(c => c.type === 'breaking')\\n+            .map(c => c.description),\\n+          commit_hash: group.commits[group.commits.length - 1].hash\\n+        };\\n+\\n+        changelogData.versions.push(version);\\n+      }\\n+\\n+      // La versión más reciente es la actual\\n+      if (changelogData.versions.length > 0) {\\n+        changelogData.current_version = changelogData.versions[0].version;\\n+      }\\n+\\n+      // Guardar changelog\\n+      writeFileSync(this.changelogPath, JSON.stringify(changelogData, null, 2));\\n+      console.log(`💾 Changelog inicializado: ${this.changelogPath}`);\\n+\\n+      // Actualizar archivos de configuración\\n+      await this.updateAllVersionFiles(changelogData.current_version);\\n+\\n+      console.log(`\\\\n✅ Inicialización completada!`);\\n+      console.log(`📦 Versión actual: ${changelogData.current_version}`);\\n+      console.log(`📋 Versiones creadas: ${changelogData.versions.length}`);\\n+\\n+    } catch (error) {\\n+      console.error('❌ Error durante la inicialización:', error);\\n+      throw error;\\n+    }\\n+  }\\n+\\n+  /**\\n+   * Agrupa commits en versiones lógicas\\n+   */\\n+  private groupCommitsIntoVersions(commits: CommitInfo[]): Array<{\\n+    commits: CommitInfo[];\\n+    date: string;\\n+    type: Version['type'];\\n+    title: string;\\n+  }> {\\n+    const groups: Array<{\\n+      commits: CommitInfo[];\\n+      date: string;\\n+      type: Version['type'];\\n+      title: string;\\n+    }> = [];\\n+\\n+    // Agrupar por fechas similares y tipos de commits\\n+    let currentGroup: CommitInfo[] = [];\\n+    let currentDate = '';\\n+\\n+    for (let i = 0; i < commits.length; i++) {\\n+      const commit = commits[i];\\n+      \\n+      // Si es primer commit o fecha muy diferente, crear nuevo grupo\\n+      if (!currentDate || this.daysDifference(currentDate, commit.date) > 7 || currentGroup.length >= 10) {\\n+        if (currentGroup.length > 0) {\\n+          groups.push({\\n+            commits: [...currentGroup],\\n+            date: currentDate,\\n+            type: this.determineVersionType(currentGroup),\\n+            title: this.generateGroupTitle(currentGroup)\\n+          });\\n+        }\\n+        currentGroup = [commit];\\n+        currentDate = commit.date;\\n+      } else {\\n+        currentGroup.push(commit);\\n+      }\\n+    }\\n+\\n+    // Agregar último grupo\\n+    if (currentGroup.length > 0) {\\n+      groups.push({\\n+        commits: currentGroup,\\n+        date: currentDate,\\n+        type: this.determineVersionType(currentGroup),\\n+        title: this.generateGroupTitle(currentGroup)\\n+      });\\n+    }\\n+\\n+    return groups.reverse(); // Más recientes primero\\n+  }\\n+\\n+  /**\\n+   * Calcula diferencia en días entre fechas\\n+   */\\n+  private daysDifference(date1: string, date2: string): number {\\n+    const d1 = new Date(date1).getTime();\\n+    const d2 = new Date(date2).getTime();\\n+    return Math.abs((d2 - d1) / (1000 * 60 * 60 * 24));\\n+  }\\n+\\n+  /**\\n+   * Genera título para un grupo de commits\\n+   */\\n+  private generateGroupTitle(commits: CommitInfo[]): string {\\n+    const features = commits.filter(c => c.title.startsWith('feat('));\\n+    const fixes = commits.filter(c => c.title.startsWith('fix('));\\n+    \\n+    if (features.length > 0) {\\n+      return `Nuevas funcionalidades y mejoras`;\\n+    }\\n+    if (fixes.length > 0) {\\n+      return `Correcciones y optimizaciones`;\\n+    }\\n+    return `Mejoras del sistema`;\\n+  }\\n+\\n+  /**\\n+   * Genera número de versión para inicialización\\n+   */\\n+  private generateVersionNumber(index: number, total: number): string {\\n+    if (total === 1) return '1.0.0';\\n+    \\n+    if (index === 0) return '1.0.0'; // Versión más reciente\\n+    if (index < 3) return `0.${9 - index}.0`; // Versiones recientes\\n+    \\n+    // Versiones más antiguas\\n+    const patchVersion = Math.max(1, total - index);\\n+    return `0.1.${patchVersion}`;\\n+  }\\n+}\\n+\\n+// Ejecutar script\\n+if (import.meta.main) {\\n+  const manager = new VersionManager();\\n+  \\n+  const args = process.argv.slice(2);\\n+  const isInit = args.includes('--init') || args.includes('-i');\\n+  const isSync = args.includes('--sync') || args.includes('-s');\\n+  const autoApprove = args.includes('--auto-approve');\\n+  const noSync = args.includes('--no-sync');\\n+  const quiet = args.includes('--quiet');\\n+  \\n+  // Parsear parámetros adicionales\\n+  const typeIndex = args.indexOf('--type');\\n+  const type = typeIndex > -1 && args[typeIndex + 1] ? args[typeIndex + 1] as Version['type'] : undefined;\\n+  \\n+  const prefixIndex = args.indexOf('--prefix');\\n+  const prefix = prefixIndex > -1 ? (args[prefixIndex + 1] || '') : undefined;\\n+  \\n+  // Validar tipo si se especifica\\n+  if (type && !['major', 'minor', 'patch'].includes(type)) {\\n+    console.error(`❌ Tipo de versión inválido: ${type}. Válidos: major, minor, patch`);\\n+    process.exit(1);\\n+  }\\n+\\n+  // Mostrar ayuda\\n+  if (args.includes('--help') || args.includes('-h')) {\\n+    console.log(`\\n+🚀 Version Manager para Better Logger\\n+\\n+Uso:\\n+  node project-utils/version-manager.ts [opciones]\\n+\\n+Opciones:\\n+  --init, -i              Inicializar desde historial completo\\n+  --sync, -s              Sincronizar archivos de configuración\\n+  --auto-approve          Ejecución automática sin confirmaciones\\n+  --no-sync               No sincronizar archivos de configuración\\n+  --quiet                 Ejecución silenciosa (solo errores y resultados)\\n+  --type <tipo>           Forzar tipo de versión (major|minor|patch)\\n+  --prefix <prefijo>      Cambiar prefijo (pre-alpha|alpha|beta|rc|'' para stable)\\n+  --help, -h              Mostrar esta ayuda\\n+\\n+Ejemplos:\\n+  node project-utils/version-manager.ts                         # Análisis automático\\n+  node project-utils/version-manager.ts --auto-approve          # Ejecución silenciosa\\n+  node project-utils/version-manager.ts --type minor --auto-approve\\n+  node project-utils/version-manager.ts --prefix beta --auto-approve\\n+  node project-utils/version-manager.ts --sync --auto-approve\\n+  node project-utils/version-manager.ts --quiet --auto-approve   # Para workflows\\n+`);\\n+    process.exit(0);\\n+  }\\n+\\n+  try {\\n+    if (isInit) {\\n+      await manager.initializeFromHistory();\\n+    } else if (isSync) {\\n+      await manager.syncVersionFiles();\\n+    } else {\\n+      await manager.analyzeAndVersion({ \\n+        type,\\n+        prefix: prefix === '' ? undefined : prefix\\n+      });\\n+    }\\n+  } catch (error) {\\n+    console.error('❌ Error:', error);\\n+    process.exit(1);\\n+  }\\n+}\\n\\\\ No newline at end of file\",\n+      \"lines_added\": 967,\n+      \"lines_removed\": 0,\n+      \"is_binary\": false\n+    },\n+    {\n+      \"path\": \"vite.config.ts\",\n+      \"status\": \"modified\",\n+      \"diff\": \"diff --git a/vite.config.ts b/vite.config.ts\\nindex cd6d8ae..a64a3c2 100644\\n--- a/vite.config.ts\\n+++ b/vite.config.ts\\n@@ -1,62 +1,21 @@\\n-import { defineConfig } from 'vite'\\n+import { defineConfig, UserConfig } from 'vite'\\n import { resolve } from 'path'\\n import dts from 'vite-plugin-dts'\\n \\n-export default defineConfig({\\n+// Configuración base compartida\\n+const baseConfig = {\\n   plugins: [\\n     dts({\\n       include: ['src/**/*'],\\n       exclude: ['src/**/*.test.ts', 'src/**/*.spec.ts', 'src/main.ts', 'src/example.ts'],\\n-      outDir: 'dist/types',\\n       rollupTypes: true,\\n       insertTypesEntry: true,\\n     })\\n   ],\\n+  define: {\\n+    'process.env.NODE_ENV': JSON.stringify('production')\\n+  },\\n   build: {\\n-    lib: {\\n-      entry: {\\n-        // Main entry - Full logger with all features\\n-        index: resolve(__dirname, 'src/index.ts'),\\n-        \\n-        // Core module - Minimal logger without advanced features\\n-        core: resolve(__dirname, 'src/core.ts'),\\n-        \\n-        // Styling module - Advanced visual features\\n-        styling: resolve(__dirname, 'src/styling-module.ts'),\\n-        \\n-        // Exports module - Export and remote handlers  \\n-        exports: resolve(__dirname, 'src/exports-module.ts')\\n-      },\\n-      name: 'BetterLogger',\\n-      formats: ['es', 'cjs'],\\n-      fileName: (format, entryName) => {\\n-        const ext = format === 'cjs' ? 'cjs' : 'js';\\n-        return `${entryName}.${ext}`;\\n-      }\\n-    },\\n-    rollupOptions: {\\n-      external: [],\\n-      output: {\\n-        globals: {},\\n-        exports: 'named',\\n-        preserveModules: false,\\n-        chunkFileNames: 'chunks/[name]-[hash].js',\\n-        manualChunks: (id) => {\\n-          // Separate styling features into their own chunk\\n-          if (id.includes('styling/') || id.includes('banners.ts') || id.includes('themes.ts')) {\\n-            return 'styling';\\n-          }\\n-          // Separate export handlers\\n-          if (id.includes('handlers/Export') || id.includes('handlers/Remote')) {\\n-            return 'exports';\\n-          }\\n-          // Core functionality\\n-          if (id.includes('src/types/') || id.includes('src/utils/')) {\\n-            return 'core';\\n-          }\\n-        }\\n-      }\\n-    },\\n     sourcemap: true,\\n     minify: 'terser',\\n     terserOptions: {\\n@@ -77,8 +36,151 @@ export default defineConfig({\\n       }\\n     },\\n     target: 'es2022'\\n+  }\\n+};\\n+\\n+// Configuraciones específicas por build\\n+const buildConfigs = {\\n+  // Build completa - Incluye todas las funcionalidades\\n+  full: {\\n+    ...baseConfig,\\n+    plugins: [\\n+      dts({\\n+        ...baseConfig.plugins[0].options,\\n+        outDir: 'dist/types',\\n+      })\\n+    ],\\n+    build: {\\n+      ...baseConfig.build,\\n+      outDir: 'dist',\\n+      lib: {\\n+        entry: {\\n+          index: resolve(__dirname, 'src/index.ts'),\\n+          core: resolve(__dirname, 'src/core.ts'),\\n+          styling: resolve(__dirname, 'src/styling-module.ts'),\\n+          exports: resolve(__dirname, 'src/exports-module.ts')\\n+        },\\n+        name: 'BetterLogger',\\n+        formats: ['es', 'cjs'],\\n+        fileName: (format, entryName) => {\\n+          const ext = format === 'cjs' ? 'cjs' : 'js';\\n+          return `${entryName}.${ext}`;\\n+        }\\n+      },\\n+      rollupOptions: {\\n+        external: [],\\n+        output: {\\n+          globals: {},\\n+          exports: 'named',\\n+          preserveModules: false,\\n+          chunkFileNames: 'chunks/[name]-[hash].js'\\n+        }\\n+      }\\n+    }\\n   },\\n-  define: {\\n-    'process.env.NODE_ENV': JSON.stringify('production')\\n+\\n+  // Build modular - Solo core (logger básico)\\n+  core: {\\n+    ...baseConfig,\\n+    plugins: [\\n+      dts({\\n+        ...baseConfig.plugins[0].options,\\n+        outDir: 'dist/modular/core/types',\\n+        include: ['src/core.ts', 'src/constants.ts', 'src/types/**/*'],\\n+      })\\n+    ],\\n+    build: {\\n+      ...baseConfig.build,\\n+      outDir: 'dist/modular/core',\\n+      lib: {\\n+        entry: resolve(__dirname, 'src/core.ts'),\\n+        name: 'BetterLoggerCore',\\n+        formats: ['es', 'cjs'],\\n+        fileName: (format) => {\\n+          const ext = format === 'cjs' ? 'cjs' : 'js';\\n+          return `index.${ext}`;\\n+        }\\n+      },\\n+      rollupOptions: {\\n+        external: [],\\n+        output: {\\n+          globals: {},\\n+          exports: 'named'\\n+        }\\n+      }\\n+    }\\n+  },\\n+\\n+  // Build modular - Solo styling (características visuales)\\n+  styling: {\\n+    ...baseConfig,\\n+    plugins: [\\n+      dts({\\n+        ...baseConfig.plugins[0].options,\\n+        outDir: 'dist/modular/styling/types',\\n+        include: ['src/styling-module.ts', 'src/constants.ts', 'src/types/**/*'],\\n+      })\\n+    ],\\n+    build: {\\n+      ...baseConfig.build,\\n+      outDir: 'dist/modular/styling',\\n+      lib: {\\n+        entry: resolve(__dirname, 'src/styling-module.ts'),\\n+        name: 'BetterLoggerStyling',\\n+        formats: ['es', 'cjs'],\\n+        fileName: (format) => {\\n+          const ext = format === 'cjs' ? 'cjs' : 'js';\\n+          return `index.${ext}`;\\n+        }\\n+      },\\n+      rollupOptions: {\\n+        external: [],\\n+        output: {\\n+          globals: {},\\n+          exports: 'named'\\n+        }\\n+      }\\n+    }\\n+  },\\n+\\n+  // Build modular - Solo exports (handlers de exportación)\\n+  exports: {\\n+    ...baseConfig,\\n+    plugins: [\\n+      dts({\\n+        ...baseConfig.plugins[0].options,\\n+        outDir: 'dist/modular/exports/types',\\n+        include: ['src/exports-module.ts', 'src/constants.ts', 'src/types/**/*'],\\n+      })\\n+    ],\\n+    build: {\\n+      ...baseConfig.build,\\n+      outDir: 'dist/modular/exports',\\n+      lib: {\\n+        entry: resolve(__dirname, 'src/exports-module.ts'),\\n+        name: 'BetterLoggerExports',\\n+        formats: ['es', 'cjs'],\\n+        fileName: (format) => {\\n+          const ext = format === 'cjs' ? 'cjs' : 'js';\\n+          return `index.${ext}`;\\n+        }\\n+      },\\n+      rollupOptions: {\\n+        external: [],\\n+        output: {\\n+          globals: {},\\n+          exports: 'named'\\n+        }\\n+      }\\n+    }\\n   }\\n-})\\n\\\\ No newline at end of file\\n+};\\n+\\n+// Determinar configuración según variable de entorno\\n+const buildMode = process.env.BUILD_MODE || 'full';\\n+\\n+if (!buildConfigs[buildMode]) {\\n+  throw new Error(`Build mode \\\"${buildMode}\\\" not found. Available modes: ${Object.keys(buildConfigs).join(', ')}`);\\n+}\\n+\\n+export default defineConfig(buildConfigs[buildMode] as UserConfig);\\n\\\\ No newline at end of file\",\n+      \"lines_added\": 152,\n+      \"lines_removed\": 50,\n+      \"is_binary\": false\n+    }\n+  ],\n+  \"stats\": {\n+    \"total_files\": 20,\n+    \"total_additions\": 150,\n+    \"total_deletions\": 3,\n+    \"files_by_extension\": {\n+      \"yml\": 9,\n+      \"json\": 1,\n+      \"md\": 1,\n+      \"ts\": 8,\n+      \"js\": 1\n+    },\n+    \"directories_affected\": [\n+      \".github\",\n+      \"...\",\n+      \"package.json\",\n+      \"project-utils\",\n+      \"vite.config.ts\"\n+    ]\n+  },\n+  \"project_context\": {\n+    \"name\": \"OpenTUI\",\n+    \"description\": \"Modern Terminal User Interface Framework\",\n+    \"tech_stack\": [\n+      \"TypeScript\",\n+      \"Node.js\",\n+      \"Terminal UI\",\n+      \"CLI\"\n+    ],\n+    \"target_platform\": \"Cross-platform (macOS, Linux, Windows)\"\n+  },\n+  \"commit_patterns\": \"No commit patterns found\"\n+}\n\\ No newline at end of file",
      "lines_added": 189,
      "lines_removed": 0,
      "is_binary": true
    },
    {
      "path": "project-utils/.temp/commit-proposal-2025-08-29T18-19-51.md",
      "status": "added",
      "diff": "diff --git a/project-utils/.temp/commit-proposal-2025-08-29T18-19-51.md b/project-utils/.temp/commit-proposal-2025-08-29T18-19-51.md\nnew file mode 100644\nindex 0000000..8c61574\n--- /dev/null\n+++ b/project-utils/.temp/commit-proposal-2025-08-29T18-19-51.md\n@@ -0,0 +1,36 @@\n+### **ANÁLISIS PRINCIPAL**\n+\n+Se ha detectado una refactorización masiva y la implementación de un sistema de automatización completo para el proyecto. Los cambios introducen una infraestructura de CI/CD modular y avanzada, junto con un conjunto de herramientas locales (`project-utils`) para automatizar la generación de commits, el versionado y la creación de releases, incluyendo integración con IA (Gemini). El sistema de build ha sido modificado para soportar compilaciones modulares (`full`, `core`, `styling`, `exports`), alineándose con los nuevos workflows de GitHub Actions.\n+\n+---\n+\n+### **Propuesta de Commit #1**\n+\n+```markdown\n+feat(build): Implementación de Sistema de Build y Release Modular con IA\n+\n+Se introduce un sistema de automatización y CI/CD completamente nuevo y avanzado para mejorar la eficiencia del desarrollo y la gestión de releases.\n+\n+Este sistema reemplaza los flujos de trabajo monolíticos anteriores con una arquitectura modular y potente que permite builds y releases independientes para los distintos componentes de la librería (`core`, `styling`, `exports`). Además, se integra un conjunto de herramientas en `project-utils` que automatizan tareas clave como la generación de commits, el versionado semántico y la publicación en GitHub, utilizando Gemini AI para análisis inteligente.\n+\n+<technical>\n+- **Nuevos Workflows de GitHub Actions**: Se añaden flujos de trabajo modulares para CI (`ci-quality.yml`), releases (`releases-core.yml`, `releases-full.yml`), builds nocturnos (`nightly-auto.yml`) y despliegue de la documentación (`docs-demo.yml`). Los workflows antiguos se han movido a `.github/workflows-backup`.\n+- **Utilidades de Proyecto (`project-utils`)**: Se crea un nuevo directorio con scripts de automatización basados en TypeScript:\n+  - `commit-generator.ts`: Genera propuestas de commit analizando los cambios.\n+  - `version-manager.ts`: Gestiona el versionado basado en el historial de commits.\n+  - `auto-release-gemini.ts`: Orquesta releases completas con integración de IA.\n+  - `github-release-manager.ts`: Automatiza la creación de releases en GitHub.\n+  - `prompt-templates.ts`: Centraliza las plantillas para la comunicación con Gemini.\n+- **Configuración de Vite (`vite.config.ts`)**: Refactorizada para soportar builds modulares a través de la variable de entorno `BUILD_MODE`. Ahora genera salidas separadas para cada módulo en `dist/`.\n+- **Scripts de `package.json`**: Actualizados para reflejar la nueva estructura de build modular (`build:core`, `build:styling`, etc.) y para invocar los nuevos scripts de automatización.\n+</technical>\n+\n+<changelog>\n+## [Chore] ⚙️\n+Se ha implementado un sistema de automatización y CI/CD avanzado para mejorar la mantenibilidad y la velocidad de desarrollo del proyecto.\n+</changelog>\n+```\n+\n+---\n+\n+**DECISIÓN**: Se propone un único commit porque todos los cambios están intrínsecamente relacionados y forman una única unidad funcional: la implementación del nuevo sistema de automatización y build. Separarlos resultaría en estados intermedios no funcionales en el repositorio.",
      "lines_added": 36,
      "lines_removed": 0,
      "is_binary": false
    },
    {
      "path": "project-utils/.temp/gemini-prompt.txt",
      "status": "added",
      "diff": "diff --git a/project-utils/.temp/gemini-prompt.txt b/project-utils/.temp/gemini-prompt.txt\nnew file mode 100644\nindex 0000000..b89b032\n--- /dev/null\n+++ b/project-utils/.temp/gemini-prompt.txt\n@@ -0,0 +1,257 @@\n+# Sistema de Análisis Inteligente - Better Logger\n+\n+Eres un asistente especializado en análisis de código y automatización para el proyecto Better Logger. Tu función es proporcionar respuestas estructuradas, precisas y consistentes que puedan ser parseadas automáticamente.\n+\n+## REGLAS CRÍTICAS DE FORMATO\n+\n+1. **FORMATO DE RESPUESTA OBLIGATORIO**: Todas tus respuestas deben seguir exactamente el formato especificado más abajo.\n+2. **CONSISTENCIA**: Mantén la misma estructura sin importar la complejidad del análisis.\n+3. **PARSEABLE**: El formato debe ser fácil de procesar automáticamente con expresiones regulares.\n+4. **BLOQUES MARKDOWN**: Usa ```markdown para bloques de código cuando se especifique.\n+5. **SECCIONES TÉCNICAS**: Siempre incluye las secciones <technical> y <changelog> cuando sea aplicable.\n+\n+## Contexto del Proyecto\n+**Nombre**: Better Logger\n+**Descripción**: State-of-the-art console logger with advanced CSS styling, SVG support, animations, and CLI interface\n+**Versión Actual**: 0.0.3-alpha.0\n+**Stack Tecnológico**: TypeScript, Vite, Browser, CSS-in-JS, SVG\n+**Plataforma Objetivo**: Browser (Chrome, Firefox, Safari, Edge)\n+\n+---\n+\n+\n+# ANÁLISIS DE COMMITS\n+\n+## Datos del Análisis\n+{\n+  \"stats\": {\n+    \"total_files\": 20,\n+    \"total_additions\": 150,\n+    \"total_deletions\": 3,\n+    \"files_by_extension\": {\n+      \"yml\": 9,\n+      \"json\": 1,\n+      \"md\": 1,\n+      \"ts\": 8,\n+      \"js\": 1\n+    },\n+    \"directories_affected\": [\n+      \".github\",\n+      \"...\",\n+      \"package.json\",\n+      \"project-utils\",\n+      \"vite.config.ts\"\n+    ]\n+  },\n+  \"files\": [\n+    {\n+      \"path\": \".github/workflows/ci.yml -> .github/workflows-backup/ci.yml\",\n+      \"status\": \"renamed\",\n+      \"diff_preview\": \"No diff available\"\n+    },\n+    {\n+      \"path\": \".github/workflows-backup/nightly.yml\",\n+      \"status\": \"added\",\n+      \"lines_added\": 196,\n+      \"lines_removed\": 0,\n+      \"is_binary\": false,\n+      \"diff_preview\": \"diff --git a/.github/workflows-backup/nightly.yml b/.github/workflows-backup/nightly.yml\\nnew file mode 100644\\nindex 0000000..2618595\\n--- /dev/null\\n+++ b/.github/workflows-backup/nightly.yml\\n@@ -0,0 +1,196 @@\\n+name: Nightly Builds\\n+\\n+on:\\n+  schedule:\\n+    # Ejecutar cada día a las 3:00 AM UTC\\n+    - cron: '0 3 * * *'\\n+  workflow_dispatch:\\n+    inputs:\\n+      force_build:\\n+        description: 'Forzar build aunque no haya cambios'\\n+        required: false\\n+        default: false\\n+        type: boolean\\n+\\n+env:\\n+  NODE_VERSION: '20'\\n+  REGISTRY_URL: 'https://registry.npmjs.org'\\n+\\n+jobs:\\n+  check-changes:\\n+    runs-on: ubuntu-latest\\n+    outputs:\\n+      has_changes: ${{ steps.changes.outputs.has_changes }}\\n+      last_commit: ${{ steps.changes.outputs.last_commit }}\\n+      commit_count: ${{ steps.changes.outputs.commit_count }}\\n+    \\n+    steps:\\n+      - name: 📥 Checkout code\\n+        uses: actions/checkout@v4\\n+        with:\\n+          fetch-depth: 0\\n+\\n+      - name: 🔍 Check for changes since last nightly\\n+        id: changes\\n+        run: |\\n+          # Buscar último tag nightly\\n+          LAST_NIGHTLY=$(git tag -l \\\"nightly-*\\\" | sort -V | tail -1 || echo \\\"\\\")\\n+          \\n+          if [ -z \\\"$LAST_NIGHTLY\\\" ]; then\\n+            # No hay nightlies previos, verificar desde hace 24 horas\\n+            SINCE_DATE=$(date -d '24 hours ago' --iso-8601)\\n+            COMMITS_COUNT=$(git log --since=\\\"$SINCE_DATE\\\" --oneline | wc -l)\\n+          else\\n+            # Verificar desde último nightl\"\n+    },\n+    {\n+      \"path\": \".github/workflows-backup/release-optimized.yml\",\n+      \"status\": \"added\",\n+      \"lines_added\": 373,\n+      \"lines_removed\": 0,\n+      \"is_binary\": false,\n+      \"diff_preview\": \"diff --git a/.github/workflows-backup/release-optimized.yml b/.github/workflows-backup/release-optimized.yml\\nnew file mode 100644\\nindex 0000000..846bd9b\\n--- /dev/null\\n+++ b/.github/workflows-backup/release-optimized.yml\\n@@ -0,0 +1,373 @@\\n+name: Optimized Release Pipeline\\n+\\n+on:\\n+  workflow_dispatch:\\n+    inputs:\\n+      release_type:\\n+        description: 'Tipo de release'\\n+        required: true\\n+        default: 'auto'\\n+        type: choice\\n+        options:\\n+          - auto\\n+          - patch\\n+          - minor\\n+          - major\\n+          - alpha\\n+          - beta\\n+          - stable\\n+      use_gemini:\\n+        description: 'Usar Gemini AI para versionado'\\n+        required: false\\n+        default: true\\n+        type: boolean\\n+      skip_tests:\\n+        description: 'Saltar tests (no recomendado)'\\n+        required: false\\n+        default: false\\n+        type: boolean\\n+      target_registry:\\n+        description: 'Registro objetivo'\\n+        required: false\\n+        default: 'both'\\n+        type: choice\\n+        options:\\n+          - npm\\n+          - github\\n+          - both\\n+\\n+env:\\n+  NODE_VERSION: '20'\\n+\\n+jobs:\\n+  # ===== VALIDATION & VERSIONING =====\\n+  prepare-release:\\n+    runs-on: ubuntu-latest\\n+    \\n+    outputs:\\n+      version: ${{ steps.version.outputs.version }}\\n+      tag: ${{ steps.version.outputs.tag }}\\n+      is_prerelease: ${{ steps.version.outputs.is_prerelease }}\\n+      changelog: ${{ steps.version.outputs.changelog }}\\n+      release_channel: ${{ steps.v\"\n+    },\n+    {\n+      \"path\": \".github/workflows/release.yml -> .github/workflows-backup/release.yml\",\n+      \"status\": \"renamed\",\n+      \"diff_preview\": \"No diff available\"\n+    },\n+    {\n+      \"path\": \".github/workflows/ci-quality.yml\",\n+      \"status\": \"added\",\n+      \"lines_added\": 357,\n+      \"lines_removed\": 0,\n+      \"is_binary\": false,\n+      \"diff_preview\": \"diff --git a/.github/workflows/ci-quality.yml b/.github/workflows/ci-quality.yml\\nnew file mode 100644\\nindex 0000000..5974ff0\\n--- /dev/null\\n+++ b/.github/workflows/ci-quality.yml\\n@@ -0,0 +1,357 @@\\n+name: CI Quality & Testing\\n+\\n+on:\\n+  push:\\n+    branches: [ main, develop ]\\n+  pull_request:\\n+    branches: [ main, develop ]\\n+  workflow_dispatch:\\n+    inputs:\\n+      run_performance:\\n+        description: 'Ejecutar tests de performance'\\n+        required: false\\n+        default: true\\n+        type: boolean\\n+      run_visual:\\n+        description: 'Ejecutar tests visuales'\\n+        required: false\\n+        default: false\\n+        type: boolean\\n+\\n+env:\\n+  NODE_VERSION: '20'\\n+\\n+jobs:\\n+  # ===== MATRIX TESTING =====\\n+  test-matrix:\\n+    runs-on: ubuntu-latest\\n+    \\n+    strategy:\\n+      fail-fast: false\\n+      matrix:\\n+        node-version: [18, 20, 21]\\n+        build-mode: [full, core, styling, exports]\\n+    \\n+    name: Test Node ${{ matrix.node-version }} - ${{ matrix.build-mode }}\\n+    \\n+    steps:\\n+      - name: 📥 Checkout code\\n+        uses: actions/checkout@v4\\n+        with:\\n+          fetch-depth: 0\\n+\\n+      - name: 📦 Setup Node.js ${{ matrix.node-version }}\\n+        uses: actions/setup-node@v4\\n+        with:\\n+          node-version: ${{ matrix.node-version }}\\n+          cache: 'npm'\\n+\\n+      - name: 🔧 Install dependencies\\n+        run: npm run ci:install\\n+\\n+      - name: 🔍 Type checking\\n+        run: npm run type-check\\n+\\n+      - name: 🏗️ Build ${{ matrix.build-mode }}\\n+ \"\n+    },\n+    {\n+      \"path\": \".github/workflows/docs-demo.yml\",\n+      \"status\": \"added\",\n+      \"lines_added\": 125,\n+      \"lines_removed\": 0,\n+      \"is_binary\": false,\n+      \"diff_preview\": \"diff --git a/.github/workflows/docs-demo.yml b/.github/workflows/docs-demo.yml\\nnew file mode 100644\\nindex 0000000..f7c4cd3\\n--- /dev/null\\n+++ b/.github/workflows/docs-demo.yml\\n@@ -0,0 +1,125 @@\\n+name: Docs & Demo Deployment\\n+\\n+on:\\n+  push:\\n+    branches: [ main ]\\n+    paths: \\n+      - 'docs/**'\\n+      - 'demo.html'\\n+      - 'index.html'\\n+      - 'src/**'\\n+  workflow_dispatch:\\n+\\n+env:\\n+  NODE_VERSION: '20'\\n+\\n+jobs:\\n+  # ===== BUILD DEMO =====\\n+  build-demo:\\n+    runs-on: ubuntu-latest\\n+    \\n+    steps:\\n+      - name: 📥 Checkout code\\n+        uses: actions/checkout@v4\\n+\\n+      - name: 📦 Setup Node.js\\n+        uses: actions/setup-node@v4\\n+        with:\\n+          node-version: ${{ env.NODE_VERSION }}\\n+          cache: 'npm'\\n+\\n+      - name: 🔧 Install dependencies\\n+        run: npm run ci:install\\n+\\n+      - name: 🏗️ Build library for demo\\n+        run: npm run build:full\\n+\\n+      - name: 🏗️ Setup demo structure\\n+        run: |\\n+          mkdir -p _site/docs\\n+          # Copy demo as root\\n+          cp demo.html _site/index.html\\n+          cp index.html _site/dev.html\\n+          cp -r dist/ _site/dist/\\n+          \\n+          # Create demo metadata\\n+          echo \\\"## 📦 Demo Build Info\\\" > _site/build-info.md\\n+          echo \\\"- **Build Date**: $(date)\\\" >> _site/build-info.md\\n+          echo \\\"- **Commit**: ${{ github.sha }}\\\" >> _site/build-info.md\\n+          echo \\\"- **Version**: $(node -p 'require(\\\"./package.json\\\").version')\\\" >> _site/build-info.md\\n+\\n+      - name: 📤 Upload dem\"\n+    },\n+    {\n+      \"path\": \".github/workflows/nightly-auto.yml\",\n+      \"status\": \"added\",\n+      \"lines_added\": 335,\n+      \"lines_removed\": 0,\n+      \"is_binary\": false,\n+      \"diff_preview\": \"diff --git a/.github/workflows/nightly-auto.yml b/.github/workflows/nightly-auto.yml\\nnew file mode 100644\\nindex 0000000..c936f3d\\n--- /dev/null\\n+++ b/.github/workflows/nightly-auto.yml\\n@@ -0,0 +1,335 @@\\n+name: Nightly Builds with Smart Detection\\n+\\n+on:\\n+  schedule:\\n+    # Ejecutar cada día a las 3:00 AM UTC\\n+    - cron: '0 3 * * *'\\n+  workflow_dispatch:\\n+    inputs:\\n+      force_build:\\n+        description: 'Forzar build aunque no haya cambios'\\n+        required: false\\n+        default: false\\n+        type: boolean\\n+      include_prereleases:\\n+        description: 'Incluir cambios de prereleases en detección'\\n+        required: false\\n+        default: false\\n+        type: boolean\\n+\\n+env:\\n+  NODE_VERSION: '20'\\n+\\n+jobs:\\n+  # ===== SMART CHANGE DETECTION =====\\n+  detect-changes:\\n+    runs-on: ubuntu-latest\\n+    outputs:\\n+      has_changes: ${{ steps.changes.outputs.has_changes }}\\n+      change_type: ${{ steps.changes.outputs.change_type }}\\n+      last_commit: ${{ steps.changes.outputs.last_commit }}\\n+      commit_count: ${{ steps.changes.outputs.commit_count }}\\n+      significant_changes: ${{ steps.changes.outputs.significant_changes }}\\n+      files_changed: ${{ steps.changes.outputs.files_changed }}\\n+    \\n+    steps:\\n+      - name: 📥 Checkout code\\n+        uses: actions/checkout@v4\\n+        with:\\n+          fetch-depth: 0\\n+\\n+      - name: 🔍 Analyze changes since last nightly\\n+        id: changes\\n+        run: |\\n+          # Buscar último tag nightly\\n+          LAST_NIGHTLY=$(g\"\n+    },\n+    {\n+      \"path\": \".github/workflows/releases-core.yml\",\n+      \"status\": \"added\",\n+      \"lines_added\": 378,\n+      \"lines_removed\": 0,\n+      \"is_binary\": false,\n+      \"diff_preview\": \"diff --git a/.github/workflows/releases-core.yml b/.github/workflows/releases-core.yml\\nnew file mode 100644\\nindex 0000000..aa4b59c\\n--- /dev/null\\n+++ b/.github/workflows/releases-core.yml\\n@@ -0,0 +1,378 @@\\n+name: Core Modular Releases\\n+\\n+on:\\n+  workflow_dispatch:\\n+    inputs:\\n+      module:\\n+        description: 'Módulo a construir y publicar'\\n+        required: true\\n+        default: 'all'\\n+        type: choice\\n+        options:\\n+          - all\\n+          - core\\n+          - styling\\n+          - exports\\n+          - full\\n+      release_type:\\n+        description: 'Tipo de release'\\n+        required: true\\n+        default: 'patch'\\n+        type: choice\\n+        options:\\n+          - patch\\n+          - minor\\n+          - major\\n+          - alpha\\n+          - beta\\n+      target_registry:\\n+        description: 'Registro objetivo'\\n+        required: false\\n+        default: 'both'\\n+        type: choice\\n+        options:\\n+          - npm\\n+          - github\\n+          - both\\n+      skip_tests:\\n+        description: 'Saltar tests (no recomendado)'\\n+        required: false\\n+        default: false\\n+        type: boolean\\n+\\n+env:\\n+  NODE_VERSION: '20'\\n+\\n+jobs:\\n+  # ===== VALIDATION & VERSIONING =====\\n+  prepare-modular-release:\\n+    runs-on: ubuntu-latest\\n+    \\n+    outputs:\\n+      version: ${{ steps.version.outputs.version }}\\n+      tag: ${{ steps.version.outputs.tag }}\\n+      is_prerelease: ${{ steps.version.outputs.is_prerelease }}\\n+      release_channel: ${{ steps.version.outputs.re\"\n+    },\n+    {\n+      \"path\": \".github/workflows/releases-full.yml\",\n+      \"status\": \"added\",\n+      \"lines_added\": 501,\n+      \"lines_removed\": 0,\n+      \"is_binary\": false,\n+      \"diff_preview\": \"diff --git a/.github/workflows/releases-full.yml b/.github/workflows/releases-full.yml\\nnew file mode 100644\\nindex 0000000..44bab03\\n--- /dev/null\\n+++ b/.github/workflows/releases-full.yml\\n@@ -0,0 +1,501 @@\\n+name: Full Release Pipeline with Gemini AI\\n+\\n+on:\\n+  workflow_dispatch:\\n+    inputs:\\n+      use_gemini:\\n+        description: 'Usar Gemini AI para versionado inteligente'\\n+        required: false\\n+        default: true\\n+        type: boolean\\n+      release_type:\\n+        description: 'Tipo de release (solo si no usar Gemini)'\\n+        required: false\\n+        default: 'auto'\\n+        type: choice\\n+        options:\\n+          - auto\\n+          - patch\\n+          - minor\\n+          - major\\n+          - alpha\\n+          - beta\\n+          - stable\\n+      target_registry:\\n+        description: 'Registro objetivo'\\n+        required: false\\n+        default: 'both'\\n+        type: choice\\n+        options:\\n+          - npm\\n+          - github\\n+          - both\\n+      skip_tests:\\n+        description: 'Saltar tests (no recomendado)'\\n+        required: false\\n+        default: false\\n+        type: boolean\\n+      force_release:\\n+        description: 'Forzar release aunque no haya cambios significativos'\\n+        required: false\\n+        default: false\\n+        type: boolean\\n+\\n+env:\\n+  NODE_VERSION: '20'\\n+\\n+jobs:\\n+  # ===== INTELLIGENT VERSIONING WITH GEMINI =====\\n+  gemini-analysis:\\n+    runs-on: ubuntu-latest\\n+    if: ${{ inputs.use_gemini }}\\n+    \\n+    outputs:\\n+      should_release: $\"\n+    },\n+    {\n+      \"path\": \"package.json\",\n+      \"status\": \"modified\",\n+      \"lines_added\": 23,\n+      \"lines_removed\": 17,\n+      \"is_binary\": false,\n+      \"diff_preview\": \"diff --git a/package.json b/package.json\\nindex 49619ea..bcde04c 100644\\n--- a/package.json\\n+++ b/package.json\\n@@ -29,32 +29,38 @@\\n   \\\"homepage\\\": \\\"https://mks2508.github.io/advanced-logger/\\\",\\n   \\\"scripts\\\": {\\n     \\\"dev\\\": \\\"vite\\\",\\n-    \\\"build\\\": \\\"tsc && vite build\\\",\\n-    \\\"build:watch\\\": \\\"vite build --watch\\\",\\n-    \\\"build:analyze\\\": \\\"vite build --mode analyze\\\",\\n-    \\\"preview\\\": \\\"vite preview\\\",\\n+    \\\"build\\\": \\\"tsc && BUILD_MODE=full vite build\\\",\\n+    \\\"build:full\\\": \\\"tsc && BUILD_MODE=full vite build\\\", \\n+    \\\"build:core\\\": \\\"tsc && BUILD_MODE=core vite build\\\",\\n+    \\\"build:styling\\\": \\\"tsc && BUILD_MODE=styling vite build\\\",\\n+    \\\"build:exports\\\": \\\"tsc && BUILD_MODE=exports vite build\\\",\\n+    \\\"build:all\\\": \\\"npm run build:full && npm run build:core && npm run build:styling && npm run build:exports\\\",\\n     \\\"clean\\\": \\\"rm -rf dist node_modules/.vite\\\",\\n     \\\"type-check\\\": \\\"tsc --noEmit\\\",\\n-    \\\"lint\\\": \\\"echo 'Linting with ESLint...' && exit 0\\\",\\n-    \\\"lint:fix\\\": \\\"echo 'Fixing with ESLint...' && exit 0\\\",\\n     \\\"test\\\": \\\"echo 'Running tests...' && exit 0\\\",\\n-    \\\"test:watch\\\": \\\"echo 'Running tests in watch mode...' && exit 0\\\",\\n-    \\\"test:coverage\\\": \\\"echo 'Running tests with coverage...' && exit 0\\\",\\n     \\\"test:performance\\\": \\\"echo 'Running performance benchmarks...' && exit 0\\\",\\n     \\\"test:visual\\\": \\\"echo 'Running visual tests...' && exit 0\\\",\\n-    \\\"prepublishOnly\\\": \\\"npm run clean && npm run type-check && npm run build\\\",\\n-    \\\"release\\\": \\\"npm version patch && npm publish --access public\\\",\\n-    \\\"release:minor\\\": \\\"npm versio\"\n+    },\n+    {\n+      \"path\": \"project-utils/README.md\",\n+      \"status\": \"added\",\n+      \"lines_added\": 118,\n+      \"lines_removed\": 0,\n+      \"is_binary\": false,\n+      \"diff_preview\": \"diff --git a/project-utils/README.md b/project-utils/README.md\\nnew file mode 100644\\nindex 0000000..e19f929\\n--- /dev/null\\n+++ b/project-utils/README.md\\n@@ -0,0 +1,118 @@\\n+# Project Utils - Sistema de Automatización Completa\\n+\\n+## 🚀 Comandos de Workflow Automatizado\\n+\\n+### Comandos Individuales\\n+```bash\\n+# Commits automatizados\\n+npm run commit:auto           # Commit automático silencioso\\n+npm run commit:ui            # UI interactiva para commits  \\n+npm run commit:generate      # Solo generar propuesta\\n+\\n+# Versionado automatizado\\n+npm run version:auto         # Auto-detectar tipo de versión\\n+npm run version:patch        # Forzar versión patch\\n+npm run version:minor        # Forzar versión minor  \\n+npm run version:major        # Forzar versión major\\n+npm run version:alpha        # Versión alpha\\n+npm run version:beta         # Versión beta\\n+npm run version:stable       # Versión estable\\n+\\n+# GitHub Releases\\n+npm run release:github       # Crear release en GitHub\\n+npm run release:full         # Versión + Build + GitHub + Publish NPM\\n+npm run release:auto         # Release completa con AI\\n+```\\n+\\n+### Workflows Completos\\n+```bash\\n+npm run workflow:full        # Commit + Versión + Build + Release + Publish\\n+npm run workflow:commit      # Solo commit automático\\n+npm run workflow:version     # Versión + Build\\n+npm run workflow:release     # Versión + Build + GitHub Release\\n+```\\n+\\n+## 🔧 Parámetros de Automatización\\n+\\n+### commit-generator.ts\\n+```bash\\n+# Usar propuesta existente\\n+nod\"\n+    },\n+    {\n+      \"path\": \"project-utils/auto-release-gemini.ts\",\n+      \"status\": \"added\",\n+      \"lines_added\": 743,\n+      \"lines_removed\": 0,\n+      \"is_binary\": false,\n+      \"diff_preview\": \"diff --git a/project-utils/auto-release-gemini.ts b/project-utils/auto-release-gemini.ts\\nnew file mode 100755\\nindex 0000000..72a63ba\\n--- /dev/null\\n+++ b/project-utils/auto-release-gemini.ts\\n@@ -0,0 +1,743 @@\\n+#!/usr/bin/env node\\n+\\n+/**\\n+ * Auto-Release Manager con Integración Gemini para Better Logger\\n+ * Sistema avanzado que usa AI para generar documentación y commits inteligentes\\n+ */\\n+\\n+import { spawn } from 'child_process';\\n+import { readFileSync, writeFileSync, existsSync, mkdirSync, readdirSync, statSync } from 'fs';\\n+import { join, dirname } from 'path';\\n+import { createReleasePrompt, BETTER_LOGGER_PROJECT_CONFIG, type GeminiPromptConfig } from './prompt-templates';\\n+\\n+interface ChangelogData {\\n+  current_version: string;\\n+  versions: Array<{\\n+    version: string;\\n+    date: string;\\n+    type: string;\\n+    title: string;\\n+    changes: Array<{\\n+      type: string;\\n+      title: string;\\n+      description: string;\\n+    }>;\\n+    technical_notes: string;\\n+    breaking_changes: string[];\\n+    commit_hash: string;\\n+    prefix?: string;\\n+  }>;\\n+}\\n+\\n+interface ReleaseInfo {\\n+  version: string;\\n+  prefix: string;\\n+  major: number;\\n+  minor: number;\\n+  patch: number;\\n+}\\n+\\n+class AutoReleaseManagerAI {\\n+  private projectRoot: string;\\n+  private releaseDir: string;\\n+  private changelogPath: string;\\n+  private tempDir: string;\\n+  private forceMode: boolean;\\n+  private useAI: boolean;\\n+  private noGitHub: boolean;\\n+  \\n+  // Parámetros de contexto mejorados\\n+  private focusArea: stri\"\n+    },\n+    {\n+      \"path\": \"project-utils/commit-generator.ts\",\n+      \"status\": \"added\",\n+      \"lines_added\": 858,\n+      \"lines_removed\": 0,\n+      \"is_binary\": true,\n+      \"diff_preview\": \"diff --git a/project-utils/commit-generator.ts b/project-utils/commit-generator.ts\\nnew file mode 100755\\nindex 0000000..1e0df07\\n--- /dev/null\\n+++ b/project-utils/commit-generator.ts\\n@@ -0,0 +1,858 @@\\n+#!/usr/bin/env node\\n+\\n+/**\\n+ * Generador Automático de Commits con Gemini CLI\\n+ * Analiza todos los cambios del repositorio y genera commits coherentes\\n+ * siguiendo los patrones establecidos para el proyecto Better Logger\\n+ */\\n+\\n+import { spawn } from 'child_process';\\n+import { readFileSync, writeFileSync, existsSync } from 'fs';\\n+import { createCommitPrompt, GeminiResponseParser, BETTER_LOGGER_PROJECT_CONFIG, type GeminiPromptConfig } from './prompt-templates';\\n+import { join } from 'path';\\n+\\n+interface FileChange {\\n+  path: string;\\n+  status: 'modified' | 'added' | 'deleted' | 'renamed' | 'untracked';\\n+  diff?: string;\\n+  lines_added?: number;\\n+  lines_removed?: number;\\n+  is_binary?: boolean;\\n+}\\n+\\n+interface GitStats {\\n+  total_files: number;\\n+  total_additions: number;\\n+  total_deletions: number;\\n+  files_by_extension: Record<string, number>;\\n+  directories_affected: string[];\\n+}\\n+\\n+interface CommitAnalysis {\\n+  files: FileChange[];\\n+  stats: GitStats;\\n+  project_context: {\\n+    name: string;\\n+    description: string;\\n+    tech_stack: string[];\\n+    target_platform: string;\\n+  };\\n+  commit_patterns: string;\\n+}\\n+\\n+interface CommitProposal {\\n+  title: string;\\n+  description: string;\\n+  technical: string;\\n+  changelog: string;\\n+  files?: string[];\\n+}\\n+\\n+class CommitGenerator {\\n\"\n+    },\n+    {\n+      \"path\": \"project-utils/commit-ui.ts\",\n+      \"status\": \"added\",\n+      \"lines_added\": 246,\n+      \"lines_removed\": 0,\n+      \"is_binary\": false,\n+      \"diff_preview\": \"diff --git a/project-utils/commit-ui.ts b/project-utils/commit-ui.ts\\nnew file mode 100755\\nindex 0000000..bb63e24\\n--- /dev/null\\n+++ b/project-utils/commit-ui.ts\\n@@ -0,0 +1,246 @@\\n+#!/usr/bin/env node\\n+\\n+import { execSync } from \\\"child_process\\\"\\n+import { platform } from \\\"os\\\"\\n+\\n+interface CommitOptions {\\n+  context: string\\n+  workType: string\\n+  affectedComponents: string[]\\n+  scope?: string\\n+  breakingChange?: boolean\\n+  performanceImpact?: string\\n+}\\n+\\n+class CommitUI {\\n+  private platform = platform()\\n+\\n+  async collectCommitInfo(): Promise<CommitOptions> {\\n+    console.log(\\\"🚀 Interactive Commit Generator\\\")\\n+    console.log(\\\"================================\\\")\\n+\\n+    try {\\n+      if (this.platform === \\\"darwin\\\") {\\n+        return await this.macOSDialog()\\n+      } else if (this.platform === \\\"linux\\\") {\\n+        return await this.linuxDialog()\\n+      } else {\\n+        return await this.fallbackDialog()\\n+      }\\n+    } catch (error) {\\n+      console.log(\\\"⚠️ GUI not available, falling back to text input\\\")\\n+      return await this.fallbackDialog()\\n+    }\\n+  }\\n+\\n+  private async macOSDialog(): Promise<CommitOptions> {\\n+    // Create a unified form using AppleScript\\n+    const formScript = `\\n+      const app = Application.currentApplication()\\n+      app.includeStandardAdditions = true\\n+      \\n+      // First get the context text\\n+      const contextResult = app.displayDialog(\\\"📝 Commit Generator\\\\\\\\n\\\\\\\\nDescribe what you implemented/fixed:\\\", {\\n+        defaultAnswer: \\\"\\\",\\n+        withTitl\"\n+    },\n+    {\n+      \"path\": \"project-utils/git-utils.ts\",\n+      \"status\": \"added\",\n+      \"lines_added\": 199,\n+      \"lines_removed\": 0,\n+      \"is_binary\": false,\n+      \"diff_preview\": \"diff --git a/project-utils/git-utils.ts b/project-utils/git-utils.ts\\nnew file mode 100644\\nindex 0000000..d1b860f\\n--- /dev/null\\n+++ b/project-utils/git-utils.ts\\n@@ -0,0 +1,199 @@\\n+/**\\n+ * Utilidades para manejo de Git\\n+ * Funciones auxiliares para el generador de commits\\n+ */\\n+\\n+export interface GitFileStatus {\\n+  path: string;\\n+  staged: boolean;\\n+  unstaged: boolean;\\n+  untracked: boolean;\\n+  deleted: boolean;\\n+  renamed?: string;\\n+}\\n+\\n+export interface CommitInfo {\\n+  hash: string;\\n+  message: string;\\n+  author: string;\\n+  date: string;\\n+}\\n+\\n+/**\\n+ * Parsea la salida de git status --porcelain\\n+ */\\n+export function parseGitStatus(statusOutput: string): GitFileStatus[] {\\n+  const files: GitFileStatus[] = [];\\n+  \\n+  for (const line of statusOutput.split('\\\\n').filter(l => l.trim())) {\\n+    const staged = line[0];\\n+    const unstaged = line[1];\\n+    const filePath = line.substring(3);\\n+\\n+    files.push({\\n+      path: filePath,\\n+      staged: staged !== ' ' && staged !== '?',\\n+      unstaged: unstaged !== ' ',\\n+      untracked: staged === '?' && unstaged === '?',\\n+      deleted: staged === 'D' || unstaged === 'D',\\n+      renamed: staged === 'R' ? filePath.split(' -> ')[1] : undefined,\\n+    });\\n+  }\\n+\\n+  return files;\\n+}\\n+\\n+/**\\n+ * Determina el área funcional de un archivo basado en su ruta\\n+ */\\n+export function getFileArea(filePath: string): string {\\n+  const areas = [\\n+    { pattern: /^src\\\\/components\\\\/|^src\\\\/layouts\\\\//, area: 'ui' },\\n+    { pattern: /^src-tauri\\\\//, area: 'backe\"\n+    },\n+    {\n+      \"path\": \"project-utils/github-release-manager.ts\",\n+      \"status\": \"added\",\n+      \"lines_added\": 458,\n+      \"lines_removed\": 0,\n+      \"is_binary\": false,\n+      \"diff_preview\": \"diff --git a/project-utils/github-release-manager.ts b/project-utils/github-release-manager.ts\\nnew file mode 100644\\nindex 0000000..83dac00\\n--- /dev/null\\n+++ b/project-utils/github-release-manager.ts\\n@@ -0,0 +1,458 @@\\n+#!/usr/bin/env node\\n+\\n+/**\\n+ * GitHub Release Manager para Better Logger\\n+ * Crea releases automáticamente en GitHub con los archivos de distribución\\n+ */\\n+\\n+import { readFileSync, existsSync, readdirSync, statSync } from 'fs';\\n+import { join, basename } from 'path';\\n+\\n+interface ReleaseInfo {\\n+  version: string;\\n+  prefix?: string;\\n+  baseVersion: string;\\n+  path: string;\\n+  files: string[];\\n+  readme: string;\\n+  isPrerelease: boolean;\\n+}\\n+\\n+interface ChangelogEntry {\\n+  type: 'feature' | 'fix' | 'improvement' | 'breaking';\\n+  title: string;\\n+  description: string;\\n+}\\n+\\n+interface VersionData {\\n+  version: string;\\n+  date: string;\\n+  type: 'initial' | 'major' | 'minor' | 'patch';\\n+  title: string;\\n+  changes: ChangelogEntry[];\\n+  technical_notes: string;\\n+  breaking_changes: string[];\\n+}\\n+\\n+class GitHubReleaseManager {\\n+  private projectRoot: string;\\n+  private releasesDir: string;\\n+  private changelogPath: string;\\n+\\n+  constructor() {\\n+    this.projectRoot = process.cwd();\\n+    this.releasesDir = join(this.projectRoot, 'dist');\\n+    this.changelogPath = join(this.projectRoot, 'CHANGELOG.json');\\n+  }\\n+\\n+  /**\\n+   * Ejecuta comando gh CLI\\n+   */\\n+  private async ghCommand(args: string[]): Promise<string> {\\n+    const { spawn } = await import('child_process');\\n+ \"\n+    },\n+    {\n+      \"path\": \"project-utils/prompt-templates.js\",\n+      \"status\": \"added\",\n+      \"lines_added\": 345,\n+      \"lines_removed\": 0,\n+      \"is_binary\": false,\n+      \"diff_preview\": \"diff --git a/project-utils/prompt-templates.js b/project-utils/prompt-templates.js\\nnew file mode 100644\\nindex 0000000..504b6d7\\n--- /dev/null\\n+++ b/project-utils/prompt-templates.js\\n@@ -0,0 +1,345 @@\\n+/**\\n+ * Plantillas de prompts estandarizadas para Gemini CLI\\n+ * @description Asegura respuestas consistentes y parseables en todos los scripts\\n+ * @author TPV EL Haido\\n+ */\\n+/**\\n+ * Configuración base del proyecto OpenTUI\\n+ */\\n+export const TPV_PROJECT_CONFIG = {\\n+    name: 'OpenTUI',\\n+    description: 'Modern Terminal User Interface Framework',\\n+    version: '0.1.0',\\n+    techStack: ['TypeScript', 'Node.js', 'Terminal UI', 'CLI'],\\n+    targetPlatform: 'Cross-platform (macOS, Linux, Windows)',\\n+};\\n+/**\\n+ * Prefijo estándar para todos los prompts de Gemini\\n+ */\\n+const STANDARD_PROMPT_PREFIX = `# Sistema de Análisis Inteligente - OpenTUI\\n+\\n+Eres un asistente especializado en análisis de código y automatización para el proyecto OpenTUI. Tu función es proporcionar respuestas estructuradas, precisas y consistentes que puedan ser parseadas automáticamente.\\n+\\n+## REGLAS CRÍTICAS DE FORMATO\\n+\\n+1. **FORMATO DE RESPUESTA OBLIGATORIO**: Todas tus respuestas deben seguir exactamente el formato especificado más abajo.\\n+2. **CONSISTENCIA**: Mantén la misma estructura sin importar la complejidad del análisis.\\n+3. **PARSEABLE**: El formato debe ser fácil de procesar automáticamente con expresiones regulares.\\n+4. **BLOQUES MARKDOWN**: Usa \\\\`\\\\`\\\\`markdown para bloques de código cuando se especifiq\"\n+    },\n+    {\n+      \"path\": \"project-utils/prompt-templates.ts\",\n+      \"status\": \"added\",\n+      \"lines_added\": 422,\n+      \"lines_removed\": 0,\n+      \"is_binary\": false,\n+      \"diff_preview\": \"diff --git a/project-utils/prompt-templates.ts b/project-utils/prompt-templates.ts\\nnew file mode 100644\\nindex 0000000..8cee1c5\\n--- /dev/null\\n+++ b/project-utils/prompt-templates.ts\\n@@ -0,0 +1,422 @@\\n+/**\\n+ * Plantillas de prompts estandarizadas para Gemini CLI\\n+ * @description Asegura respuestas consistentes y parseables en todos los scripts\\n+ * @author TPV EL Haido\\n+ */\\n+\\n+export interface GeminiPromptConfig {\\n+  /** Contexto base del proyecto */\\n+  projectContext: {\\n+    name: string;\\n+    description: string;\\n+    version: string;\\n+    techStack: string[];\\n+    targetPlatform: string;\\n+  };\\n+  /** Tipo de análisis requerido */\\n+  analysisType: 'commit' | 'workflow' | 'release';\\n+  /** Contexto adicional específico */\\n+  specificContext?: string;\\n+  /** Datos estructurados para el análisis */\\n+  data?: any;\\n+}\\n+\\n+export interface StandardResponseFormat {\\n+  /** Análisis o resumen principal */\\n+  analysis: string;\\n+  /** Recomendaciones o acciones */\\n+  recommendations: string;\\n+  /** Datos estructurados (commits, comandos, etc.) */\\n+  structured_data: any[];\\n+}\\n+\\n+/**\\n+ * Configuración base del proyecto Better Logger\\n+ */\\n+export const BETTER_LOGGER_PROJECT_CONFIG = {\\n+  name: 'Better Logger',\\n+  description: 'State-of-the-art console logger with advanced CSS styling, SVG support, animations, and CLI interface',\\n+  version: '0.0.3-alpha.0',\\n+  techStack: ['TypeScript', 'Vite', 'Browser', 'CSS-in-JS', 'SVG'] as const,\\n+  targetPlatform: 'Browser (Chrome, Firefox, Safari, Edg\"\n+    },\n+    {\n+      \"path\": \"project-utils/version-manager.ts\",\n+      \"status\": \"added\",\n+      \"lines_added\": 967,\n+      \"lines_removed\": 0,\n+      \"is_binary\": false,\n+      \"diff_preview\": \"diff --git a/project-utils/version-manager.ts b/project-utils/version-manager.ts\\nnew file mode 100644\\nindex 0000000..b9639b2\\n--- /dev/null\\n+++ b/project-utils/version-manager.ts\\n@@ -0,0 +1,967 @@\\n+#!/usr/bin/env node\\n+\\n+/**\\n+ * Version Manager para Better Logger\\n+ * Analiza commits, extrae changelog, asigna versiones y actualiza archivos\\n+ */\\n+\\n+import { readFileSync, writeFileSync, existsSync } from 'fs';\\n+import { join } from 'path';\\n+\\n+interface ChangelogEntry {\\n+  type: 'feature' | 'fix' | 'improvement' | 'breaking';\\n+  title: string;\\n+  description: string;\\n+}\\n+\\n+interface Version {\\n+  version: string;\\n+  date: string;\\n+  type: 'initial' | 'major' | 'minor' | 'patch';\\n+  title: string;\\n+  changes: ChangelogEntry[];\\n+  technical_notes: string;\\n+  breaking_changes: string[];\\n+  commit_hash: string;\\n+  prefix?: string; // pre-alpha, alpha, beta, rc, o undefined para stable\\n+}\\n+\\n+interface ChangelogData {\\n+  current_version: string;\\n+  versions: Version[];\\n+}\\n+\\n+interface CommitInfo {\\n+  hash: string;\\n+  date: string;\\n+  title: string;\\n+  description: string;\\n+  technical_section?: string;\\n+  changelog_section?: string;\\n+}\\n+\\n+class VersionManager {\\n+  private projectRoot: string;\\n+  private changelogPath: string;\\n+  private packageJsonPath: string;\\n+  private tauriConfigPath: string;\\n+  private cargoTomlPath: string;\\n+\\n+  constructor() {\\n+    this.projectRoot = process.cwd();\\n+    this.changelogPath = join(this.projectRoot, 'CHANGELOG.json');\\n+    this.packageJsonPath = join\"\n+    },\n+    {\n+      \"path\": \"vite.config.ts\",\n+      \"status\": \"modified\",\n+      \"lines_added\": 152,\n+      \"lines_removed\": 50,\n+      \"is_binary\": false,\n+      \"diff_preview\": \"diff --git a/vite.config.ts b/vite.config.ts\\nindex cd6d8ae..a64a3c2 100644\\n--- a/vite.config.ts\\n+++ b/vite.config.ts\\n@@ -1,62 +1,21 @@\\n-import { defineConfig } from 'vite'\\n+import { defineConfig, UserConfig } from 'vite'\\n import { resolve } from 'path'\\n import dts from 'vite-plugin-dts'\\n \\n-export default defineConfig({\\n+// Configuración base compartida\\n+const baseConfig = {\\n   plugins: [\\n     dts({\\n       include: ['src/**/*'],\\n       exclude: ['src/**/*.test.ts', 'src/**/*.spec.ts', 'src/main.ts', 'src/example.ts'],\\n-      outDir: 'dist/types',\\n       rollupTypes: true,\\n       insertTypesEntry: true,\\n     })\\n   ],\\n+  define: {\\n+    'process.env.NODE_ENV': JSON.stringify('production')\\n+  },\\n   build: {\\n-    lib: {\\n-      entry: {\\n-        // Main entry - Full logger with all features\\n-        index: resolve(__dirname, 'src/index.ts'),\\n-        \\n-        // Core module - Minimal logger without advanced features\\n-        core: resolve(__dirname, 'src/core.ts'),\\n-        \\n-        // Styling module - Advanced visual features\\n-        styling: resolve(__dirname, 'src/styling-module.ts'),\\n-        \\n-        // Exports module - Export and remote handlers  \\n-        exports: resolve(__dirname, 'src/exports-module.ts')\\n-      },\\n-      name: 'BetterLogger',\\n-      formats: ['es', 'cjs'],\\n-      fileName: (format, entryName) => {\\n-        const ext = format === 'cjs' ? 'cjs' : 'js';\\n-        return `${entryName}.${ext}`;\\n-      }\\n-    },\\n-    rollupOptions: {\\n-      external: [],\\n-   \"\n+    }\n+  ],\n+  \"patterns\": \"No commit patterns found\"\n+}\n+\n+## Contexto Adicional\n+Ninguno proporcionado\n+\n+---\n+\n+## FORMATO DE RESPUESTA REQUERIDO\n+\n+Tu respuesta debe seguir EXACTAMENTE esta estructura:\n+\n+### **ANÁLISIS PRINCIPAL**\n+\n+[Descripción general de los cambios detectados]\n+\n+---\n+\n+### **Propuesta de Commit #1**\n+\n+```markdown\n+[prefijo](área - descripción breve)\n+\n+[Descripción completa en castellano de QUÉ se logró y POR QUÉ]\n+\n+<technical>\n+[Detalles técnicos específicos: archivos modificados, funciones añadidas, refactorizaciones, etc.]\n+</technical>\n+\n+<changelog>\n+## [Tipo] [Emoji]\n+[Entrada para changelog de la app, optimizada para mostrar al usuario]\n+</changelog>\n+```\n+\n+### **Propuesta de Commit #2** (solo si es necesario)\n+\n+[Repetir formato anterior]\n+\n+---\n+\n+**DECISIÓN**: [Explicación breve de por qué uno o múltiples commits]\n+\n+\n+\n+---\n+\n+## INSTRUCCIONES FINALES\n+\n+1. **Lee cuidadosamente** toda la información proporcionada\n+2. **Analiza el contexto** y los datos específicos\n+3. **Genera una respuesta** siguiendo EXACTAMENTE el formato especificado\n+4. **Mantén consistencia** en la estructura y sintaxis\n+5. **No desvíes** del formato requerido bajo ninguna circunstancia\n+\n+**IMPORTANTE**: La respuesta debe ser parseada automáticamente. Cualquier desviación del formato especificado causará errores en el sistema.\n\\ No newline at end of file",
      "lines_added": 257,
      "lines_removed": 0,
      "is_binary": false
    },
    {
      "path": "project-utils/.temp/gemini-response.md",
      "status": "added",
      "diff": "diff --git a/project-utils/.temp/gemini-response.md b/project-utils/.temp/gemini-response.md\nnew file mode 100644\nindex 0000000..8c61574\n--- /dev/null\n+++ b/project-utils/.temp/gemini-response.md\n@@ -0,0 +1,36 @@\n+### **ANÁLISIS PRINCIPAL**\n+\n+Se ha detectado una refactorización masiva y la implementación de un sistema de automatización completo para el proyecto. Los cambios introducen una infraestructura de CI/CD modular y avanzada, junto con un conjunto de herramientas locales (`project-utils`) para automatizar la generación de commits, el versionado y la creación de releases, incluyendo integración con IA (Gemini). El sistema de build ha sido modificado para soportar compilaciones modulares (`full`, `core`, `styling`, `exports`), alineándose con los nuevos workflows de GitHub Actions.\n+\n+---\n+\n+### **Propuesta de Commit #1**\n+\n+```markdown\n+feat(build): Implementación de Sistema de Build y Release Modular con IA\n+\n+Se introduce un sistema de automatización y CI/CD completamente nuevo y avanzado para mejorar la eficiencia del desarrollo y la gestión de releases.\n+\n+Este sistema reemplaza los flujos de trabajo monolíticos anteriores con una arquitectura modular y potente que permite builds y releases independientes para los distintos componentes de la librería (`core`, `styling`, `exports`). Además, se integra un conjunto de herramientas en `project-utils` que automatizan tareas clave como la generación de commits, el versionado semántico y la publicación en GitHub, utilizando Gemini AI para análisis inteligente.\n+\n+<technical>\n+- **Nuevos Workflows de GitHub Actions**: Se añaden flujos de trabajo modulares para CI (`ci-quality.yml`), releases (`releases-core.yml`, `releases-full.yml`), builds nocturnos (`nightly-auto.yml`) y despliegue de la documentación (`docs-demo.yml`). Los workflows antiguos se han movido a `.github/workflows-backup`.\n+- **Utilidades de Proyecto (`project-utils`)**: Se crea un nuevo directorio con scripts de automatización basados en TypeScript:\n+  - `commit-generator.ts`: Genera propuestas de commit analizando los cambios.\n+  - `version-manager.ts`: Gestiona el versionado basado en el historial de commits.\n+  - `auto-release-gemini.ts`: Orquesta releases completas con integración de IA.\n+  - `github-release-manager.ts`: Automatiza la creación de releases en GitHub.\n+  - `prompt-templates.ts`: Centraliza las plantillas para la comunicación con Gemini.\n+- **Configuración de Vite (`vite.config.ts`)**: Refactorizada para soportar builds modulares a través de la variable de entorno `BUILD_MODE`. Ahora genera salidas separadas para cada módulo en `dist/`.\n+- **Scripts de `package.json`**: Actualizados para reflejar la nueva estructura de build modular (`build:core`, `build:styling`, etc.) y para invocar los nuevos scripts de automatización.\n+</technical>\n+\n+<changelog>\n+## [Chore] ⚙️\n+Se ha implementado un sistema de automatización y CI/CD avanzado para mejorar la mantenibilidad y la velocidad de desarrollo del proyecto.\n+</changelog>\n+```\n+\n+---\n+\n+**DECISIÓN**: Se propone un único commit porque todos los cambios están intrínsecamente relacionados y forman una única unidad funcional: la implementación del nuevo sistema de automatización y build. Separarlos resultaría en estados intermedios no funcionales en el repositorio.",
      "lines_added": 36,
      "lines_removed": 0,
      "is_binary": false
    },
    {
      "path": "project-utils/README.md",
      "status": "added",
      "diff": "diff --git a/project-utils/README.md b/project-utils/README.md\nnew file mode 100644\nindex 0000000..e19f929\n--- /dev/null\n+++ b/project-utils/README.md\n@@ -0,0 +1,118 @@\n+# Project Utils - Sistema de Automatización Completa\n+\n+## 🚀 Comandos de Workflow Automatizado\n+\n+### Comandos Individuales\n+```bash\n+# Commits automatizados\n+npm run commit:auto           # Commit automático silencioso\n+npm run commit:ui            # UI interactiva para commits  \n+npm run commit:generate      # Solo generar propuesta\n+\n+# Versionado automatizado\n+npm run version:auto         # Auto-detectar tipo de versión\n+npm run version:patch        # Forzar versión patch\n+npm run version:minor        # Forzar versión minor  \n+npm run version:major        # Forzar versión major\n+npm run version:alpha        # Versión alpha\n+npm run version:beta         # Versión beta\n+npm run version:stable       # Versión estable\n+\n+# GitHub Releases\n+npm run release:github       # Crear release en GitHub\n+npm run release:full         # Versión + Build + GitHub + Publish NPM\n+npm run release:auto         # Release completa con AI\n+```\n+\n+### Workflows Completos\n+```bash\n+npm run workflow:full        # Commit + Versión + Build + Release + Publish\n+npm run workflow:commit      # Solo commit automático\n+npm run workflow:version     # Versión + Build\n+npm run workflow:release     # Versión + Build + GitHub Release\n+```\n+\n+## 🔧 Parámetros de Automatización\n+\n+### commit-generator.ts\n+```bash\n+# Usar propuesta existente\n+node project-utils/commit-generator.ts --proposal-file project-utils/.temp/commit-proposal-*.md --auto-approve\n+\n+# Configuración personalizada\n+node project-utils/commit-generator.ts \\\n+  --auto-approve \\\n+  --quiet \\\n+  --work-type feature \\\n+  --affected-components \"core,styling\" \\\n+  --output-dir custom/path\n+```\n+\n+### version-manager.ts\n+```bash\n+# Versionado automático completo\n+node project-utils/version-manager.ts --auto-approve --quiet --type minor\n+```\n+\n+### github-release-manager.ts\n+```bash\n+# Release automática\n+node project-utils/github-release-manager.ts --auto-approve --quiet\n+```\n+\n+## 📁 Archivos Temporales\n+\n+Ubicación: `project-utils/.temp/`\n+- `commit-proposal-YYYYMMDD-HHMMSS.md` - Propuestas de commit\n+- `gemini-prompt.txt` - Prompts enviados a Gemini\n+- `gemini-response.md` - Respuestas de Gemini\n+- `analysis-context.json` - Contexto de análisis\n+\n+## 🔄 Reutilización de Propuestas\n+\n+1. Generar propuesta: `npm run commit:generate`\n+2. Revisar en `project-utils/.temp/commit-proposal-*.md`\n+3. Ejecutar: `node project-utils/commit-generator.ts --proposal-file <ruta> --auto-approve`\n+\n+## 🎯 Casos de Uso\n+\n+### Desarrollo Normal\n+```bash\n+# 1. Hacer cambios en código\n+# 2. Commit automático\n+npm run commit:auto\n+\n+# 3. Cuando esté listo para release\n+npm run workflow:release\n+```\n+\n+### CI/CD Pipeline\n+```bash\n+# Workflow completo automático\n+npm run workflow:full\n+```\n+\n+### Releases Manuales con Control\n+```bash\n+npm run commit:generate     # Revisar propuesta\n+# Editar si necesario\n+npm run commit:auto         # Ejecutar commits\n+npm run version:minor       # Versión específica\n+npm run release:github      # Solo GitHub release\n+```\n+\n+## ⚙️ Configuración\n+\n+Todos los scripts respetan los parámetros:\n+- `--auto-approve`: Ejecución automática sin confirmaciones\n+- `--quiet`: Solo errores y resultados finales\n+- `--no-push`: No hacer push (solo commits locales)\n+- `--force`: Forzar operaciones (recrear releases, etc.)\n+\n+## 🔒 Validaciones de Seguridad\n+\n+- Solo funciona en rama `master`\n+- Validación de conflictos antes de ejecutar  \n+- Commits atómicos con rollback en caso de error\n+- Logs completos de todas las operaciones\n+- Validación de estado del repositorio antes de auto-approve\n\\ No newline at end of file",
      "lines_added": 118,
      "lines_removed": 0,
      "is_binary": false
    },
    {
      "path": "project-utils/auto-release-gemini.ts",
      "status": "added",
      "diff": "diff --git a/project-utils/auto-release-gemini.ts b/project-utils/auto-release-gemini.ts\nnew file mode 100755\nindex 0000000..72a63ba\n--- /dev/null\n+++ b/project-utils/auto-release-gemini.ts\n@@ -0,0 +1,743 @@\n+#!/usr/bin/env node\n+\n+/**\n+ * Auto-Release Manager con Integración Gemini para Better Logger\n+ * Sistema avanzado que usa AI para generar documentación y commits inteligentes\n+ */\n+\n+import { spawn } from 'child_process';\n+import { readFileSync, writeFileSync, existsSync, mkdirSync, readdirSync, statSync } from 'fs';\n+import { join, dirname } from 'path';\n+import { createReleasePrompt, BETTER_LOGGER_PROJECT_CONFIG, type GeminiPromptConfig } from './prompt-templates';\n+\n+interface ChangelogData {\n+  current_version: string;\n+  versions: Array<{\n+    version: string;\n+    date: string;\n+    type: string;\n+    title: string;\n+    changes: Array<{\n+      type: string;\n+      title: string;\n+      description: string;\n+    }>;\n+    technical_notes: string;\n+    breaking_changes: string[];\n+    commit_hash: string;\n+    prefix?: string;\n+  }>;\n+}\n+\n+interface ReleaseInfo {\n+  version: string;\n+  prefix: string;\n+  major: number;\n+  minor: number;\n+  patch: number;\n+}\n+\n+class AutoReleaseManagerAI {\n+  private projectRoot: string;\n+  private releaseDir: string;\n+  private changelogPath: string;\n+  private tempDir: string;\n+  private forceMode: boolean;\n+  private useAI: boolean;\n+  private noGitHub: boolean;\n+  \n+  // Parámetros de contexto mejorados\n+  private focusArea: string;\n+  private targetPlatform: string;\n+  private urgency: string;\n+  private targetAudience: string;\n+  private dependencies: string;\n+\n+  constructor() {\n+    this.projectRoot = process.cwd();\n+    this.releaseDir = join(this.projectRoot, 'dist');\n+    this.changelogPath = join(this.projectRoot, 'CHANGELOG.json');\n+    this.tempDir = join(this.projectRoot, 'project-utils/.temp');\n+    this.forceMode = process.argv.includes('--force');\n+    this.useAI = process.argv.includes('--ai') || !process.argv.includes('--no-ai');\n+    this.noGitHub = process.argv.includes('--no-github');\n+    \n+    // Parsear parámetros de contexto mejorados\n+    this.focusArea = this.getArgValue('--focus') || '';\n+    this.targetPlatform = this.getArgValue('--target-platform') || 'universal';\n+    this.urgency = this.getArgValue('--urgency') || 'normal';\n+    this.targetAudience = this.getArgValue('--audience') || 'public';\n+    this.dependencies = this.getArgValue('--dependencies') || 'both';\n+    \n+    // Crear directorio temporal si no existe\n+    if (!existsSync(this.tempDir)) {\n+      mkdirSync(this.tempDir, { recursive: true });\n+    }\n+  }\n+\n+  /**\n+   * Obtiene valor de un argumento específico\n+   */\n+  private getArgValue(argName: string): string | undefined {\n+    const args = process.argv;\n+    const argIndex = args.indexOf(argName);\n+    if (argIndex > -1 && args[argIndex + 1] && !args[argIndex + 1].startsWith('--')) {\n+      return args[argIndex + 1];\n+    }\n+    return undefined;\n+  }\n+\n+  async run(): Promise<void> {\n+    console.log('🚀 Auto-Release Manager AI iniciado...\\n');\n+    if (this.useAI) {\n+      console.log('🤖 Modo AI activado - Generación inteligente habilitada');\n+    } else {\n+      console.log('📝 Modo básico - Sin generación AI');\n+    }\n+\n+    try {\n+      // Paso 1: Detectar cambios remotos y hacer pull\n+      await this.pullRemoteChanges();\n+\n+      // Paso 2: Instalar dependencias\n+      await this.installNodeDependencies();\n+\n+      // Paso 3: Verificar versión actual del changelog\n+      const currentVersion = this.getCurrentVersion();\n+      console.log(`📋 Versión actual: ${currentVersion}`);\n+\n+      // Paso 4: Verificar última release existente\n+      const latestRelease = this.getLatestRelease();\n+      console.log(`📦 Última release: ${latestRelease || 'ninguna'}`);\n+\n+      // Paso 5: Comparar versiones\n+      if (latestRelease === currentVersion && !this.forceMode) {\n+        console.log('✅ No hay nueva versión para compilar. Release ya existe.');\n+        console.log('💡 Usa --force para forzar la recompilación.');\n+        return;\n+      }\n+\n+      if (this.forceMode && latestRelease === currentVersion) {\n+        console.log('🔧 Modo forzado activado. Regenerando release existente...');\n+      } else {\n+        console.log(`🆕 Nueva versión detectada: ${currentVersion}`);\n+      }\n+      \n+      console.log('⚡ Iniciando proceso de compilación y release...\\n');\n+\n+      // Paso 6: Compilar aplicación\n+      await this.buildApplication();\n+\n+      // Paso 7: Crear estructura de release\n+      const releaseInfo = this.parseVersion(currentVersion);\n+      await this.createReleaseStructure(releaseInfo);\n+\n+      // Paso 8: Copiar archivos de distribución\n+      await this.copyDistFiles(releaseInfo);\n+\n+      // Paso 9: Generar documentación (con AI si está disponible)\n+      await this.generateReleaseDocumentation(releaseInfo);\n+\n+      // Paso 10: Commit y push con AI\n+      await this.commitAndPushReleaseAI(releaseInfo);\n+\n+      // Paso 11: Crear GitHub Release (si está configurado)\n+      await this.createGitHubRelease(releaseInfo);\n+\n+      // Paso 12: Actualizar sistema OTA\n+      await this.updateOTASystem(currentVersion);\n+\n+      console.log('\\n✅ Auto-release AI completado exitosamente!');\n+\n+    } catch (error) {\n+      console.error('❌ Error en auto-release:', error);\n+      process.exit(1);\n+    }\n+  }\n+\n+  private async pullRemoteChanges(): Promise<void> {\n+    console.log('🔄 Verificando cambios remotos...');\n+    \n+    try {\n+      await this.runCommand('git', ['fetch', 'origin']);\n+      const result = await this.runCommand('git', ['log', 'HEAD..origin/master', '--oneline']);\n+      \n+      if (result.stdout.trim()) {\n+        console.log('📥 Cambios remotos detectados. Actualizando...');\n+        \n+        const statusResult = await this.runCommand('git', ['status', '--porcelain']);\n+        if (statusResult.stdout.trim()) {\n+          console.log('💾 Guardando cambios locales...');\n+          await this.runCommand('git', ['stash', 'push', '-m', 'auto-release-stash']);\n+        }\n+        \n+        await this.runCommand('git', ['pull', 'origin', 'master']);\n+        console.log('✅ Actualización completa');\n+      } else {\n+        console.log('✅ Repositorio actualizado');\n+      }\n+    } catch (error) {\n+      throw new Error(`Error al actualizar repositorio: ${error}`);\n+    }\n+  }\n+\n+  private async installNodeDependencies(): Promise<void> {\n+    console.log('📦 Verificando dependencias...');\n+    \n+    try {\n+      const result = await this.runCommand('npm', ['install']);\n+      if (result.stdout.includes('up to date')) {\n+        console.log('✅ Dependencias actualizadas');\n+      } else {\n+        console.log('✅ Dependencias instaladas/actualizadas');\n+      }\n+    } catch (error) {\n+      throw new Error(`Error instalando dependencias: ${error}`);\n+    }\n+  }\n+\n+  private getCurrentVersion(): string {\n+    try {\n+      const changelog: ChangelogData = JSON.parse(readFileSync(this.changelogPath, 'utf8'));\n+      return changelog.current_version;\n+    } catch (error) {\n+      throw new Error(`Error leyendo changelog: ${error}`);\n+    }\n+  }\n+\n+  private getLatestRelease(): string | null {\n+    if (!existsSync(this.releaseDir)) {\n+      return null;\n+    }\n+\n+    const prefixes = readdirSync(this.releaseDir);\n+    let latestVersion = null;\n+    let latestDate = new Date(0);\n+\n+    for (const prefix of prefixes) {\n+      const prefixDir = join(this.releaseDir, prefix);\n+      if (!statSync(prefixDir).isDirectory()) continue;\n+\n+      const versions = readdirSync(prefixDir);\n+      for (const version of versions) {\n+        const versionDir = join(prefixDir, version);\n+        if (!statSync(versionDir).isDirectory()) continue;\n+\n+        const stat = statSync(versionDir);\n+        const modDate = stat.mtime;\n+        \n+        if (modDate > latestDate) {\n+          latestDate = modDate;\n+          latestVersion = `${prefix}-${version}`;\n+        }\n+      }\n+    }\n+\n+    return latestVersion;\n+  }\n+\n+  private parseVersion(version: string): ReleaseInfo {\n+    const match = version.match(/^(pre-alpha-|alpha-|beta-|rc-)?(\\d+)\\.(\\d+)\\.(\\d+)$/);\n+    if (!match) {\n+      throw new Error(`Formato de versión inválido: ${version}`);\n+    }\n+\n+    return {\n+      version: version,\n+      prefix: match[1] ? match[1].slice(0, -1) : 'stable',\n+      major: parseInt(match[2]),\n+      minor: parseInt(match[3]),\n+      patch: parseInt(match[4])\n+    };\n+  }\n+\n+  private async buildApplication(): Promise<void> {\n+    console.log('🔨 Compilando biblioteca...');\n+    \n+    try {\n+      await this.runCommand('npm', ['run', 'clean']);\n+      await this.runCommand('npm', ['run', 'build']);\n+      console.log('✅ Compilación exitosa');\n+      \n+    } catch (error) {\n+      throw new Error(`Error en compilación: ${error}`);\n+    }\n+  }\n+\n+  private async createReleaseStructure(releaseInfo: ReleaseInfo): Promise<void> {\n+    const releaseDir = join(this.releaseDir, releaseInfo.prefix, `${releaseInfo.major}.${releaseInfo.minor}.${releaseInfo.patch}`);\n+    \n+    console.log(`📁 Creando estructura: ${releaseDir}`);\n+    \n+    if (!existsSync(releaseDir)) {\n+      mkdirSync(releaseDir, { recursive: true });\n+    }\n+  }\n+\n+  private async copyDistFiles(releaseInfo: ReleaseInfo): Promise<void> {\n+    const releaseDir = join(this.releaseDir, releaseInfo.prefix, `${releaseInfo.major}.${releaseInfo.minor}.${releaseInfo.patch}`);\n+    const distDir = join(this.projectRoot, 'dist');\n+\n+    console.log('📋 Copiando archivos de distribución...');\n+\n+    try {\n+      const files = readdirSync(distDir);\n+      \n+      for (const file of files) {\n+        const sourceFile = join(distDir, file);\n+        const destFile = join(releaseDir, file);\n+        await this.runCommand('cp', [sourceFile, destFile]);\n+      }\n+\n+      console.log('✅ Archivos de distribución copiados');\n+\n+    } catch (error) {\n+      throw new Error(`Error copiando archivos de distribución: ${error}`);\n+    }\n+  }\n+\n+  private async generateReleaseDocumentation(releaseInfo: ReleaseInfo): Promise<void> {\n+    console.log('📝 Generando documentación de release...');\n+\n+    if (this.useAI) {\n+      await this.generateAIDocumentation(releaseInfo);\n+    } else {\n+      await this.generateBasicREADME(releaseInfo);\n+    }\n+  }\n+\n+  private async generateAIDocumentation(releaseInfo: ReleaseInfo): Promise<void> {\n+    const releaseDir = join(this.releaseDir, releaseInfo.prefix, `${releaseInfo.major}.${releaseInfo.minor}.${releaseInfo.patch}`);\n+    \n+    console.log('🤖 Generando documentación con AI...');\n+\n+    try {\n+      // Leer información del changelog\n+      const changelog: ChangelogData = JSON.parse(readFileSync(this.changelogPath, 'utf8'));\n+      const versionInfo = changelog.versions.find(v => v.version === releaseInfo.version);\n+      \n+      if (!versionInfo) {\n+        throw new Error(`No se encontró información para la versión ${releaseInfo.version}`);\n+      }\n+\n+      // Obtener información de archivos generados\n+      const files = readdirSync(releaseDir);\n+      const fileInfo = this.getFileInfo(releaseDir, files);\n+\n+      // Crear prompt para Gemini\n+      const prompt = this.createDocumentationPrompt(releaseInfo, versionInfo, fileInfo);\n+      \n+      // Guardar el prompt\n+      const promptPath = join(this.tempDir, 'release-doc-prompt.txt');\n+      writeFileSync(promptPath, prompt);\n+\n+      try {\n+        console.log('🚀 Consultando Gemini AI...');\n+        const { spawn } = await import('child_process');\n+        const geminiProcess = spawn('gemini', [], {\n+          cwd: this.projectRoot,\n+          stdio: ['pipe', 'pipe', 'pipe']\n+        });\n+        \n+        geminiProcess.stdin?.write(prompt);\n+        geminiProcess.stdin?.end();\n+        \n+        let aiResponse = '';\n+        let errorOutput = '';\n+        \n+        geminiProcess.stdout?.on('data', (data) => {\n+          aiResponse += data.toString();\n+        });\n+        \n+        geminiProcess.stderr?.on('data', (data) => {\n+          errorOutput += data.toString();\n+        });\n+        \n+        const exitCode = await new Promise((resolve) => {\n+          geminiProcess.on('exit', resolve);\n+        });\n+\n+        if (exitCode !== 0) {\n+          throw new Error(`Gemini CLI error: ${errorOutput || 'Gemini CLI failed'}`);\n+        }\n+        \n+        // Guardar respuesta AI\n+        const responsePath = join(this.tempDir, 'release-doc-response.md');\n+        writeFileSync(responsePath, aiResponse);\n+\n+        // Procesar y usar la respuesta de AI\n+        const processedREADME = this.processAIResponse(aiResponse, releaseInfo, versionInfo, fileInfo);\n+        \n+        const readmePath = join(releaseDir, 'README.md');\n+        writeFileSync(readmePath, processedREADME, 'utf8');\n+        \n+        // Generar documentación adicional si AI lo sugiere\n+        await this.generateAdditionalDocs(aiResponse, releaseDir, releaseInfo);\n+        \n+        console.log('✅ Documentación AI generada exitosamente');\n+\n+      } catch (aiError) {\n+        console.warn('⚠️ Error con AI, usando generación básica:', aiError);\n+        console.log('📝 Prompt guardado en:', promptPath);\n+        await this.generateBasicREADME(releaseInfo);\n+      }\n+\n+    } catch (error) {\n+      throw new Error(`Error generando documentación AI: ${error}`);\n+    }\n+  }\n+\n+  private createDocumentationPrompt(releaseInfo: ReleaseInfo, versionInfo: any, fileInfo: any): string {\n+    const config: GeminiPromptConfig = {\n+      projectContext: {\n+        name: BETTER_LOGGER_PROJECT_CONFIG.name,\n+        description: BETTER_LOGGER_PROJECT_CONFIG.description,\n+        version: releaseInfo.version,\n+        techStack: [...BETTER_LOGGER_PROJECT_CONFIG.techStack],\n+        targetPlatform: BETTER_LOGGER_PROJECT_CONFIG.targetPlatform,\n+      },\n+      analysisType: 'release',\n+      specificContext: `Release ${releaseInfo.version} (${releaseInfo.prefix})`,\n+      data: {\n+        releaseInfo,\n+        versionInfo,\n+        fileInfo,\n+        date: new Date().toISOString().split('T')[0]\n+      }\n+    };\n+\n+    return createReleasePrompt(config);\n+\n+  }\n+\n+  private getFileInfo(releaseDir: string, files: string[]): Record<string, string> {\n+    const fileInfo: Record<string, string> = {};\n+    \n+    for (const file of files) {\n+      if (file !== 'README.md') { // No incluir README que estamos generando\n+        const filePath = join(releaseDir, file);\n+        const stats = statSync(filePath);\n+        const sizeMB = (stats.size / (1024 * 1024)).toFixed(1);\n+        fileInfo[file] = `${sizeMB}MB`;\n+      }\n+    }\n+    \n+    return fileInfo;\n+  }\n+\n+  private processAIResponse(aiResponse: string, releaseInfo: ReleaseInfo, versionInfo: any, fileInfo: any): string {\n+    // Usar directamente la respuesta de AI como README\n+    // En el futuro se puede añadir más procesamiento si es necesario\n+    return aiResponse;\n+  }\n+\n+  private async generateAdditionalDocs(aiResponse: string, releaseDir: string, releaseInfo: ReleaseInfo): Promise<void> {\n+    // Placeholder para generar documentación adicional basada en respuesta AI\n+    // Por ahora no genera documentación adicional\n+    return Promise.resolve();\n+  }\n+\n+  private async generateBasicREADME(releaseInfo: ReleaseInfo): Promise<void> {\n+    // Fallback a generación básica si AI no está disponible\n+    const releaseDir = join(this.releaseDir, releaseInfo.prefix, `${releaseInfo.major}.${releaseInfo.minor}.${releaseInfo.patch}`);\n+    const changelog: ChangelogData = JSON.parse(readFileSync(this.changelogPath, 'utf8'));\n+    const versionInfo = changelog.versions.find(v => v.version === releaseInfo.version);\n+    \n+    const date = new Date().toISOString().split('T')[0];\n+    const files = readdirSync(releaseDir);\n+    const fileInfo = this.getFileInfo(releaseDir, files);\n+\n+    const readme = `# EL Haido TPV - ${releaseInfo.prefix.charAt(0).toUpperCase() + releaseInfo.prefix.slice(1)} ${releaseInfo.major}.${releaseInfo.minor}.${releaseInfo.patch} - ARM64 Release\n+\n+## Información de la Release\n+\n+- **Versión**: ${releaseInfo.version}  \n+- **Fecha**: ${date}\n+- **Arquitectura**: ARM64 (aarch64)\n+- **Plataforma objetivo**: Raspberry Pi 3B+\n+- **Tipo de release**: ${versionInfo?.type} (${versionInfo?.title.toLowerCase()})\n+\n+## Archivos incluidos\n+\n+${Object.entries(fileInfo).map(([file, size]) => `- \\`${file}\\` - ${size}`).join('\\n')}\n+\n+## Instalación Rápida\n+\n+\\`\\`\\`bash\n+sudo dpkg -i \"EL Haido TPV_${releaseInfo.major}.${releaseInfo.minor}.${releaseInfo.patch}_arm64.deb\"\n+sudo apt-get install -f\n+\\`\\`\\`\n+\n+---\n+\n+*Release generada automáticamente el ${date}*\n+`;\n+\n+    const readmePath = join(releaseDir, 'README.md');\n+    writeFileSync(readmePath, readme, 'utf8');\n+    console.log('✅ README básico generado');\n+  }\n+\n+  private async commitAndPushReleaseAI(releaseInfo: ReleaseInfo): Promise<void> {\n+    console.log('📤 Realizando commit y push con AI...');\n+\n+    try {\n+      const releaseDir = join(this.releaseDir, releaseInfo.prefix, `${releaseInfo.major}.${releaseInfo.minor}.${releaseInfo.patch}`);\n+      \n+      // Configurar git si es necesario\n+      try {\n+        await this.runCommand('git', ['config', 'user.name']);\n+      } catch {\n+        await this.runCommand('git', ['config', 'user.email', 'auto-release@build.local']);\n+        await this.runCommand('git', ['config', 'user.name', 'Auto-Release AI System']);\n+      }\n+\n+      // Añadir archivos\n+      await this.runCommand('git', ['add', releaseDir]);\n+      \n+      // Añadir cambios en Cargo.toml si existen\n+      const cargoPath = join(this.projectRoot, 'src-tauri/Cargo.toml');\n+      const cargoLockPath = join(this.projectRoot, 'src-tauri/Cargo.lock');\n+      \n+      if (existsSync(cargoPath)) {\n+        await this.runCommand('git', ['add', cargoPath]);\n+      }\n+      if (existsSync(cargoLockPath)) {\n+        await this.runCommand('git', ['add', cargoLockPath]);\n+      }\n+\n+      // Verificar si hay algo que commitear\n+      const statusResult = await this.runCommand('git', ['status', '--porcelain']);\n+      if (!statusResult.stdout.trim()) {\n+        console.log('⚠️ No hay cambios para commitear.');\n+        return;\n+      }\n+\n+      if (this.useAI) {\n+        // Usar commit-generator con contexto AI mejorado\n+        console.log('🤖 Generando commit automático con AI avanzado...');\n+        const extraContext = this.createCommitContext(releaseInfo);\n+\n+        try {\n+          await this.runCommand('node', ['project-utils/commit-generator.ts'], {\n+            env: {\n+              ...process.env,\n+              COMMIT_EXTRA_CONTEXT: extraContext\n+            }\n+          });\n+          \n+          console.log('✅ Commit AI generado exitosamente');\n+        } catch (error) {\n+          console.warn('⚠️ Error con commit AI, usando manual...');\n+          const commitMessage = this.generateCommitMessage(releaseInfo);\n+          await this.runCommand('git', ['commit', '-m', commitMessage]);\n+        }\n+      } else {\n+        // Commit manual\n+        const commitMessage = this.generateCommitMessage(releaseInfo);\n+        await this.runCommand('git', ['commit', '-m', commitMessage]);\n+      }\n+\n+      // Push\n+      await this.runCommand('git', ['push', 'origin', 'master']);\n+      console.log('✅ Push completado');\n+\n+    } catch (error) {\n+      throw new Error(`Error en commit/push: ${error}`);\n+    }\n+  }\n+\n+  private createCommitContext(releaseInfo: ReleaseInfo): string {\n+    const changelog: ChangelogData = JSON.parse(readFileSync(this.changelogPath, 'utf8'));\n+    const versionInfo = changelog.versions.find(v => v.version === releaseInfo.version);\n+    \n+    return `AUTO-RELEASE CONTEXT - Version ${releaseInfo.version}\n+\n+Esto es un auto-release generado automáticamente para la versión ${releaseInfo.version}.\n+Se han compilado y añadido binarios ARM64 optimizados para Raspberry Pi 3B+.\n+\n+ARCHIVOS INCLUIDOS:\n+- Binario ejecutable nativo ARM64\n+- Paquete Debian (.deb) para fácil instalación\n+- Paquete RPM (.rpm) para distribuciones basadas en RPM\n+- README detallado ${this.useAI ? 'generado con AI' : 'básico'}\n+${this.useAI ? '- Documentación adicional generada por AI' : ''}\n+\n+CARACTERÍSTICAS DE ESTA VERSIÓN:\n+${versionInfo?.changes.slice(0, 5).map(c => `- ${c.type}: ${c.title}`).join('\\n') || '- Versión de mantenimiento'}\n+\n+NOTAS TÉCNICAS:\n+- Compilado nativamente en ARM64 con optimizaciones específicas\n+- OpenSSL configurado para cross-compilation\n+- Todos los tests pasaron exitosamente\n+${this.useAI ? '- Documentación mejorada con inteligencia artificial' : ''}\n+\n+Por favor genera un commit tipo 'release(${releaseInfo.version})' que refleje adecuadamente:\n+1. Que es un auto-release automatizado\n+2. Las características principales de esta versión\n+3. Que incluye binarios optimizados para RPi\n+4. ${this.useAI ? 'Que usa AI para documentación mejorada' : 'Documentación estándar incluida'}\n+\n+Mantén el mensaje profesional pero informativo.`;\n+  }\n+\n+  private generateCommitMessage(releaseInfo: ReleaseInfo): string {\n+    const changelog: ChangelogData = JSON.parse(readFileSync(this.changelogPath, 'utf8'));\n+    const versionInfo = changelog.versions.find(v => v.version === releaseInfo.version);\n+    \n+    const features = versionInfo?.changes\n+      .filter(c => c.type === 'feature')\n+      .slice(0, 3)\n+      .map(c => `✨ ${c.title}`)\n+      .join('\\n') || '';\n+\n+    const improvements = versionInfo?.changes\n+      .filter(c => c.type === 'improvement')\n+      .slice(0, 2) \n+      .map(c => `⚙️ ${c.title}`)\n+      .join('\\n') || '';\n+\n+    return `release(${releaseInfo.version}): auto-release ARM64 ${this.useAI ? 'con AI' : 'binarios'}\n+\n+- Binario ejecutable principal\n+- Paquete Debian (.deb)\n+- Paquete RPM (.rpm)  \n+- README ${this.useAI ? 'generado con AI' : 'automático'}\n+${this.useAI ? '- Documentación adicional AI' : ''}\n+\n+${features ? 'Nuevas características:\\n' + features : ''}\n+${improvements ? '\\nMejoras:\\n' + improvements : ''}\n+\n+${this.useAI ? 'Generado por Auto-Release Manager AI con Gemini.' : 'Generado por Auto-Release Manager.'}\n+Compilado nativamente en ARM64 para RPi3+ con optimizaciones.`;\n+  }\n+\n+  /**\n+   * Crea GitHub Release usando el GitHub Release Manager\n+   */\n+  private async createGitHubRelease(releaseInfo: ReleaseInfo): Promise<void> {\n+    if (this.noGitHub) {\n+      console.log('⏭️ GitHub Release deshabilitado por --no-github');\n+      return;\n+    }\n+\n+    console.log(`🚀 Creando GitHub Release ${this.useAI ? 'con documentación AI' : 'con documentación básica'}...`);\n+\n+    try {\n+      // Verificar que GitHub CLI esté disponible\n+      await this.runCommand('gh', ['--version']);\n+      \n+      // Ejecutar GitHub Release Manager con configuraciones apropiadas\n+      const ghArgs = process.argv.includes('--force') ? ['--force'] : [];\n+      await this.runCommand('node', ['project-utils/github-release-manager.ts', ...ghArgs]);\n+      \n+      console.log(`✅ GitHub Release creado exitosamente ${this.useAI ? '(con mejoras AI)' : ''}`);\n+      \n+    } catch (error) {\n+      console.warn('⚠️ No se pudo crear GitHub Release:', error);\n+      console.log('💡 Verifica que gh CLI esté instalado y autenticado');\n+      console.log('💡 O usa --no-github para deshabilitar GitHub releases');\n+    }\n+  }\n+\n+  /**\n+   * Actualiza el sistema OTA después de un release exitoso\n+   * Sincroniza la nueva versión con los canales OTA apropiados\n+   */\n+  private async updateOTASystem(version: string): Promise<void> {\n+    console.log(`🔄 Actualizando sistema OTA para versión ${version}...`);\n+    \n+    try {\n+      // El version-manager.ts ya sincroniza automáticamente con OTA,\n+      // pero podemos hacer validaciones adicionales aquí\n+      \n+      // Verificar que package.json fue actualizado correctamente\n+      const packagePath = join(this.projectRoot, 'package.json');\n+      if (!existsSync(packagePath)) {\n+        console.warn('⚠️ package.json no existe');\n+        return;\n+      }\n+\n+      const packageData = JSON.parse(readFileSync(packagePath, 'utf-8'));\n+      \n+      if (packageData.version === version) {\n+        console.log(`✅ package.json actualizado correctamente: ${version}`);\n+      } else {\n+        console.warn(`⚠️ Posible desincronización en package.json:`);\n+        console.warn(`   Esperado: ${version}`);\n+        console.warn(`   Actual: ${packageData.version || 'N/A'}`);\n+      }\n+      \n+    } catch (error) {\n+      console.warn(`⚠️ Error verificando package.json: ${error}`);\n+      console.warn('El release continuará sin verificación');\n+    }\n+  }\n+\n+  private async runCommand(command: string, args: string[] = [], options: any = {}): Promise<any> {\n+    return new Promise((resolve, reject) => {\n+      const proc = spawn(command, args, {\n+        cwd: options.cwd || this.projectRoot,\n+        env: options.env || process.env,\n+        stdio: ['pipe', 'pipe', 'pipe']\n+      });\n+\n+      let stdout = '';\n+      let stderr = '';\n+\n+      proc.stdout?.on('data', (data) => {\n+        stdout += data.toString();\n+      });\n+\n+      proc.stderr?.on('data', (data) => {\n+        stderr += data.toString();\n+      });\n+\n+      proc.on('exit', (code) => {\n+        if (code !== 0) {\n+          reject(new Error(`Command failed: ${command} ${args.join(' ')}\\n${stderr}`));\n+        } else {\n+          resolve({ stdout, stderr });\n+        }\n+      });\n+\n+      proc.on('error', (error) => {\n+        reject(error);\n+      });\n+    });\n+  }\n+}\n+\n+// Ejecutar si se llama directamente\n+if (import.meta.main) {\n+  const args = process.argv.slice(2);\n+  \n+  if (args.includes('--help') || args.includes('-h')) {\n+    console.log(`\n+🚀 Auto-Release Manager AI para Better Logger\n+\n+Automatiza el proceso completo con AI para documentación inteligente y commits mejorados.\n+\n+Uso:\n+  node project-utils/auto-release-gemini.ts [opciones]\n+\n+Opciones:\n+  --ai            Activar generación con AI (por defecto)\n+  --no-ai         Deshabilitar AI, usar generación básica\n+  --force         Forzar recompilación aunque la release ya exista\n+  --no-github     Deshabilitar creación automática de GitHub releases\n+  --help, -h      Mostrar esta ayuda\n+\n+Ejemplos:\n+  node project-utils/auto-release-gemini.ts --ai\n+  node project-utils/auto-release-gemini.ts --no-ai\n+  node project-utils/auto-release-gemini.ts --force --no-github\n+`);\n+    process.exit(0);\n+  }\n+  \n+  const manager = new AutoReleaseManagerAI();\n+  await manager.run();\n+}\n+\n+export { AutoReleaseManagerAI };",
      "lines_added": 743,
      "lines_removed": 0,
      "is_binary": false
    },
    {
      "path": "project-utils/commit-generator.ts",
      "status": "added",
      "diff": "diff --git a/project-utils/commit-generator.ts b/project-utils/commit-generator.ts\nnew file mode 100755\nindex 0000000..2e6cda9\n--- /dev/null\n+++ b/project-utils/commit-generator.ts\n@@ -0,0 +1,861 @@\n+#!/usr/bin/env node\n+\n+/**\n+ * Generador Automático de Commits con Gemini CLI\n+ * Analiza todos los cambios del repositorio y genera commits coherentes\n+ * siguiendo los patrones establecidos para el proyecto Better Logger\n+ */\n+\n+import { spawn } from 'child_process';\n+import { readFileSync, writeFileSync, existsSync } from 'fs';\n+import { createCommitPrompt, GeminiResponseParser, BETTER_LOGGER_PROJECT_CONFIG, type GeminiPromptConfig } from './prompt-templates';\n+import { join } from 'path';\n+\n+interface FileChange {\n+  path: string;\n+  status: 'modified' | 'added' | 'deleted' | 'renamed' | 'untracked';\n+  diff?: string;\n+  lines_added?: number;\n+  lines_removed?: number;\n+  is_binary?: boolean;\n+}\n+\n+interface GitStats {\n+  total_files: number;\n+  total_additions: number;\n+  total_deletions: number;\n+  files_by_extension: Record<string, number>;\n+  directories_affected: string[];\n+}\n+\n+interface CommitAnalysis {\n+  files: FileChange[];\n+  stats: GitStats;\n+  project_context: {\n+    name: string;\n+    description: string;\n+    tech_stack: string[];\n+    target_platform: string;\n+  };\n+  commit_patterns: string;\n+}\n+\n+interface CommitProposal {\n+  title: string;\n+  description: string;\n+  technical: string;\n+  changelog: string;\n+  files?: string[];\n+}\n+\n+class CommitGenerator {\n+  private projectRoot: string;\n+  private tempDir: string;\n+  private autoApprove: boolean;\n+  private noPush: boolean;\n+  private quiet: boolean;\n+  private proposalFile?: string;\n+  private outputDir?: string;\n+\n+  constructor() {\n+    this.projectRoot = process.cwd();\n+    this.tempDir = this.getArgValue('--output-dir') || join(this.projectRoot, 'project-utils/.temp');\n+    this.autoApprove = process.argv.includes('--auto-approve');\n+    this.noPush = process.argv.includes('--no-push');\n+    this.quiet = process.argv.includes('--quiet');\n+    this.proposalFile = this.getArgValue('--proposal-file');\n+    this.outputDir = this.getArgValue('--output-dir');\n+    this.ensureTempDir();\n+  }\n+  \n+  private getArgValue(argName: string): string | undefined {\n+    const args = process.argv;\n+    const argIndex = args.indexOf(argName);\n+    if (argIndex > -1 && args[argIndex + 1] && !args[argIndex + 1].startsWith('--')) {\n+      return args[argIndex + 1];\n+    }\n+    return undefined;\n+  }\n+\n+  private ensureTempDir(): void {\n+    if (!existsSync(this.tempDir)) {\n+      const { spawnSync } = require('child_process');\n+      spawnSync('mkdir', ['-p', this.tempDir], { stdio: 'ignore' });\n+    }\n+  }\n+  \n+  private log(message: string): void {\n+    if (!this.quiet) {\n+      console.log(message);\n+    }\n+  }\n+  \n+  private logInfo(message: string): void {\n+    if (!this.quiet) {\n+      console.log(message);\n+    }\n+  }\n+\n+  /**\n+   * Ejecuta un comando git y devuelve el resultado\n+   */\n+  private async gitCommand(args: string[]): Promise<string> {\n+    const { spawnSync } = await import('child_process');\n+    const result = spawnSync('git', args, {\n+      cwd: this.projectRoot,\n+      encoding: 'utf-8',\n+      stdio: ['pipe', 'pipe', 'pipe']\n+    });\n+\n+    if (result.status !== 0) {\n+      const error = result.stderr || 'Git command failed';\n+      throw new Error(`Git error: ${error}`);\n+    }\n+\n+    return (result.stdout || '').trim();\n+  }\n+\n+  /**\n+   * Agrega todos los cambios al staging area\n+   */\n+  private async stageAllChanges(): Promise<void> {\n+    this.log('📦 Agregando todos los cambios al staging area...');\n+    await this.gitCommand(['add', '-A']);\n+  }\n+\n+  /**\n+   * Obtiene el estado actual del repositorio\n+   */\n+  private async getRepositoryStatus(): Promise<FileChange[]> {\n+    this.log('🔍 Analizando estado del repositorio...');\n+    \n+    const statusOutput = await this.gitCommand(['status', '--porcelain']);\n+    const files: FileChange[] = [];\n+\n+    for (const line of statusOutput.split('\\n').filter(l => l.trim())) {\n+      const status = line.substring(0, 2);\n+      const filePath = line.substring(3);\n+\n+      let fileStatus: FileChange['status'];\n+      if (status.includes('A')) fileStatus = 'added';\n+      else if (status.includes('M')) fileStatus = 'modified';\n+      else if (status.includes('D')) fileStatus = 'deleted';\n+      else if (status.includes('R')) fileStatus = 'renamed';\n+      else fileStatus = 'untracked';\n+\n+      files.push({\n+        path: filePath,\n+        status: fileStatus,\n+      });\n+    }\n+\n+    return files;\n+  }\n+\n+  /**\n+   * Obtiene el diff de un archivo específico\n+   */\n+  private async getFileDiff(filePath: string, isStaged: boolean = true): Promise<string> {\n+    try {\n+      const diffArgs = isStaged \n+        ? ['diff', '--cached', '--', filePath]\n+        : ['diff', '--', filePath];\n+      \n+      return await this.gitCommand(diffArgs);\n+    } catch (error) {\n+      // Si es un archivo nuevo o binario, devolver información básica\n+      try {\n+        const showArgs = ['show', `HEAD:${filePath}`];\n+        await this.gitCommand(showArgs);\n+        return `New file: ${filePath}`;\n+      } catch {\n+        return `Binary or new file: ${filePath}`;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Obtiene estadísticas del repositorio\n+   */\n+  private async getGitStats(): Promise<GitStats> {\n+    this.log('📊 Calculando estadísticas de cambios...');\n+    \n+    try {\n+      const diffStat = await this.gitCommand(['diff', '--cached', '--stat']);\n+      const lines = diffStat.split('\\n').filter(l => l.trim());\n+      \n+      let totalFiles = 0;\n+      let totalAdditions = 0;\n+      let totalDeletions = 0;\n+      const filesByExtension: Record<string, number> = {};\n+      const directoriesAffected = new Set<string>();\n+\n+      for (const line of lines) {\n+        if (line.includes('|')) {\n+          totalFiles++;\n+          const filePath = line.split('|')[0].trim();\n+          \n+          // Extraer extensión\n+          const ext = filePath.split('.').pop() || 'no-ext';\n+          filesByExtension[ext] = (filesByExtension[ext] || 0) + 1;\n+          \n+          // Extraer directorio\n+          const dir = filePath.split('/')[0];\n+          directoriesAffected.add(dir);\n+          \n+          // Extraer adiciones y eliminaciones\n+          const stats = line.split('|')[1];\n+          const plusCount = (stats.match(/\\+/g) || []).length;\n+          const minusCount = (stats.match(/\\-/g) || []).length;\n+          totalAdditions += plusCount;\n+          totalDeletions += minusCount;\n+        }\n+      }\n+\n+      return {\n+        total_files: totalFiles,\n+        total_additions: totalAdditions,\n+        total_deletions: totalDeletions,\n+        files_by_extension: filesByExtension,\n+        directories_affected: Array.from(directoriesAffected),\n+      };\n+    } catch (error) {\n+      return {\n+        total_files: 0,\n+        total_additions: 0,\n+        total_deletions: 0,\n+        files_by_extension: {},\n+        directories_affected: [],\n+      };\n+    }\n+  }\n+\n+  /**\n+   * Genera el contexto completo para Gemini CLI\n+   */\n+  private async generateAnalysisContext(): Promise<CommitAnalysis> {\n+    this.log('🧠 Generando contexto de análisis...');\n+\n+    await this.stageAllChanges();\n+    \n+    const files = await this.getRepositoryStatus();\n+    const stats = await this.getGitStats();\n+\n+    // Obtener diffs para cada archivo\n+    for (const file of files) {\n+      if (file.status !== 'deleted') {\n+        try {\n+          file.diff = await this.getFileDiff(file.path);\n+          \n+          // Calcular líneas agregadas/eliminadas del diff\n+          if (file.diff) {\n+            file.lines_added = (file.diff.match(/^\\+[^+]/gm) || []).length;\n+            file.lines_removed = (file.diff.match(/^-[^-]/gm) || []).length;\n+            file.is_binary = file.diff.includes('Binary files differ');\n+          }\n+        } catch (error) {\n+          file.diff = `Error getting diff: ${error}`;\n+        }\n+      }\n+    }\n+\n+    // Cargar patrones de commit\n+    const patternsPath = join(this.projectRoot, 'commit-templates/commit-patterns.md');\n+    const commitPatterns = existsSync(patternsPath) \n+      ? readFileSync(patternsPath, 'utf-8')\n+      : 'No commit patterns found';\n+\n+    return {\n+      files,\n+      stats,\n+      project_context: {\n+        name: 'OpenTUI',\n+        description: 'Modern Terminal User Interface Framework',\n+        tech_stack: ['TypeScript', 'Node.js', 'Terminal UI', 'CLI'],\n+        target_platform: 'Cross-platform (macOS, Linux, Windows)',\n+      },\n+      commit_patterns: commitPatterns,\n+    };\n+  }\n+\n+  private createStandardPrompt(analysis: CommitAnalysis, extraContext: string = ''): string {\n+    const config: GeminiPromptConfig = {\n+      projectContext: {\n+        name: BETTER_LOGGER_PROJECT_CONFIG.name,\n+        description: BETTER_LOGGER_PROJECT_CONFIG.description,\n+        version: BETTER_LOGGER_PROJECT_CONFIG.version,\n+        techStack: [...BETTER_LOGGER_PROJECT_CONFIG.techStack],\n+        targetPlatform: BETTER_LOGGER_PROJECT_CONFIG.targetPlatform,\n+      },\n+      analysisType: 'commit',\n+      specificContext: extraContext,\n+      data: {\n+        stats: analysis.stats,\n+        files: analysis.files.map(file => ({\n+          path: file.path,\n+          status: file.status,\n+          lines_added: file.lines_added,\n+          lines_removed: file.lines_removed,\n+          is_binary: file.is_binary,\n+          diff_preview: file.diff?.substring(0, 1500) || 'No diff available'\n+        })),\n+        patterns: analysis.commit_patterns\n+      }\n+    };\n+\n+    return createCommitPrompt(config);\n+  }\n+\n+  private createExhaustivePrompt(analysis: CommitAnalysis, extraContext: string = ''): string {\n+    const config: GeminiPromptConfig = {\n+      projectContext: {\n+        name: BETTER_LOGGER_PROJECT_CONFIG.name,\n+        description: BETTER_LOGGER_PROJECT_CONFIG.description,\n+        version: BETTER_LOGGER_PROJECT_CONFIG.version,\n+        techStack: [...BETTER_LOGGER_PROJECT_CONFIG.techStack],\n+        targetPlatform: BETTER_LOGGER_PROJECT_CONFIG.targetPlatform,\n+      },\n+      analysisType: 'commit',\n+      specificContext: `MODO EXHAUSTIVO: Análisis profundo requerido.\\n${extraContext}`,\n+      data: {\n+        mode: 'exhaustive',\n+        stats: analysis.stats,\n+        files: analysis.files.map(file => ({\n+          path: file.path,\n+          status: file.status,\n+          lines_added: file.lines_added,\n+          lines_removed: file.lines_removed,\n+          is_binary: file.is_binary,\n+          diff_preview: file.diff?.substring(0, 2000) || 'No diff available'\n+        })),\n+        patterns: analysis.commit_patterns\n+      }\n+    };\n+\n+    return createCommitPrompt(config);\n+  }\n+\n+  /**\n+   * Construye contexto mejorado con parámetros adicionales\n+   */\n+  private buildEnhancedContext(\n+    extraContext: string,\n+    contextDescription: string,\n+    workType: string,\n+    affectedComponents: string,\n+    performanceImpact: string,\n+    breakingChanges: string\n+  ): string {\n+    let enhancedContext = extraContext;\n+\n+    const contextParts = [];\n+\n+    if (contextDescription) {\n+      contextParts.push(`**Descripción del trabajo**: ${contextDescription}`);\n+    }\n+\n+    if (workType) {\n+      const workTypeDescriptions = {\n+        'feature': 'Nueva funcionalidad o capacidad',\n+        'bugfix': 'Corrección de error o fallo',\n+        'refactor': 'Mejora del código sin cambios de funcionalidad',\n+        'docs': 'Actualización de documentación',\n+        'performance': 'Optimización de rendimiento',\n+        'ui': 'Cambios en interfaz de usuario',\n+        'api': 'Modificaciones en API o endpoints',\n+        'security': 'Mejoras de seguridad',\n+        'test': 'Adición o modificación de tests'\n+      };\n+      contextParts.push(`**Tipo de trabajo**: ${workType} - ${workTypeDescriptions[workType] || workType}`);\n+    }\n+\n+    if (affectedComponents) {\n+      contextParts.push(`**Componentes afectados**: ${affectedComponents}`);\n+    }\n+\n+    if (performanceImpact) {\n+      const performanceDescriptions = {\n+        'mejora': 'Este cambio mejora el rendimiento del sistema',\n+        'neutro': 'Este cambio no afecta significativamente el rendimiento',\n+        'regresion': 'Este cambio puede impactar negativamente el rendimiento (justificado por otros beneficios)'\n+      };\n+      contextParts.push(`**Impacto en rendimiento**: ${performanceImpact} - ${performanceDescriptions[performanceImpact] || performanceImpact}`);\n+    }\n+\n+    if (breakingChanges) {\n+      const breakingDescription = breakingChanges.toLowerCase() === 'si' \n+        ? 'Este cambio introduce cambios que rompen compatibilidad hacia atrás'\n+        : 'Este cambio mantiene compatibilidad hacia atrás';\n+      contextParts.push(`**Cambios incompatibles**: ${breakingChanges} - ${breakingDescription}`);\n+    }\n+\n+    if (contextParts.length > 0) {\n+      const contextSection = contextParts.join('\\n');\n+      enhancedContext = enhancedContext \n+        ? `${enhancedContext}\\n\\n## Contexto Estructurado\\n\\n${contextSection}`\n+        : `## Contexto Estructurado\\n\\n${contextSection}`;\n+    }\n+\n+    return enhancedContext;\n+  }\n+\n+  /**\n+   * Invoca Gemini CLI con el contexto de análisis\n+   */\n+  private async analyzeWithGemini(analysis: CommitAnalysis, exhaustive: boolean = false, extraContext: string = ''): Promise<string> {\n+    this.log(`🤖 Analizando cambios con Gemini CLI... ${exhaustive ? '(Modo Exhaustivo)' : ''}`);\n+\n+    const prompt = exhaustive\n+      ? this.createExhaustivePrompt(analysis, extraContext)\n+      : this.createStandardPrompt(analysis, extraContext);\n+\n+    // Guardar el contexto en un archivo temporal\n+    const contextPath = join(this.tempDir, 'analysis-context.json');\n+    writeFileSync(contextPath, JSON.stringify(analysis, null, 2));\n+\n+    // Guardar el prompt en un archivo temporal\n+    const promptPath = join(this.tempDir, 'gemini-prompt.txt');\n+    writeFileSync(promptPath, prompt);\n+\n+    try {\n+      // Ejecutar Gemini CLI\n+      const geminiResult = Bun.spawnSync(['gemini'], {\n+        cwd: this.projectRoot,\n+        stdin: Buffer.from(prompt) as any,\n+        stdout: 'pipe',\n+        stderr: 'pipe',\n+      });\n+\n+      if (geminiResult.exitCode !== 0) {\n+        const error = geminiResult.stderr?.toString() || 'Gemini CLI failed';\n+        throw new Error(`Gemini CLI error: ${error}`);\n+      }\n+\n+      const response = geminiResult.stdout?.toString() || '';\n+      \n+      // Guardar la respuesta\n+      const responsePath = join(this.tempDir, 'gemini-response.md');\n+      writeFileSync(responsePath, response);\n+\n+      return response;\n+    } catch (error) {\n+      console.error('❌ Error ejecutando Gemini CLI:', error);\n+      console.error('💡 Verifica que Gemini CLI esté instalado y configurado');\n+      console.log('📝 Contexto guardado en:', contextPath);\n+      console.log('📝 Prompt guardado en:', promptPath);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * Guarda la propuesta de commits\n+   */\n+  private saveCommitProposal(analysis: string): string {\n+    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');\n+    const proposalPath = join(this.tempDir, `commit-proposal-${timestamp}.md`);\n+    \n+    writeFileSync(proposalPath, analysis);\n+    return proposalPath;\n+  }\n+\n+  /**\n+   * Parsea propuestas de commit de la respuesta de Gemini\n+   */\n+  private parseCommitProposals(aiResponse: string): CommitProposal[] {\n+    // Usar el parser estandarizado\n+    const parsedProposals = GeminiResponseParser.parseCommitProposals(aiResponse);\n+    \n+    // Convertir al formato interno\n+    return parsedProposals.map(proposal => ({\n+      title: proposal.title,\n+      description: proposal.description,\n+      technical: proposal.technical,\n+      changelog: proposal.changelog,\n+      files: [] // Usar todos los archivos disponibles\n+    }));\n+  }\n+\n+  /**\n+   * Ejecuta un commit individual\n+   */\n+  private async executeCommit(proposal: CommitProposal, allFiles: FileChange[]): Promise<boolean> {\n+    this.log(`\\n🔨 Ejecutando commit: ${proposal.title}`);\n+    \n+    try {\n+      // Si no hay archivos específicos, usar todos los archivos disponibles (excluyendo temp files)\n+      const targetFiles = proposal.files && proposal.files.length > 0 \n+        ? proposal.files \n+        : allFiles\n+            .map(f => f.path)\n+            .filter(path => !path.includes('.temp/') && !path.startsWith('.release-notes-'));\n+      \n+      // Agregar archivos específicos al staging area\n+      for (const file of targetFiles) {\n+        try {\n+          await this.gitCommand(['add', file]);\n+          this.log(`  ✓ Agregado: ${file}`);\n+        } catch (error) {\n+          console.warn(`  ⚠️ No se pudo agregar ${file}:`, error);\n+        }\n+      }\n+      \n+      // Verificar que hay algo para commitear\n+      try {\n+        const statusResult = await this.gitCommand(['diff', '--cached', '--name-only']);\n+        if (!statusResult.trim()) {\n+          console.warn(`  ⚠️ No hay cambios staged para este commit`);\n+          return false;\n+        }\n+      } catch (error) {\n+        // Fallback si diff --cached no funciona\n+        this.log(`  🔍 Verificando staging area...`);\n+      }\n+      \n+      // Crear mensaje de commit\n+      let commitMessage = proposal.title;\n+      if (proposal.description) {\n+        commitMessage += `\\n\\n${proposal.description}`;\n+      }\n+      if (proposal.technical) {\n+        commitMessage += `\\n\\n<technical>\\n${proposal.technical}\\n</technical>`;\n+      }\n+      if (proposal.changelog) {\n+        commitMessage += `\\n\\n<changelog>\\n${proposal.changelog}\\n</changelog>`;\n+      }\n+      \n+      // Ejecutar commit\n+      await this.gitCommand(['commit', '-m', commitMessage]);\n+      this.log(`  ✅ Commit exitoso`);\n+      return true;\n+      \n+    } catch (error) {\n+      console.error(`  ❌ Error en commit:`, error);\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Ejecuta push de todos los commits\n+   */\n+  private async pushCommits(): Promise<void> {\n+    if (this.noPush) {\n+      this.log('⏭️ Push deshabilitado por --no-push');\n+      return;\n+    }\n+    \n+    this.log('\\n📤 Pushing commits to remote...');\n+    \n+    try {\n+      // Detectar rama actual para push\n+      const currentBranch = await this.gitCommand(['branch', '--show-current']);\n+      await this.gitCommand(['push', 'origin', currentBranch]);\n+      this.log('✅ Push completado exitosamente');\n+    } catch (error) {\n+      console.error('❌ Error en push:', error);\n+      this.log('💡 Los commits están en tu repositorio local');\n+    }\n+  }\n+\n+  /**\n+   * Valida que auto-approve es seguro de ejecutar\n+   */\n+  private async validateAutoApprove(): Promise<boolean> {\n+    try {\n+      // Verificar que estamos en la rama correcta (master o main)\n+      const currentBranch = await this.gitCommand(['branch', '--show-current']);\n+      const validBranches = ['master', 'main'];\n+      if (!validBranches.includes(currentBranch)) {\n+        console.warn(`⚠️ No estás en una rama principal válida (actual: ${currentBranch}, válidas: ${validBranches.join(', ')})`);\n+        return false;\n+      }\n+      \n+      // Verificar que el repositorio está limpio (sin conflictos)\n+      const statusOutput = await this.gitCommand(['status', '--porcelain']);\n+      const conflicts = statusOutput.split('\\n').filter(line => line.startsWith('UU'));\n+      if (conflicts.length > 0) {\n+        console.error('❌ Hay conflictos de merge sin resolver');\n+        return false;\n+      }\n+      \n+      return true;\n+    } catch (error) {\n+      console.error('❌ Error validando repositorio:', error);\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Ejecuta commits desde un archivo de propuesta existente\n+   */\n+  private async executeFromProposalFile(proposalPath: string): Promise<void> {\n+    this.log(`📂 Cargando propuesta desde: ${proposalPath}`);\n+    \n+    try {\n+      const proposalContent = readFileSync(proposalPath, 'utf-8');\n+      const proposals = this.parseCommitProposals(proposalContent);\n+      \n+      if (proposals.length === 0) {\n+        console.error('❌ No se encontraron commits válidos en el archivo de propuesta');\n+        return;\n+      }\n+      \n+      this.log(`📦 Encontrados ${proposals.length} commits en la propuesta:`);\n+      proposals.forEach((p, i) => {\n+        this.log(`  ${i + 1}. ${p.title}`);\n+      });\n+      \n+      if (!this.autoApprove) {\n+        console.log('\\n💡 Usa --auto-approve para ejecutar estos commits automáticamente');\n+        return;\n+      }\n+      \n+      // Obtener archivos actuales para el contexto\n+      const files = await this.getRepositoryStatus();\n+      \n+      let successfulCommits = 0;\n+      \n+      for (let i = 0; i < proposals.length; i++) {\n+        const proposal = proposals[i];\n+        const success = await this.executeCommit(proposal, files);\n+        if (success) {\n+          successfulCommits++;\n+        } else {\n+          console.error(`❌ Falló commit ${i + 1}: ${proposal.title}`);\n+        }\n+      }\n+      \n+      this.log(`\\n📊 Resultados: ${successfulCommits}/${proposals.length} commits exitosos`);\n+      \n+      if (successfulCommits > 0) {\n+        await this.pushCommits();\n+      }\n+      \n+      this.log('\\n✅ Ejecución desde archivo completada');\n+      \n+    } catch (error) {\n+      console.error('❌ Error leyendo archivo de propuesta:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * Ejecuta el generador completo\n+   */\n+  async generate(): Promise<void> {\n+    // Si se especifica un archivo de propuesta existente, usarlo directamente\n+    if (this.proposalFile && existsSync(this.proposalFile)) {\n+      return this.executeFromProposalFile(this.proposalFile);\n+    }\n+\n+    this.log(`🚀 Iniciando generador de commits...${this.autoApprove ? ' (AUTO-APPROVE MODE)' : ''}\\n`);\n+\n+    const args = process.argv.slice(2);\n+    const isExhaustive = args.includes('-exhaustive');\n+\n+    // Parsear parámetros de contexto mejorados\n+    let extraContext = '';\n+    let workType = '';\n+    let contextDescription = '';\n+    let affectedComponents = '';\n+    let performanceImpact = '';\n+    let breakingChanges = '';\n+\n+    const extraIndex = args.indexOf('--extra');\n+    if (extraIndex > -1 && args[extraIndex + 1]) {\n+        extraContext = args[extraIndex + 1];\n+        this.log(`💬 Contexto extra proporcionado por el usuario.`);\n+    } else if (extraIndex > -1) {\n+        console.warn('⚠️ El parámetro --extra requiere un valor de texto después.');\n+    }\n+\n+    const contextIndex = args.indexOf('--context');\n+    if (contextIndex > -1 && args[contextIndex + 1]) {\n+        contextDescription = args[contextIndex + 1];\n+        this.log(`📋 Contexto del trabajo: ${contextDescription}`);\n+    }\n+\n+    const workTypeIndex = args.indexOf('--work-type');\n+    if (workTypeIndex > -1 && args[workTypeIndex + 1]) {\n+        workType = args[workTypeIndex + 1];\n+        this.log(`🏷️ Tipo de trabajo: ${workType}`);\n+    }\n+\n+    const componentsIndex = args.indexOf('--affected-components');\n+    if (componentsIndex > -1 && args[componentsIndex + 1]) {\n+        affectedComponents = args[componentsIndex + 1];\n+        this.log(`🎯 Componentes afectados: ${affectedComponents}`);\n+    }\n+\n+    const perfIndex = args.indexOf('--performance-impact');\n+    if (perfIndex > -1 && args[perfIndex + 1]) {\n+        performanceImpact = args[perfIndex + 1];\n+        this.log(`⚡ Impacto en rendimiento: ${performanceImpact}`);\n+    }\n+\n+    const breakingIndex = args.indexOf('--breaking-changes');\n+    if (breakingIndex > -1 && args[breakingIndex + 1]) {\n+        breakingChanges = args[breakingIndex + 1];\n+        this.log(`⚠️ Cambios que rompen compatibilidad: ${breakingChanges}`);\n+    }\n+\n+    try {\n+      // Verificar que estamos en un repositorio git\n+      await this.gitCommand(['status']);\n+\n+      // Generar análisis completo\n+      const analysis = await this.generateAnalysisContext();\n+      \n+      if (analysis.files.length === 0) {\n+        this.log('✅ No hay cambios para procesar');\n+        return;\n+      }\n+\n+      const fileCount = analysis.files.length;\n+      const exhaustiveMode = isExhaustive || fileCount > 50;\n+\n+      this.log(`📋 Encontrados ${fileCount} archivos modificados`);\n+      this.log(`📊 Estadísticas: +${analysis.stats.total_additions} -${analysis.stats.total_deletions} líneas`);\n+      if (exhaustiveMode) {\n+        this.log('⚡️ Activado modo de análisis exhaustivo.');\n+      }\n+\n+      // Preparar contexto completo mejorado\n+      const enhancedContext = this.buildEnhancedContext(\n+        extraContext,\n+        contextDescription,\n+        workType,\n+        affectedComponents,\n+        performanceImpact,\n+        breakingChanges\n+      );\n+\n+      // Analizar con Gemini\n+      const commitProposal = await this.analyzeWithGemini(analysis, exhaustiveMode, enhancedContext);\n+      \n+      // Guardar propuesta\n+      const proposalPath = this.saveCommitProposal(commitProposal);\n+      \n+      if (this.autoApprove) {\n+        // Validar que es seguro ejecutar auto-approve\n+        const isValid = await this.validateAutoApprove();\n+        if (!isValid) {\n+          console.error('❌ Auto-approve cancelado por validaciones de seguridad');\n+          return;\n+        }\n+        \n+        // Parsear y ejecutar commits\n+        this.log('\\n🤖 Ejecutando commits automáticamente...');\n+        const proposals = this.parseCommitProposals(commitProposal);\n+        \n+        if (proposals.length === 0) {\n+          console.warn('⚠️ No se encontraron commits válidos para ejecutar');\n+          console.log('📋 Revisa la propuesta manualmente:');\n+          console.log(commitProposal);\n+          return;\n+        }\n+        \n+        this.log(`📦 Encontrados ${proposals.length} commits para ejecutar:`);\n+        proposals.forEach((p, i) => {\n+          this.log(`  ${i + 1}. ${p.title}`);\n+        });\n+        \n+        let successfulCommits = 0;\n+        \n+        // Ejecutar cada commit secuencialmente\n+        for (let i = 0; i < proposals.length; i++) {\n+          const proposal = proposals[i];\n+          const success = await this.executeCommit(proposal, analysis.files);\n+          if (success) {\n+            successfulCommits++;\n+          } else {\n+            console.error(`❌ Falló commit ${i + 1}: ${proposal.title}`);\n+            // Continuar con los siguientes commits\n+          }\n+        }\n+        \n+        this.log(`\\n📊 Resultados: ${successfulCommits}/${proposals.length} commits exitosos`);\n+        \n+        if (successfulCommits > 0) {\n+          await this.pushCommits();\n+        }\n+        \n+        this.log('\\n✅ Auto-approve completado');\n+        \n+      } else {\n+        // Modo normal - solo mostrar propuesta\n+        this.log('\\n✅ Análisis completado');\n+        console.log(`📄 Propuesta guardada en: ${proposalPath}`);\n+        if (!this.quiet) {\n+          console.log('\\n📋 Propuesta de commits:');\n+          console.log('─'.repeat(60));\n+          console.log(commitProposal);\n+          console.log('─'.repeat(60));\n+          console.log('\\n💡 Usa --auto-approve para ejecutar automáticamente los commits');\n+          console.log('💡 O usa --proposal-file <ruta> para reutilizar esta propuesta');\n+        }\n+      }\n+\n+    } catch (error) {\n+      console.error('❌ Error en el generador:', error);\n+      process.exit(1);\n+    }\n+  }\n+}\n+\n+// Ejecutar el generador si se llama directamente\n+if (import.meta.main) {\n+  const args = process.argv.slice(2);\n+  \n+  if (args.includes('--help') || args.includes('-h')) {\n+    console.log(`\n+🚀 Generador Automático de Commits con Gemini CLI\n+\n+Analiza cambios del repositorio y genera commits coherentes siguiendo los patrones del proyecto.\n+\n+Uso:\n+  node project-utils/commit-generator.ts [opciones]\n+\n+Opciones principales:\n+  --auto-approve                Ejecutar automáticamente los commits propuestos y hacer push\n+  --proposal-file <ruta>        Usar propuesta existente (ej: project-utils/.temp/commit-proposal-*.md)\n+  --quiet                       Ejecución silenciosa (solo errores y resultados finales)\n+  --output-dir <directorio>     Directorio personalizado para archivos temporales\n+\n+Opciones de configuración:\n+  --no-push                    Con --auto-approve, no hacer push (solo commits locales)\n+  --extra <texto>              Contexto adicional para mejorar el análisis\n+  --context <descripción>      Descripción del trabajo actual\n+  --work-type <tipo>           Tipo: feature|fix|refactor|docs|test\n+  --affected-components <lista> Componentes afectados (ej: \"core,styling,exports\")\n+  --performance-impact <tipo>  Impacto: none|minor|major\n+  --breaking-changes <si|no>   Si introduce cambios incompatibles\n+  --exhaustive                 Análisis exhaustivo para proyectos complejos\n+  --help, -h                   Mostrar esta ayuda\n+\n+Ejemplos:\n+  node project-utils/commit-generator.ts                     # Generar propuesta básica\n+  node project-utils/commit-generator.ts --auto-approve      # Ejecutar automáticamente\n+  node project-utils/commit-generator.ts --quiet --auto-approve # Ejecución silenciosa\n+  node project-utils/commit-generator.ts --proposal-file project-utils/.temp/commit-proposal-20240101-120000.md --auto-approve\n+  node project-utils/commit-generator.ts --context \"logger functionality\" --work-type feature\n+  node project-utils/commit-generator.ts --work-type fix --affected-components \"core,exports\"\n+\n+Modo Auto-Approve:\n+- Valida estado del repositorio (rama main/master, sin conflictos)\n+- Parsea commits propuestos por Gemini AI\n+- Ejecuta cada commit secuencialmente con archivos apropiados\n+- Hace push automático a origin/current-branch (excepto con --no-push)\n+- Manejo de errores y rollback en caso de fallos\n+\n+Seguridad:\n+- Solo funciona en rama main o master\n+- Validación de conflictos antes de ejecutar\n+- Commits atómicos con manejo de errores individual\n+- Logs completos de todas las operaciones\n+`);\n+    process.exit(0);\n+  }\n+  \n+  const generator = new CommitGenerator();\n+  await generator.generate();\n+}\n\\ No newline at end of file",
      "lines_added": 861,
      "lines_removed": 0,
      "is_binary": true
    },
    {
      "path": "project-utils/commit-ui.ts",
      "status": "added",
      "diff": "diff --git a/project-utils/commit-ui.ts b/project-utils/commit-ui.ts\nnew file mode 100755\nindex 0000000..bb63e24\n--- /dev/null\n+++ b/project-utils/commit-ui.ts\n@@ -0,0 +1,246 @@\n+#!/usr/bin/env node\n+\n+import { execSync } from \"child_process\"\n+import { platform } from \"os\"\n+\n+interface CommitOptions {\n+  context: string\n+  workType: string\n+  affectedComponents: string[]\n+  scope?: string\n+  breakingChange?: boolean\n+  performanceImpact?: string\n+}\n+\n+class CommitUI {\n+  private platform = platform()\n+\n+  async collectCommitInfo(): Promise<CommitOptions> {\n+    console.log(\"🚀 Interactive Commit Generator\")\n+    console.log(\"================================\")\n+\n+    try {\n+      if (this.platform === \"darwin\") {\n+        return await this.macOSDialog()\n+      } else if (this.platform === \"linux\") {\n+        return await this.linuxDialog()\n+      } else {\n+        return await this.fallbackDialog()\n+      }\n+    } catch (error) {\n+      console.log(\"⚠️ GUI not available, falling back to text input\")\n+      return await this.fallbackDialog()\n+    }\n+  }\n+\n+  private async macOSDialog(): Promise<CommitOptions> {\n+    // Create a unified form using AppleScript\n+    const formScript = `\n+      const app = Application.currentApplication()\n+      app.includeStandardAdditions = true\n+      \n+      // First get the context text\n+      const contextResult = app.displayDialog(\"📝 Commit Generator\\\\n\\\\nDescribe what you implemented/fixed:\", {\n+        defaultAnswer: \"\",\n+        withTitle: \"🚀 Interactive Commit\",\n+        buttons: [\"Cancel\", \"Next →\"],\n+        defaultButton: \"Next →\"\n+      })\n+      \n+      const context = contextResult.textReturned\n+      \n+      // Then get work type\n+      const workTypes = [\"feature\", \"fix\", \"refactor\", \"docs\", \"test\"]\n+      const workTypeResult = app.chooseFromList(workTypes, {\n+        withTitle: \"🚀 Interactive Commit - Work Type\",\n+        withPrompt: \"Context: \" + context + \"\\\\n\\\\nSelect work type:\",\n+        defaultItems: [\"feature\"]\n+      })\n+      \n+      if (workTypeResult === false) {\n+        throw new Error(\"Cancelled\")\n+      }\n+      \n+      const workType = workTypeResult[0]\n+      \n+      // Then get components\n+      const components = [\"core\", \"styling\", \"exports\", \"cli\", \"docs\", \"tests\", \"examples\"]\n+      const componentsResult = app.chooseFromList(components, {\n+        withTitle: \"🚀 Interactive Commit - Components\",\n+        withPrompt: \"Context: \" + context + \"\\\\nType: \" + workType + \"\\\\n\\\\nSelect affected components:\",\n+        multipleSelectionsAllowed: true,\n+        defaultItems: [\"core\"]\n+      })\n+      \n+      if (componentsResult === false) {\n+        throw new Error(\"Cancelled\")\n+      }\n+      \n+      const affectedComponents = componentsResult.join(\",\")\n+      \n+      // Finally get performance impact\n+      const impacts = [\"none\", \"minor\", \"major\"]\n+      const performanceResult = app.chooseFromList(impacts, {\n+        withTitle: \"🚀 Interactive Commit - Performance\",\n+        withPrompt: \"Context: \" + context + \"\\\\nType: \" + workType + \"\\\\nComponents: \" + affectedComponents + \"\\\\n\\\\nPerformance impact:\",\n+        defaultItems: [\"none\"]\n+      })\n+      \n+      const performanceImpact = performanceResult === false ? \"none\" : performanceResult[0]\n+      \n+      // Return all values as JSON\n+      JSON.stringify({\n+        context: context,\n+        workType: workType,\n+        affectedComponents: affectedComponents,\n+        performanceImpact: performanceImpact\n+      })\n+    `\n+    \n+    const result = execSync(`osascript -l JavaScript -e '${formScript}'`, { encoding: 'utf-8' }).trim()\n+    const parsed = JSON.parse(result)\n+\n+    return {\n+      context: parsed.context,\n+      workType: parsed.workType,\n+      affectedComponents: parsed.affectedComponents.split(\",\"),\n+      performanceImpact: parsed.performanceImpact\n+    }\n+  }\n+\n+  private async linuxDialog(): Promise<CommitOptions> {\n+    // Check if zenity is available\n+    try {\n+      execSync(\"which zenity\", { stdio: 'ignore' })\n+    } catch {\n+      throw new Error(\"zenity not available\")\n+    }\n+\n+    // Context Input first\n+    const context = execSync(`zenity --entry --title=\"🚀 Interactive Commit\" --text=\"📝 Describe what you implemented/fixed:\" --width=400`, { encoding: 'utf-8' }).trim()\n+\n+    // Work Type Selection with context shown\n+    const workType = execSync(`zenity --list --title=\"🚀 Interactive Commit - Work Type\" --text=\"Context: ${context}\\\\n\\\\nSelect work type:\" --radiolist --column=\"Select\" --column=\"Type\" --column=\"Description\" --width=450 --height=300 \\\\\n+      TRUE \"feature\" \"New functionality\" \\\\\n+      FALSE \"fix\" \"Bug fixes\" \\\\\n+      FALSE \"refactor\" \"Code refactoring\" \\\\\n+      FALSE \"docs\" \"Documentation\" \\\\\n+      FALSE \"test\" \"Tests\"`, { encoding: 'utf-8' }).trim()\n+\n+    // Components Selection with previous values shown\n+    const componentsResult = execSync(`zenity --list --title=\"🚀 Interactive Commit - Components\" --text=\"Context: ${context}\\\\nType: ${workType}\\\\n\\\\nSelect affected components:\" --checklist --column=\"Select\" --column=\"Component\" --width=450 --height=300 \\\\\n+      TRUE \"core\" \\\\\n+      FALSE \"styling\" \\\\\n+      FALSE \"exports\" \\\\\n+      FALSE \"cli\" \\\\\n+      FALSE \"docs\" \\\\\n+      FALSE \"tests\" \\\\\n+      FALSE \"examples\"`, { encoding: 'utf-8' }).trim()\n+    \n+    const affectedComponents = componentsResult.split(\"|\").filter(Boolean)\n+\n+    // Performance Impact with summary\n+    const performanceImpact = execSync(`zenity --list --title=\"🚀 Interactive Commit - Performance\" --text=\"Context: ${context}\\\\nType: ${workType}\\\\nComponents: ${affectedComponents.join(', ')}\\\\n\\\\nSelect performance impact:\" --radiolist --column=\"Select\" --column=\"Impact\" --width=450 --height=250 \\\\\n+      TRUE \"none\" \\\\\n+      FALSE \"minor\" \\\\\n+      FALSE \"major\"`, { encoding: 'utf-8' }).trim()\n+\n+    return {\n+      context,\n+      workType,\n+      affectedComponents,\n+      performanceImpact\n+    }\n+  }\n+\n+  private async fallbackDialog(): Promise<CommitOptions> {\n+    const readline = require('readline').createInterface({\n+      input: process.stdin,\n+      output: process.stdout\n+    })\n+\n+    const question = (prompt: string): Promise<string> => {\n+      return new Promise((resolve) => {\n+        readline.question(prompt, resolve)\n+      })\n+    }\n+\n+    console.log(\"\\n📝 Text-based commit input\")\n+    \n+    const workType = await question(\"Work type (feature/fix/refactor/docs/test): \") || \"feature\"\n+    const context = await question(\"Describe what you implemented/fixed: \")\n+    const componentsInput = await question(\"Components changed (core,styling,exports,cli,docs,tests,examples): \") || \"core\"\n+    const affectedComponents = componentsInput.split(\",\").map(c => c.trim())\n+    const performanceImpact = await question(\"Performance impact (none/minor/major): \") || \"none\"\n+\n+    readline.close()\n+\n+    return {\n+      context,\n+      workType,\n+      affectedComponents,\n+      performanceImpact\n+    }\n+  }\n+\n+  async generateCommit(options: CommitOptions): Promise<void> {\n+    const args = [\n+      \"--context\", `\"${options.context}\"`,\n+      \"--work-type\", options.workType,\n+      \"--affected-components\", options.affectedComponents.join(\",\")\n+    ]\n+\n+    if (options.performanceImpact && options.performanceImpact !== \"none\") {\n+      args.push(\"--performance-impact\", options.performanceImpact)\n+    }\n+\n+    console.log(\"\\n🔄 Generating commit...\")\n+    console.log(`📋 Context: ${options.context}`)\n+    console.log(`🏷️ Type: ${options.workType}`)\n+    console.log(`📦 Components: ${options.affectedComponents.join(\", \")}`)\n+    console.log(`⚡ Performance: ${options.performanceImpact}`)\n+\n+    const command = `node src/commit-generator.ts ${args.join(\" \")} --auto-approve`\n+    console.log(`\\n🚀 Running: ${command}`)\n+    \n+    try {\n+      execSync(command, { stdio: 'inherit' })\n+      console.log(\"✅ Commits executed successfully!\")\n+    } catch (error) {\n+      console.error(\"❌ Error executing commits:\", error)\n+      process.exit(1)\n+    }\n+  }\n+}\n+\n+async function main() {\n+  const ui = new CommitUI()\n+  \n+  // Check for quick mode\n+  if (process.argv.includes(\"--quick\")) {\n+    const quickOptions: CommitOptions = {\n+      context: \"Quick commit via UI\",\n+      workType: \"feature\",\n+      affectedComponents: [\"core\"],\n+      performanceImpact: \"none\"\n+    }\n+    await ui.generateCommit(quickOptions)\n+    return\n+  }\n+  \n+  try {\n+    const options = await ui.collectCommitInfo()\n+    await ui.generateCommit(options)\n+  } catch (error) {\n+    if (error instanceof Error && error.message === \"Cancelled\") {\n+      console.log(\"❌ Commit cancelled by user\")\n+      process.exit(0)\n+    }\n+    console.error(\"❌ Error:\", error)\n+    process.exit(1)\n+  }\n+}\n+\n+if (import.meta.main) {\n+  main()\n+}\n\\ No newline at end of file",
      "lines_added": 246,
      "lines_removed": 0,
      "is_binary": false
    },
    {
      "path": "project-utils/git-utils.ts",
      "status": "added",
      "diff": "diff --git a/project-utils/git-utils.ts b/project-utils/git-utils.ts\nnew file mode 100644\nindex 0000000..d1b860f\n--- /dev/null\n+++ b/project-utils/git-utils.ts\n@@ -0,0 +1,199 @@\n+/**\n+ * Utilidades para manejo de Git\n+ * Funciones auxiliares para el generador de commits\n+ */\n+\n+export interface GitFileStatus {\n+  path: string;\n+  staged: boolean;\n+  unstaged: boolean;\n+  untracked: boolean;\n+  deleted: boolean;\n+  renamed?: string;\n+}\n+\n+export interface CommitInfo {\n+  hash: string;\n+  message: string;\n+  author: string;\n+  date: string;\n+}\n+\n+/**\n+ * Parsea la salida de git status --porcelain\n+ */\n+export function parseGitStatus(statusOutput: string): GitFileStatus[] {\n+  const files: GitFileStatus[] = [];\n+  \n+  for (const line of statusOutput.split('\\n').filter(l => l.trim())) {\n+    const staged = line[0];\n+    const unstaged = line[1];\n+    const filePath = line.substring(3);\n+\n+    files.push({\n+      path: filePath,\n+      staged: staged !== ' ' && staged !== '?',\n+      unstaged: unstaged !== ' ',\n+      untracked: staged === '?' && unstaged === '?',\n+      deleted: staged === 'D' || unstaged === 'D',\n+      renamed: staged === 'R' ? filePath.split(' -> ')[1] : undefined,\n+    });\n+  }\n+\n+  return files;\n+}\n+\n+/**\n+ * Determina el área funcional de un archivo basado en su ruta\n+ */\n+export function getFileArea(filePath: string): string {\n+  const areas = [\n+    { pattern: /^src\\/components\\/|^src\\/layouts\\//, area: 'ui' },\n+    { pattern: /^src-tauri\\//, area: 'backend' },\n+    { pattern: /^src\\/models\\/|types|interfaces/, area: 'types' },\n+    { pattern: /^src\\/stores\\/|state/, area: 'state' },\n+    { pattern: /^src\\/pages\\/|routing|navigation/, area: 'navigation' },\n+    { pattern: /^src\\/styles\\/|\\.css$|theme/, area: 'theme' },\n+    { pattern: /config|\\.json$|\\.toml$|package\\.json/, area: 'config' },\n+    { pattern: /^project-utils\\/|tools|scripts/, area: 'tools' },\n+    { pattern: /database|migration|sql/, area: 'database' },\n+    { pattern: /test|spec|\\.test\\.|\\.spec\\./, area: 'testing' },\n+    { pattern: /doc|readme|\\.md$/, area: 'docs' },\n+  ];\n+\n+  for (const { pattern, area } of areas) {\n+    if (pattern.test(filePath.toLowerCase())) {\n+      return area;\n+    }\n+  }\n+\n+  return 'misc';\n+}\n+\n+/**\n+ * Determina si los archivos están relacionados funcionalmente\n+ */\n+export function areFilesRelated(files: string[]): boolean {\n+  if (files.length <= 1) return true;\n+  \n+  const areas = files.map(getFileArea);\n+  const uniqueAreas = [...new Set(areas)];\n+  \n+  // Si todos están en la misma área, están relacionados\n+  if (uniqueAreas.length === 1) return true;\n+  \n+  // Áreas que suelen ir juntas\n+  const relatedAreas = [\n+    ['ui', 'theme', 'navigation'],\n+    ['backend', 'database', 'types'],\n+    ['config', 'tools', 'docs'],\n+    ['types', 'state'],\n+  ];\n+  \n+  for (const group of relatedAreas) {\n+    if (uniqueAreas.every(area => group.includes(area))) {\n+      return true;\n+    }\n+  }\n+  \n+  return false;\n+}\n+\n+/**\n+ * Sugiere el tipo de commit basado en los cambios\n+ */\n+export function suggestCommitType(files: GitFileStatus[]): 'feat' | 'fix' | 'refactor' | 'feat-phase' {\n+  const hasNewFiles = files.some(f => f.untracked);\n+  const hasDeletedFiles = files.some(f => f.deleted);\n+  const modifiedFiles = files.filter(f => f.staged || f.unstaged);\n+  \n+  // Si hay muchos archivos nuevos, probablemente es una feature\n+  if (hasNewFiles && files.length > 3) {\n+    return 'feat-phase';\n+  }\n+  \n+  // Si hay archivos nuevos pero pocos, es feature completa\n+  if (hasNewFiles) {\n+    return 'feat';\n+  }\n+  \n+  // Si solo se modificaron archivos existentes, probablemente es fix o refactor\n+  if (modifiedFiles.length > 0 && !hasNewFiles) {\n+    // Si los cambios son grandes, es refactor\n+    if (modifiedFiles.length > 5) {\n+      return 'refactor';\n+    }\n+    // Si son pocos cambios, probablemente es fix\n+    return 'fix';\n+  }\n+  \n+  return 'feat';\n+}\n+\n+/**\n+ * Extrae información relevante del diff de un archivo\n+ */\n+export function analyzeDiff(diff: string): {\n+  addedLines: number;\n+  removedLines: number;\n+  hasNewFunctions: boolean;\n+  hasNewTypes: boolean;\n+  hasNewImports: boolean;\n+  hasFixes: boolean;\n+} {\n+  const lines = diff.split('\\n');\n+  const addedLines = lines.filter(l => l.startsWith('+')).length;\n+  const removedLines = lines.filter(l => l.startsWith('-')).length;\n+  \n+  const addedCode = lines.filter(l => l.startsWith('+')).join('\\n');\n+  const removedCode = lines.filter(l => l.startsWith('-')).join('\\n');\n+  \n+  return {\n+    addedLines,\n+    removedLines,\n+    hasNewFunctions: /function\\s+\\w+|const\\s+\\w+\\s*=|async\\s+function/.test(addedCode),\n+    hasNewTypes: /interface\\s+\\w+|type\\s+\\w+|enum\\s+\\w+/.test(addedCode),\n+    hasNewImports: /import\\s+.*from/.test(addedCode),\n+    hasFixes: /fix|error|bug|issue|problem/i.test(addedCode) || removedCode.includes('TODO') || removedCode.includes('FIXME'),\n+  };\n+}\n+\n+/**\n+ * Genera un resumen técnico basado en los archivos modificados\n+ */\n+export function generateTechnicalSummary(files: GitFileStatus[], diffs: Record<string, string>): string {\n+  const summary: string[] = [];\n+  \n+  for (const file of files) {\n+    const area = getFileArea(file.path);\n+    const diff = diffs[file.path];\n+    \n+    if (!diff) continue;\n+    \n+    const analysis = analyzeDiff(diff);\n+    const changes: string[] = [];\n+    \n+    if (file.untracked) {\n+      changes.push(`Creado ${file.path}`);\n+    } else if (file.deleted) {\n+      changes.push(`Eliminado ${file.path}`);\n+    } else {\n+      if (analysis.hasNewFunctions) changes.push('nuevas funciones');\n+      if (analysis.hasNewTypes) changes.push('nuevos tipos');\n+      if (analysis.hasNewImports) changes.push('nuevas dependencias');\n+      if (analysis.hasFixes) changes.push('correcciones');\n+      \n+      if (changes.length > 0) {\n+        changes.unshift(`Modificado ${file.path} con`);\n+      } else {\n+        changes.push(`Actualizado ${file.path}`);\n+      }\n+    }\n+    \n+    if (changes.length > 0) {\n+      summary.push(`- ${changes.join(' ')}`);\n+    }\n+  }\n+  \n+  return summary.join('\\n');\n+}\n\\ No newline at end of file",
      "lines_added": 199,
      "lines_removed": 0,
      "is_binary": false
    },
    {
      "path": "project-utils/github-release-manager.ts",
      "status": "added",
      "diff": "diff --git a/project-utils/github-release-manager.ts b/project-utils/github-release-manager.ts\nnew file mode 100644\nindex 0000000..83dac00\n--- /dev/null\n+++ b/project-utils/github-release-manager.ts\n@@ -0,0 +1,458 @@\n+#!/usr/bin/env node\n+\n+/**\n+ * GitHub Release Manager para Better Logger\n+ * Crea releases automáticamente en GitHub con los archivos de distribución\n+ */\n+\n+import { readFileSync, existsSync, readdirSync, statSync } from 'fs';\n+import { join, basename } from 'path';\n+\n+interface ReleaseInfo {\n+  version: string;\n+  prefix?: string;\n+  baseVersion: string;\n+  path: string;\n+  files: string[];\n+  readme: string;\n+  isPrerelease: boolean;\n+}\n+\n+interface ChangelogEntry {\n+  type: 'feature' | 'fix' | 'improvement' | 'breaking';\n+  title: string;\n+  description: string;\n+}\n+\n+interface VersionData {\n+  version: string;\n+  date: string;\n+  type: 'initial' | 'major' | 'minor' | 'patch';\n+  title: string;\n+  changes: ChangelogEntry[];\n+  technical_notes: string;\n+  breaking_changes: string[];\n+}\n+\n+class GitHubReleaseManager {\n+  private projectRoot: string;\n+  private releasesDir: string;\n+  private changelogPath: string;\n+\n+  constructor() {\n+    this.projectRoot = process.cwd();\n+    this.releasesDir = join(this.projectRoot, 'dist');\n+    this.changelogPath = join(this.projectRoot, 'CHANGELOG.json');\n+  }\n+\n+  /**\n+   * Ejecuta comando gh CLI\n+   */\n+  private async ghCommand(args: string[]): Promise<string> {\n+    const { spawn } = await import('child_process');\n+    \n+    return new Promise((resolve, reject) => {\n+      const proc = spawn('gh', args, {\n+        cwd: this.projectRoot,\n+        stdio: ['pipe', 'pipe', 'pipe']\n+      });\n+\n+      let stdout = '';\n+      let stderr = '';\n+\n+      proc.stdout?.on('data', (data) => {\n+        stdout += data.toString();\n+      });\n+\n+      proc.stderr?.on('data', (data) => {\n+        stderr += data.toString();\n+      });\n+\n+      proc.on('exit', (code) => {\n+        if (code !== 0) {\n+          reject(new Error(`GitHub CLI error: ${stderr || 'gh command failed'}`));\n+        } else {\n+          resolve(stdout.trim());\n+        }\n+      });\n+\n+      proc.on('error', (error) => {\n+        reject(error);\n+      });\n+    });\n+  }\n+\n+  /**\n+   * Verifica si gh CLI está instalado y autenticado\n+   */\n+  private async checkGitHubCLI(): Promise<void> {\n+    try {\n+      await this.ghCommand(['auth', 'status']);\n+      console.log('✅ GitHub CLI autenticado correctamente');\n+    } catch (error) {\n+      console.error('❌ GitHub CLI no está instalado o no estás autenticado');\n+      console.log('💡 Instala gh CLI: https://cli.github.com/');\n+      console.log('💡 Autentica con: gh auth login');\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * Obtiene todas las releases existentes en GitHub\n+   */\n+  private async getExistingReleases(): Promise<Set<string>> {\n+    try {\n+      const output = await this.ghCommand(['release', 'list', '--json', 'tagName']);\n+      const releases = JSON.parse(output);\n+      return new Set(releases.map((r: any) => r.tagName));\n+    } catch (error) {\n+      console.warn('⚠️ No se pudieron obtener releases existentes:', error);\n+      return new Set();\n+    }\n+  }\n+\n+  /**\n+   * Obtiene información de la release actual desde package.json y dist/\n+   */\n+  private getCurrentRelease(): ReleaseInfo | null {\n+    try {\n+      // Leer versión de package.json\n+      const packagePath = join(this.projectRoot, 'package.json');\n+      if (!existsSync(packagePath)) {\n+        console.warn('⚠️ package.json no existe');\n+        return null;\n+      }\n+      \n+      const packageData = JSON.parse(readFileSync(packagePath, 'utf-8'));\n+      const version = packageData.version;\n+      \n+      if (!existsSync(this.releasesDir)) {\n+        console.warn('⚠️ Directorio dist/ no existe');\n+        return null;\n+      }\n+\n+      // Obtener archivos de la distribución\n+      const files = readdirSync(this.releasesDir)\n+        .map(file => join(this.releasesDir, file));\n+\n+      // Determinar si es prerelease\n+      const isPrerelease = version.includes('-alpha') || version.includes('-beta') || version.includes('-rc') || version.includes('-pre');\n+      \n+      // Extraer prefix y base version\n+      const match = version.match(/^(.*?)(-alpha|-beta|-rc|-pre)?(.*)$/);\n+      const baseVersion = match ? match[1] + (match[3] || '') : version;\n+      const prefix = match && match[2] ? match[2].substring(1) : undefined;\n+      return {\n+        version,\n+        prefix,\n+        baseVersion,\n+        path: this.releasesDir,\n+        files,\n+        readme: this.generateREADME(version),\n+        isPrerelease\n+      };\n+    } catch (error) {\n+      console.error('❌ Error obteniendo release actual:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Genera README básico para la release\n+   */\n+  private generateREADME(version: string): string {\n+    const date = new Date().toISOString().split('T')[0];\n+    return `# Better Logger v${version}\n+    \n+## Instalación\n+\n+\\`\\`\\`bash\n+npm install @mks2508/better-logger@${version}\n+\\`\\`\\`\n+\n+## Uso\n+\n+\\`\\`\\`javascript\n+import { Logger } from '@mks2508/better-logger';\n+\n+const logger = new Logger();\n+logger.info('¡Hola mundo!');\n+\\`\\`\\`\n+\n+---\n+\n+*Release generada automáticamente el ${date}*`;\n+  }\n+\n+  /**\n+   * Carga información del changelog para una versión específica\n+   */\n+  private getChangelogForVersion(version: string): VersionData | null {\n+    try {\n+      const changelogData = JSON.parse(readFileSync(this.changelogPath, 'utf-8'));\n+      return changelogData.versions.find((v: VersionData) => v.version === version) || null;\n+    } catch (error) {\n+      console.warn(`⚠️ No se pudo cargar changelog para ${version}`);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Genera las release notes basadas en changelog y README\n+   */\n+  private generateReleaseNotes(release: ReleaseInfo): string {\n+    const changelog = this.getChangelogForVersion(release.version);\n+    \n+    let notes = `# Better Logger - ${release.version}\\n\\n`;\n+    \n+    if (changelog) {\n+      notes += `## 📋 Resumen\\n${changelog.title}\\n\\n`;\n+      \n+      // Agrupar cambios por tipo\n+      const features = changelog.changes.filter(c => c.type === 'feature');\n+      const fixes = changelog.changes.filter(c => c.type === 'fix');\n+      const improvements = changelog.changes.filter(c => c.type === 'improvement');\n+      const breaking = changelog.changes.filter(c => c.type === 'breaking');\n+      \n+      if (features.length > 0) {\n+        notes += `## ✨ Nuevas Funcionalidades\\n`;\n+        features.forEach(f => notes += `- ${f.title}\\n`);\n+        notes += '\\n';\n+      }\n+      \n+      if (fixes.length > 0) {\n+        notes += `## 🐛 Correcciones\\n`;\n+        fixes.forEach(f => notes += `- ${f.title}\\n`);\n+        notes += '\\n';\n+      }\n+      \n+      if (improvements.length > 0) {\n+        notes += `## 🚀 Mejoras\\n`;\n+        improvements.forEach(i => notes += `- ${i.title}\\n`);\n+        notes += '\\n';\n+      }\n+      \n+      if (breaking.length > 0) {\n+        notes += `## 💥 Cambios Importantes\\n`;\n+        breaking.forEach(b => notes += `- ${b.title}\\n`);\n+        notes += '\\n';\n+      }\n+    }\n+    \n+    // Agregar información de instalación del README\n+    const readmeLines = release.readme.split('\\n');\n+    const installIndex = readmeLines.findIndex(line => line.includes('## Instalación'));\n+    const compatIndex = readmeLines.findIndex(line => line.includes('## Compatibilidad'));\n+    \n+    if (installIndex !== -1) {\n+      notes += `## 📦 Instalación\\n\\n`;\n+      const endIndex = compatIndex !== -1 ? compatIndex : readmeLines.length;\n+      const installSection = readmeLines.slice(installIndex + 1, endIndex);\n+      notes += installSection.join('\\n') + '\\n\\n';\n+    }\n+    \n+    // Información de archivos\n+    notes += `## 📁 Archivos de la Release\\n\\n`;\n+    release.files.forEach(file => {\n+      const fileName = basename(file);\n+      const stats = statSync(file);\n+      const sizeMB = (stats.size / 1024 / 1024).toFixed(1);\n+      notes += `- **${fileName}** (${sizeMB} MB)\\n`;\n+    });\n+    \n+    notes += `\\n---\\n\\n`;\n+    notes += `🏗️ **Plataforma objetivo**: Universal (Browser/Node.js)\\n`;\n+    notes += `🗓️ **Fecha**: ${changelog?.date || new Date().toISOString().split('T')[0]}\\n`;\n+    \n+    if (release.isPrerelease) {\n+      notes += `\\n⚠️ **Nota**: Esta es una versión ${release.prefix} en desarrollo. No recomendada para producción.\\n`;\n+    }\n+\n+    return notes;\n+  }\n+\n+  /**\n+   * Crea una release en GitHub\n+   */\n+  private async createGitHubRelease(release: ReleaseInfo): Promise<void> {\n+    console.log(`🚀 Creando release ${release.version}...`);\n+    \n+    const tagName = `v${release.version}`;\n+    const title = `Better Logger v${release.version}`;\n+    const notes = this.generateReleaseNotes(release);\n+    \n+    // Crear archivo temporal con las release notes\n+    const notesFile = join(this.projectRoot, `.release-notes-${release.version}.md`);\n+    const { writeFileSync } = await import('fs');\n+    writeFileSync(notesFile, notes, 'utf-8');\n+    \n+    try {\n+      // Crear la release\n+      const args = [\n+        'release', 'create', tagName,\n+        '--title', title,\n+        '--notes-file', notesFile,\n+        ...release.files\n+      ];\n+      \n+      if (release.isPrerelease) {\n+        args.push('--prerelease');\n+      }\n+      \n+      await this.ghCommand(args);\n+      console.log(`✅ Release ${release.version} creada exitosamente`);\n+      \n+      // Limpiar archivo temporal\n+      const { unlinkSync } = await import('fs');\n+      try { unlinkSync(notesFile); } catch {}\n+      \n+    } catch (error) {\n+      console.error(`❌ Error creando release ${release.version}:`, error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * Procesa todas las releases\n+   */\n+  async processReleases(force = false): Promise<void> {\n+    console.log('🔍 GitHub Release Manager iniciado\\n');\n+    \n+    try {\n+      await this.checkGitHubCLI();\n+      \n+      const currentRelease = this.getCurrentRelease();\n+      \n+      if (!currentRelease) {\n+        console.log('❌ No se pudo obtener información de la release actual');\n+        return;\n+      }\n+      \n+      console.log(`📦 Release actual: ${currentRelease.version}`);\n+      \n+      const existingReleases = await this.getExistingReleases();\n+      console.log(`📋 ${existingReleases.size} releases ya existen en GitHub`);\n+      \n+      const tagName = `v${currentRelease.version}`;\n+      \n+      if (existingReleases.has(tagName) && !force) {\n+        console.log(`⏭️ Release ${currentRelease.version} ya existe, omitiendo`);\n+        console.log('💡 Usa --force para forzar recreación');\n+        return;\n+      }\n+      \n+      if (force && existingReleases.has(tagName)) {\n+        console.log(`🔄 Eliminando release existente ${currentRelease.version}...`);\n+        try {\n+          await this.ghCommand(['release', 'delete', tagName, '--yes']);\n+        } catch (error) {\n+          console.warn(`⚠️ No se pudo eliminar release ${tagName}:`, error);\n+        }\n+      }\n+      \n+      await this.createGitHubRelease(currentRelease);\n+      console.log(`\\n✅ Procesamiento completado: Release ${currentRelease.version} creada exitosamente`);\n+      \n+    } catch (error) {\n+      console.error('❌ Error en el procesamiento:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * Monitorea el directorio releases para cambios\n+   */\n+  async watchForNewReleases(): Promise<void> {\n+    console.log('👀 Monitoreando directorio releases para nuevas versiones...');\n+    // Implementación futura con file watchers\n+    console.log('💡 Funcionalidad de monitoreo en desarrollo');\n+  }\n+}\n+\n+// Función helper para obtener releases existentes (fix de scope)\n+async function getExistingReleases(): Promise<Set<string>> {\n+  try {\n+    const { spawn } = await import('child_process');\n+    \n+    return new Promise((resolve, reject) => {\n+      const proc = spawn('gh', ['release', 'list', '--json', 'tagName'], {\n+        stdio: ['pipe', 'pipe', 'pipe']\n+      });\n+\n+      let stdout = '';\n+      let stderr = '';\n+\n+      proc.stdout?.on('data', (data) => {\n+        stdout += data.toString();\n+      });\n+\n+      proc.stderr?.on('data', (data) => {\n+        stderr += data.toString();\n+      });\n+\n+      proc.on('exit', (code) => {\n+        if (code !== 0) {\n+          resolve(new Set());\n+        } else {\n+          try {\n+            const releases = JSON.parse(stdout);\n+            resolve(new Set(releases.map((r: any) => r.tagName)));\n+          } catch {\n+            resolve(new Set());\n+          }\n+        }\n+      });\n+\n+      proc.on('error', () => {\n+        resolve(new Set());\n+      });\n+    });\n+  } catch (error) {\n+    return new Set();\n+  }\n+}\n+\n+// Ejecutar script\n+if (import.meta.main) {\n+  const manager = new GitHubReleaseManager();\n+  \n+  const args = process.argv.slice(2);\n+  const force = args.includes('--force') || args.includes('-f');\n+  const watch = args.includes('--watch') || args.includes('-w');\n+  const autoApprove = args.includes('--auto-approve');\n+  const quiet = args.includes('--quiet');\n+  \n+  if (args.includes('--help') || args.includes('-h')) {\n+    console.log(`\n+🚀 GitHub Release Manager para Better Logger\n+\n+Uso:\n+  node project-utils/github-release-manager.ts [opciones]\n+\n+Opciones:\n+  --auto-approve  Crear release automáticamente sin confirmación\n+  --force, -f     Recrear releases existentes\n+  --quiet         Ejecución silenciosa (solo errores y resultados)\n+  --watch, -w     Monitorear cambios (en desarrollo)\n+  --help, -h      Mostrar esta ayuda\n+\n+Ejemplos:\n+  node project-utils/github-release-manager.ts                    # Release interactiva\n+  node project-utils/github-release-manager.ts --auto-approve     # Release automática\n+  node project-utils/github-release-manager.ts --force --auto-approve  # Forzar recreación\n+  node project-utils/github-release-manager.ts --quiet --auto-approve   # Para workflows\n+`);\n+    process.exit(0);\n+  }\n+  \n+  try {\n+    if (watch) {\n+      await manager.watchForNewReleases();\n+    } else {\n+      await manager.processReleases(force);\n+    }\n+  } catch (error) {\n+    console.error('❌ Error:', error);\n+    process.exit(1);\n+  }\n+}\n\\ No newline at end of file",
      "lines_added": 458,
      "lines_removed": 0,
      "is_binary": false
    },
    {
      "path": "project-utils/prompt-templates.js",
      "status": "added",
      "diff": "diff --git a/project-utils/prompt-templates.js b/project-utils/prompt-templates.js\nnew file mode 100644\nindex 0000000..504b6d7\n--- /dev/null\n+++ b/project-utils/prompt-templates.js\n@@ -0,0 +1,345 @@\n+/**\n+ * Plantillas de prompts estandarizadas para Gemini CLI\n+ * @description Asegura respuestas consistentes y parseables en todos los scripts\n+ * @author TPV EL Haido\n+ */\n+/**\n+ * Configuración base del proyecto OpenTUI\n+ */\n+export const TPV_PROJECT_CONFIG = {\n+    name: 'OpenTUI',\n+    description: 'Modern Terminal User Interface Framework',\n+    version: '0.1.0',\n+    techStack: ['TypeScript', 'Node.js', 'Terminal UI', 'CLI'],\n+    targetPlatform: 'Cross-platform (macOS, Linux, Windows)',\n+};\n+/**\n+ * Prefijo estándar para todos los prompts de Gemini\n+ */\n+const STANDARD_PROMPT_PREFIX = `# Sistema de Análisis Inteligente - OpenTUI\n+\n+Eres un asistente especializado en análisis de código y automatización para el proyecto OpenTUI. Tu función es proporcionar respuestas estructuradas, precisas y consistentes que puedan ser parseadas automáticamente.\n+\n+## REGLAS CRÍTICAS DE FORMATO\n+\n+1. **FORMATO DE RESPUESTA OBLIGATORIO**: Todas tus respuestas deben seguir exactamente el formato especificado más abajo.\n+2. **CONSISTENCIA**: Mantén la misma estructura sin importar la complejidad del análisis.\n+3. **PARSEABLE**: El formato debe ser fácil de procesar automáticamente con expresiones regulares.\n+4. **BLOQUES MARKDOWN**: Usa \\`\\`\\`markdown para bloques de código cuando se especifique.\n+5. **SECCIONES TÉCNICAS**: Siempre incluye las secciones <technical> y <changelog> cuando sea aplicable.\n+\n+## Contexto del Proyecto\n+**Nombre**: ${TPV_PROJECT_CONFIG.name}\n+**Descripción**: ${TPV_PROJECT_CONFIG.description}\n+**Versión Actual**: ${TPV_PROJECT_CONFIG.version}\n+**Stack Tecnológico**: ${TPV_PROJECT_CONFIG.techStack.join(', ')}\n+**Plataforma Objetivo**: ${TPV_PROJECT_CONFIG.targetPlatform}\n+\n+---\n+`;\n+/**\n+ * Sufijo estándar con instrucciones de formato\n+ */\n+const STANDARD_PROMPT_SUFFIX = `\n+\n+---\n+\n+## INSTRUCCIONES FINALES\n+\n+1. **Lee cuidadosamente** toda la información proporcionada\n+2. **Analiza el contexto** y los datos específicos\n+3. **Genera una respuesta** siguiendo EXACTAMENTE el formato especificado\n+4. **Mantén consistencia** en la estructura y sintaxis\n+5. **No desvíes** del formato requerido bajo ninguna circunstancia\n+\n+**IMPORTANTE**: La respuesta debe ser parseada automáticamente. Cualquier desviación del formato especificado causará errores en el sistema.`;\n+/**\n+ * Genera prompt para análisis de commits\n+ */\n+export function createCommitPrompt(config) {\n+    const { data, specificContext } = config;\n+    return `${STANDARD_PROMPT_PREFIX}\n+\n+# ANÁLISIS DE COMMITS\n+\n+## Datos del Análisis\n+${JSON.stringify(data, null, 2)}\n+\n+## Contexto Adicional\n+${specificContext || 'Ninguno proporcionado'}\n+\n+---\n+\n+## FORMATO DE RESPUESTA REQUERIDO\n+\n+Tu respuesta debe seguir EXACTAMENTE esta estructura:\n+\n+### **ANÁLISIS PRINCIPAL**\n+\n+[Descripción general de los cambios detectados]\n+\n+---\n+\n+### **Propuesta de Commit #1**\n+\n+\\`\\`\\`markdown\n+[prefijo](área - descripción breve)\n+\n+[Descripción completa en castellano de QUÉ se logró y POR QUÉ]\n+\n+<technical>\n+[Detalles técnicos específicos: archivos modificados, funciones añadidas, refactorizaciones, etc.]\n+</technical>\n+\n+<changelog>\n+## [Tipo] [Emoji]\n+[Entrada para changelog de la app, optimizada para mostrar al usuario]\n+</changelog>\n+\\`\\`\\`\n+\n+### **Propuesta de Commit #2** (solo si es necesario)\n+\n+[Repetir formato anterior]\n+\n+---\n+\n+**DECISIÓN**: [Explicación breve de por qué uno o múltiples commits]\n+\n+${STANDARD_PROMPT_SUFFIX}`;\n+}\n+/**\n+ * Genera prompt para asistente de workflow\n+ */\n+export function createWorkflowPrompt(config) {\n+    const { data, specificContext } = config;\n+    return `${STANDARD_PROMPT_PREFIX}\n+\n+# ASISTENTE DE WORKFLOW\n+\n+## Solicitud del Usuario\n+\"${specificContext}\"\n+\n+## Contexto del Proyecto Actual\n+${JSON.stringify(data, null, 2)}\n+\n+---\n+\n+## FORMATO DE RESPUESTA REQUERIDO\n+\n+\\`\\`\\`markdown\n+🎯 **ANÁLISIS**: [Descripción del tipo de trabajo detectado]\n+📊 **IMPACTO**: [Áreas afectadas y alcance del cambio]\n+🚀 **RECOMENDACIÓN**: [Tipo de versión y estrategia recomendada]\n+\n+## 🖥️ COMANDOS PARA macOS\n+\\`\\`\\`bash\n+# [Descripción del primer comando]\n+[comando exacto con parámetros]\n+\n+# [Descripción del segundo comando]  \n+[segundo comando exacto]\n+\\`\\`\\`\n+\n+## 🐧 COMANDOS PARA LINUX ARM (después de macOS)\n+\\`\\`\\`bash\n+# SSH y preparación\n+ssh user@raspberry-pi\n+git pull origin master && bun install\n+\n+# [Descripción del build ARM]\n+[comandos específicos de ARM]\n+\\`\\`\\`\n+\n+## ✅ VERIFICACIONES AUTOMÁTICAS\n+- [Lista de verificaciones que se ejecutarán]\n+\\`\\`\\`\n+\n+${STANDARD_PROMPT_SUFFIX}`;\n+}\n+/**\n+ * Genera prompt para releases automáticas\n+ */\n+export function createReleasePrompt(config) {\n+    const { data, specificContext } = config;\n+    return `${STANDARD_PROMPT_PREFIX}\n+\n+# ANÁLISIS DE RELEASE\n+\n+## Información de la Release\n+${JSON.stringify(data, null, 2)}\n+\n+## Contexto Específico\n+${specificContext || 'Release automática'}\n+\n+---\n+\n+## FORMATO DE RESPUESTA REQUERIDO\n+\n+\\`\\`\\`markdown\n+# 📦 ANÁLISIS DE RELEASE\n+\n+## 🎯 RESUMEN\n+[Descripción de los cambios principales incluidos en esta release]\n+\n+## 📋 CHANGELOG GENERADO\n+\n+### ✨ Features\n+[Lista de nuevas funcionalidades]\n+\n+### 🐛 Fixes\n+[Lista de correcciones de bugs]\n+\n+### 🚀 Improvements\n+[Lista de mejoras]\n+\n+### 🔧 Technical\n+[Cambios técnicos internos]\n+\n+## 🏷️ INFORMACIÓN DE VERSIÓN\n+- **Versión**: [versión calculada]\n+- **Prefijo**: [alpha/beta/rc/stable]\n+- **Canal OTA**: [dev/beta/stable]\n+- **Tipo de cambio**: [major/minor/patch]\n+\n+## 📝 NOTAS DE RELEASE\n+[Texto descriptivo para usuarios finales]\n+\\`\\`\\`\n+\n+${STANDARD_PROMPT_SUFFIX}`;\n+}\n+/**\n+ * Parser genérico para respuestas de Gemini\n+ */\n+export class GeminiResponseParser {\n+    /**\n+     * Extrae múltiples propuestas de commit del formato estándar\n+     */\n+    static parseCommitProposals(response) {\n+        const proposals = [];\n+        // Buscar todas las propuestas con el formato: ### **Propuesta de Commit #N**\n+        const proposalPattern = /###\\s*\\*\\*Propuesta de Commit #\\d+\\*\\*/g;\n+        const proposalMatches = Array.from(response.matchAll(proposalPattern));\n+        if (proposalMatches.length === 0) {\n+            // Formato de un solo commit sin numeración\n+            const codeBlock = this.extractCodeBlock(response);\n+            if (codeBlock) {\n+                const parsed = this.parseCommitContent(codeBlock);\n+                if (parsed)\n+                    proposals.push(parsed);\n+            }\n+        }\n+        else {\n+            // Múltiples propuestas numeradas\n+            for (let i = 0; i < proposalMatches.length; i++) {\n+                const startIndex = proposalMatches[i].index;\n+                const endIndex = proposalMatches[i + 1]?.index || response.length;\n+                const proposalSection = response.substring(startIndex, endIndex);\n+                const codeBlock = this.extractCodeBlock(proposalSection);\n+                if (codeBlock) {\n+                    const parsed = this.parseCommitContent(codeBlock);\n+                    if (parsed)\n+                        proposals.push(parsed);\n+                }\n+            }\n+        }\n+        return proposals;\n+    }\n+    /**\n+     * Extrae bloque de código markdown\n+     */\n+    static extractCodeBlock(text) {\n+        const patterns = [\n+            /```markdown\\s*\\n([\\s\\S]*?)\\n```/, // ```markdown\n+            /```\\s*\\n([\\s\\S]*?)\\n```/, // ``` genérico  \n+            /```([\\s\\S]*?)```/ // sin saltos\n+        ];\n+        for (const pattern of patterns) {\n+            const match = text.match(pattern);\n+            if (match)\n+                return match[1].trim();\n+        }\n+        return null;\n+    }\n+    /**\n+     * Parsea el contenido de un commit individual\n+     */\n+    static parseCommitContent(content) {\n+        const lines = content.split('\\n');\n+        // Título (primera línea no vacía)\n+        let title = '';\n+        let titleIndex = 0;\n+        for (let i = 0; i < lines.length; i++) {\n+            if (lines[i].trim()) {\n+                title = lines[i].trim();\n+                titleIndex = i;\n+                break;\n+            }\n+        }\n+        if (!title)\n+            return null;\n+        // Extraer secciones\n+        let description = '';\n+        let technical = '';\n+        let changelog = '';\n+        let currentSection = 'description';\n+        for (let i = titleIndex + 1; i < lines.length; i++) {\n+            const line = lines[i];\n+            if (line.includes('<technical>')) {\n+                currentSection = 'technical';\n+                continue;\n+            }\n+            else if (line.includes('</technical>')) {\n+                currentSection = 'none';\n+                continue;\n+            }\n+            else if (line.includes('<changelog>')) {\n+                currentSection = 'changelog';\n+                continue;\n+            }\n+            else if (line.includes('</changelog>')) {\n+                currentSection = 'none';\n+                continue;\n+            }\n+            if (currentSection === 'description' && line.trim()) {\n+                description += line + '\\n';\n+            }\n+            else if (currentSection === 'technical') {\n+                technical += line + '\\n';\n+            }\n+            else if (currentSection === 'changelog') {\n+                changelog += line + '\\n';\n+            }\n+        }\n+        return {\n+            title,\n+            description: description.trim(),\n+            technical: technical.trim(),\n+            changelog: changelog.trim()\n+        };\n+    }\n+    /**\n+     * Parsea respuesta de workflow en formato estándar\n+     */\n+    static parseWorkflowResponse(response) {\n+        const analysisMatch = response.match(/🎯\\s*\\*\\*ANÁLISIS\\*\\*:\\s*(.+)/);\n+        const impactMatch = response.match(/📊\\s*\\*\\*IMPACTO\\*\\*:\\s*(.+)/);\n+        const recommendationMatch = response.match(/🚀\\s*\\*\\*RECOMENDACIÓN\\*\\*:\\s*(.+)/);\n+        // Extraer comandos macOS\n+        const macosSection = response.match(/##\\s*🖥️\\s*COMANDOS PARA macOS\\s*```bash\\s*([\\s\\S]*?)\\s*```/);\n+        const macosCommands = macosSection ? macosSection[1].split('\\n').filter(line => line.trim() && !line.startsWith('#')) : [];\n+        // Extraer comandos Linux ARM\n+        const linuxSection = response.match(/##\\s*🐧\\s*COMANDOS PARA LINUX ARM[\\s\\S]*?```bash\\s*([\\s\\S]*?)\\s*```/);\n+        const linuxCommands = linuxSection ? linuxSection[1].split('\\n').filter(line => line.trim() && !line.startsWith('#')) : [];\n+        // Extraer verificaciones\n+        const verificationsSection = response.match(/##\\s*✅\\s*VERIFICACIONES AUTOMÁTICAS\\s*([\\s\\S]*?)```/);\n+        const verifications = verificationsSection ? verificationsSection[1].split('\\n').filter(line => line.trim().startsWith('-')).map(line => line.replace(/^-\\s*/, '')) : [];\n+        return {\n+            analysis: analysisMatch?.[1] || 'No disponible',\n+            impact: impactMatch?.[1] || 'No disponible',\n+            recommendation: recommendationMatch?.[1] || 'No disponible',\n+            macosCommands,\n+            linuxCommands,\n+            verifications\n+        };\n+    }\n+}",
      "lines_added": 345,
      "lines_removed": 0,
      "is_binary": false
    },
    {
      "path": "project-utils/prompt-templates.ts",
      "status": "added",
      "diff": "diff --git a/project-utils/prompt-templates.ts b/project-utils/prompt-templates.ts\nnew file mode 100644\nindex 0000000..8cee1c5\n--- /dev/null\n+++ b/project-utils/prompt-templates.ts\n@@ -0,0 +1,422 @@\n+/**\n+ * Plantillas de prompts estandarizadas para Gemini CLI\n+ * @description Asegura respuestas consistentes y parseables en todos los scripts\n+ * @author TPV EL Haido\n+ */\n+\n+export interface GeminiPromptConfig {\n+  /** Contexto base del proyecto */\n+  projectContext: {\n+    name: string;\n+    description: string;\n+    version: string;\n+    techStack: string[];\n+    targetPlatform: string;\n+  };\n+  /** Tipo de análisis requerido */\n+  analysisType: 'commit' | 'workflow' | 'release';\n+  /** Contexto adicional específico */\n+  specificContext?: string;\n+  /** Datos estructurados para el análisis */\n+  data?: any;\n+}\n+\n+export interface StandardResponseFormat {\n+  /** Análisis o resumen principal */\n+  analysis: string;\n+  /** Recomendaciones o acciones */\n+  recommendations: string;\n+  /** Datos estructurados (commits, comandos, etc.) */\n+  structured_data: any[];\n+}\n+\n+/**\n+ * Configuración base del proyecto Better Logger\n+ */\n+export const BETTER_LOGGER_PROJECT_CONFIG = {\n+  name: 'Better Logger',\n+  description: 'State-of-the-art console logger with advanced CSS styling, SVG support, animations, and CLI interface',\n+  version: '0.0.3-alpha.0',\n+  techStack: ['TypeScript', 'Vite', 'Browser', 'CSS-in-JS', 'SVG'] as const,\n+  targetPlatform: 'Browser (Chrome, Firefox, Safari, Edge)',\n+} as const;\n+\n+// Alias para compatibilidad\n+export const TPV_PROJECT_CONFIG = BETTER_LOGGER_PROJECT_CONFIG;\n+\n+/**\n+ * Prefijo estándar para todos los prompts de Gemini\n+ */\n+const STANDARD_PROMPT_PREFIX = `# Sistema de Análisis Inteligente - Better Logger\n+\n+Eres un asistente especializado en análisis de código y automatización para el proyecto Better Logger. Tu función es proporcionar respuestas estructuradas, precisas y consistentes que puedan ser parseadas automáticamente.\n+\n+## REGLAS CRÍTICAS DE FORMATO\n+\n+1. **FORMATO DE RESPUESTA OBLIGATORIO**: Todas tus respuestas deben seguir exactamente el formato especificado más abajo.\n+2. **CONSISTENCIA**: Mantén la misma estructura sin importar la complejidad del análisis.\n+3. **PARSEABLE**: El formato debe ser fácil de procesar automáticamente con expresiones regulares.\n+4. **BLOQUES MARKDOWN**: Usa \\`\\`\\`markdown para bloques de código cuando se especifique.\n+5. **SECCIONES TÉCNICAS**: Siempre incluye las secciones <technical> y <changelog> cuando sea aplicable.\n+\n+## Contexto del Proyecto\n+**Nombre**: ${BETTER_LOGGER_PROJECT_CONFIG.name}\n+**Descripción**: ${BETTER_LOGGER_PROJECT_CONFIG.description}\n+**Versión Actual**: ${BETTER_LOGGER_PROJECT_CONFIG.version}\n+**Stack Tecnológico**: ${BETTER_LOGGER_PROJECT_CONFIG.techStack.join(', ')}\n+**Plataforma Objetivo**: ${BETTER_LOGGER_PROJECT_CONFIG.targetPlatform}\n+\n+---\n+`;\n+\n+/**\n+ * Sufijo estándar con instrucciones de formato\n+ */\n+const STANDARD_PROMPT_SUFFIX = `\n+\n+---\n+\n+## INSTRUCCIONES FINALES\n+\n+1. **Lee cuidadosamente** toda la información proporcionada\n+2. **Analiza el contexto** y los datos específicos\n+3. **Genera una respuesta** siguiendo EXACTAMENTE el formato especificado\n+4. **Mantén consistencia** en la estructura y sintaxis\n+5. **No desvíes** del formato requerido bajo ninguna circunstancia\n+\n+**IMPORTANTE**: La respuesta debe ser parseada automáticamente. Cualquier desviación del formato especificado causará errores en el sistema.`;\n+\n+/**\n+ * Genera prompt para análisis de commits\n+ */\n+export function createCommitPrompt(config: GeminiPromptConfig): string {\n+  const { data, specificContext } = config;\n+  \n+  return `${STANDARD_PROMPT_PREFIX}\n+\n+# ANÁLISIS DE COMMITS\n+\n+## Datos del Análisis\n+${JSON.stringify(data, null, 2)}\n+\n+## Contexto Adicional\n+${specificContext || 'Ninguno proporcionado'}\n+\n+---\n+\n+## FORMATO DE RESPUESTA REQUERIDO\n+\n+Tu respuesta debe seguir EXACTAMENTE esta estructura:\n+\n+### **ANÁLISIS PRINCIPAL**\n+\n+[Descripción general de los cambios detectados]\n+\n+---\n+\n+### **Propuesta de Commit #1**\n+\n+\\`\\`\\`markdown\n+[prefijo](área - descripción breve)\n+\n+[Descripción completa en castellano de QUÉ se logró y POR QUÉ]\n+\n+<technical>\n+[Detalles técnicos específicos: archivos modificados, funciones añadidas, refactorizaciones, etc.]\n+</technical>\n+\n+<changelog>\n+## [Tipo] [Emoji]\n+[Entrada para changelog de la app, optimizada para mostrar al usuario]\n+</changelog>\n+\\`\\`\\`\n+\n+### **Propuesta de Commit #2** (solo si es necesario)\n+\n+[Repetir formato anterior]\n+\n+---\n+\n+**DECISIÓN**: [Explicación breve de por qué uno o múltiples commits]\n+\n+${STANDARD_PROMPT_SUFFIX}`;\n+}\n+\n+/**\n+ * Genera prompt para asistente de workflow\n+ */\n+export function createWorkflowPrompt(config: GeminiPromptConfig): string {\n+  const { data, specificContext } = config;\n+  \n+  return `${STANDARD_PROMPT_PREFIX}\n+\n+# ASISTENTE DE WORKFLOW\n+\n+## Solicitud del Usuario\n+\"${specificContext}\"\n+\n+## Contexto del Proyecto Actual\n+${JSON.stringify(data, null, 2)}\n+\n+---\n+\n+## FORMATO DE RESPUESTA REQUERIDO\n+\n+\\`\\`\\`markdown\n+🎯 **ANÁLISIS**: [Descripción del tipo de trabajo detectado]\n+📊 **IMPACTO**: [Áreas afectadas y alcance del cambio]\n+🚀 **RECOMENDACIÓN**: [Tipo de versión y estrategia recomendada]\n+\n+## 🖥️ COMANDOS PARA macOS\n+\\`\\`\\`bash\n+# [Descripción del primer comando]\n+[comando exacto con parámetros]\n+\n+# [Descripción del segundo comando]  \n+[segundo comando exacto]\n+\\`\\`\\`\n+\n+## 🐧 COMANDOS PARA LINUX ARM (después de macOS)\n+\\`\\`\\`bash\n+# SSH y preparación\n+ssh user@raspberry-pi\n+git pull origin master && bun install\n+\n+# [Descripción del build ARM]\n+[comandos específicos de ARM]\n+\\`\\`\\`\n+\n+## ✅ VERIFICACIONES AUTOMÁTICAS\n+- [Lista de verificaciones que se ejecutarán]\n+\\`\\`\\`\n+\n+${STANDARD_PROMPT_SUFFIX}`;\n+}\n+\n+/**\n+ * Genera prompt para releases automáticas\n+ */\n+export function createReleasePrompt(config: GeminiPromptConfig): string {\n+  const { data, specificContext } = config;\n+  \n+  return `${STANDARD_PROMPT_PREFIX}\n+\n+# ANÁLISIS DE RELEASE\n+\n+## Información de la Release\n+${JSON.stringify(data, null, 2)}\n+\n+## Contexto Específico\n+${specificContext || 'Release automática'}\n+\n+---\n+\n+## FORMATO DE RESPUESTA REQUERIDO\n+\n+\\`\\`\\`markdown\n+# 📦 ANÁLISIS DE RELEASE\n+\n+## 🎯 RESUMEN\n+[Descripción de los cambios principales incluidos en esta release]\n+\n+## 📋 CHANGELOG GENERADO\n+\n+### ✨ Features\n+[Lista de nuevas funcionalidades]\n+\n+### 🐛 Fixes\n+[Lista de correcciones de bugs]\n+\n+### 🚀 Improvements\n+[Lista de mejoras]\n+\n+### 🔧 Technical\n+[Cambios técnicos internos]\n+\n+## 🏷️ INFORMACIÓN DE VERSIÓN\n+- **Versión**: [versión calculada]\n+- **Prefijo**: [alpha/beta/rc/stable]\n+- **Canal OTA**: [dev/beta/stable]\n+- **Tipo de cambio**: [major/minor/patch]\n+\n+## 📝 NOTAS DE RELEASE\n+[Texto descriptivo para usuarios finales]\n+\\`\\`\\`\n+\n+${STANDARD_PROMPT_SUFFIX}`;\n+}\n+\n+/**\n+ * Parser genérico para respuestas de Gemini\n+ */\n+export class GeminiResponseParser {\n+  /**\n+   * Extrae múltiples propuestas de commit del formato estándar\n+   */\n+  static parseCommitProposals(response: string): Array<{\n+    title: string;\n+    description: string;\n+    technical: string;\n+    changelog: string;\n+  }> {\n+    const proposals: Array<{\n+      title: string;\n+      description: string; \n+      technical: string;\n+      changelog: string;\n+    }> = [];\n+\n+    // Buscar todas las propuestas con el formato: ### **Propuesta de Commit #N**\n+    const proposalPattern = /###\\s*\\*\\*Propuesta de Commit #\\d+\\*\\*/g;\n+    const proposalMatches = Array.from(response.matchAll(proposalPattern));\n+    \n+    if (proposalMatches.length === 0) {\n+      // Formato de un solo commit sin numeración\n+      const codeBlock = this.extractCodeBlock(response);\n+      if (codeBlock) {\n+        const parsed = this.parseCommitContent(codeBlock);\n+        if (parsed) proposals.push(parsed);\n+      }\n+    } else {\n+      // Múltiples propuestas numeradas\n+      for (let i = 0; i < proposalMatches.length; i++) {\n+        const startIndex = proposalMatches[i].index!;\n+        const endIndex = proposalMatches[i + 1]?.index || response.length;\n+        const proposalSection = response.substring(startIndex, endIndex);\n+        \n+        const codeBlock = this.extractCodeBlock(proposalSection);\n+        if (codeBlock) {\n+          const parsed = this.parseCommitContent(codeBlock);\n+          if (parsed) proposals.push(parsed);\n+        }\n+      }\n+    }\n+\n+    return proposals;\n+  }\n+\n+  /**\n+   * Extrae bloque de código markdown\n+   */\n+  private static extractCodeBlock(text: string): string | null {\n+    const patterns = [\n+      /```markdown\\s*\\n([\\s\\S]*?)\\n```/,  // ```markdown\n+      /```\\s*\\n([\\s\\S]*?)\\n```/,        // ``` genérico  \n+      /```([\\s\\S]*?)```/                 // sin saltos\n+    ];\n+    \n+    for (const pattern of patterns) {\n+      const match = text.match(pattern);\n+      if (match) return match[1].trim();\n+    }\n+    \n+    return null;\n+  }\n+\n+  /**\n+   * Parsea el contenido de un commit individual\n+   */\n+  private static parseCommitContent(content: string): {\n+    title: string;\n+    description: string;\n+    technical: string;\n+    changelog: string;\n+  } | null {\n+    const lines = content.split('\\n');\n+    \n+    // Título (primera línea no vacía)\n+    let title = '';\n+    let titleIndex = 0;\n+    for (let i = 0; i < lines.length; i++) {\n+      if (lines[i].trim()) {\n+        title = lines[i].trim();\n+        titleIndex = i;\n+        break;\n+      }\n+    }\n+\n+    if (!title) return null;\n+\n+    // Extraer secciones\n+    let description = '';\n+    let technical = '';\n+    let changelog = '';\n+    let currentSection = 'description';\n+\n+    for (let i = titleIndex + 1; i < lines.length; i++) {\n+      const line = lines[i];\n+\n+      if (line.includes('<technical>')) {\n+        currentSection = 'technical';\n+        continue;\n+      } else if (line.includes('</technical>')) {\n+        currentSection = 'none';\n+        continue;\n+      } else if (line.includes('<changelog>')) {\n+        currentSection = 'changelog';\n+        continue;\n+      } else if (line.includes('</changelog>')) {\n+        currentSection = 'none';\n+        continue;\n+      }\n+\n+      if (currentSection === 'description' && line.trim()) {\n+        description += line + '\\n';\n+      } else if (currentSection === 'technical') {\n+        technical += line + '\\n';\n+      } else if (currentSection === 'changelog') {\n+        changelog += line + '\\n';\n+      }\n+    }\n+\n+    return {\n+      title,\n+      description: description.trim(),\n+      technical: technical.trim(),\n+      changelog: changelog.trim()\n+    };\n+  }\n+\n+  /**\n+   * Parsea respuesta de workflow en formato estándar\n+   */\n+  static parseWorkflowResponse(response: string): {\n+    analysis: string;\n+    impact: string;\n+    recommendation: string;\n+    macosCommands: string[];\n+    linuxCommands: string[];\n+    verifications: string[];\n+  } {\n+    const analysisMatch = response.match(/🎯\\s*\\*\\*ANÁLISIS\\*\\*:\\s*(.+)/);\n+    const impactMatch = response.match(/📊\\s*\\*\\*IMPACTO\\*\\*:\\s*(.+)/);\n+    const recommendationMatch = response.match(/🚀\\s*\\*\\*RECOMENDACIÓN\\*\\*:\\s*(.+)/);\n+\n+    // Extraer comandos macOS\n+    const macosSection = response.match(/##\\s*🖥️\\s*COMANDOS PARA macOS\\s*```bash\\s*([\\s\\S]*?)\\s*```/);\n+    const macosCommands = macosSection ? macosSection[1].split('\\n').filter(line => \n+      line.trim() && !line.startsWith('#')\n+    ) : [];\n+\n+    // Extraer comandos Linux ARM\n+    const linuxSection = response.match(/##\\s*🐧\\s*COMANDOS PARA LINUX ARM[\\s\\S]*?```bash\\s*([\\s\\S]*?)\\s*```/);\n+    const linuxCommands = linuxSection ? linuxSection[1].split('\\n').filter(line => \n+      line.trim() && !line.startsWith('#')\n+    ) : [];\n+\n+    // Extraer verificaciones\n+    const verificationsSection = response.match(/##\\s*✅\\s*VERIFICACIONES AUTOMÁTICAS\\s*([\\s\\S]*?)```/);\n+    const verifications = verificationsSection ? verificationsSection[1].split('\\n').filter(line =>\n+      line.trim().startsWith('-')\n+    ).map(line => line.replace(/^-\\s*/, '')) : [];\n+\n+    return {\n+      analysis: analysisMatch?.[1] || 'No disponible',\n+      impact: impactMatch?.[1] || 'No disponible', \n+      recommendation: recommendationMatch?.[1] || 'No disponible',\n+      macosCommands,\n+      linuxCommands,\n+      verifications\n+    };\n+  }\n+}\n\\ No newline at end of file",
      "lines_added": 422,
      "lines_removed": 0,
      "is_binary": false
    },
    {
      "path": "project-utils/version-manager.ts",
      "status": "added",
      "diff": "diff --git a/project-utils/version-manager.ts b/project-utils/version-manager.ts\nnew file mode 100644\nindex 0000000..b9639b2\n--- /dev/null\n+++ b/project-utils/version-manager.ts\n@@ -0,0 +1,967 @@\n+#!/usr/bin/env node\n+\n+/**\n+ * Version Manager para Better Logger\n+ * Analiza commits, extrae changelog, asigna versiones y actualiza archivos\n+ */\n+\n+import { readFileSync, writeFileSync, existsSync } from 'fs';\n+import { join } from 'path';\n+\n+interface ChangelogEntry {\n+  type: 'feature' | 'fix' | 'improvement' | 'breaking';\n+  title: string;\n+  description: string;\n+}\n+\n+interface Version {\n+  version: string;\n+  date: string;\n+  type: 'initial' | 'major' | 'minor' | 'patch';\n+  title: string;\n+  changes: ChangelogEntry[];\n+  technical_notes: string;\n+  breaking_changes: string[];\n+  commit_hash: string;\n+  prefix?: string; // pre-alpha, alpha, beta, rc, o undefined para stable\n+}\n+\n+interface ChangelogData {\n+  current_version: string;\n+  versions: Version[];\n+}\n+\n+interface CommitInfo {\n+  hash: string;\n+  date: string;\n+  title: string;\n+  description: string;\n+  technical_section?: string;\n+  changelog_section?: string;\n+}\n+\n+class VersionManager {\n+  private projectRoot: string;\n+  private changelogPath: string;\n+  private packageJsonPath: string;\n+  private tauriConfigPath: string;\n+  private cargoTomlPath: string;\n+\n+  constructor() {\n+    this.projectRoot = process.cwd();\n+    this.changelogPath = join(this.projectRoot, 'CHANGELOG.json');\n+    this.packageJsonPath = join(this.projectRoot, 'package.json');\n+  }\n+\n+  /**\n+   * Ejecuta comando git y devuelve resultado\n+   */\n+  private async gitCommand(args: string[]): Promise<string> {\n+    const { spawn } = await import('child_process');\n+    \n+    return new Promise((resolve, reject) => {\n+      const proc = spawn('git', args, {\n+        cwd: this.projectRoot,\n+        stdio: ['pipe', 'pipe', 'pipe']\n+      });\n+\n+      let stdout = '';\n+      let stderr = '';\n+\n+      proc.stdout?.on('data', (data) => {\n+        stdout += data.toString();\n+      });\n+\n+      proc.stderr?.on('data', (data) => {\n+        stderr += data.toString();\n+      });\n+\n+      proc.on('exit', (code) => {\n+        if (code !== 0) {\n+          reject(new Error(`Git error: ${stderr || 'Git command failed'}`));\n+        } else {\n+          resolve(stdout.trim());\n+        }\n+      });\n+\n+      proc.on('error', (error) => {\n+        reject(error);\n+      });\n+    });\n+  }\n+\n+  /**\n+   * Obtiene todos los commits desde un hash específico\n+   */\n+  private async getCommitsSince(sinceHash?: string): Promise<CommitInfo[]> {\n+    const args = ['log', '--pretty=format:%H|%ci|%s', '--reverse'];\n+    if (sinceHash) {\n+      args.push(`${sinceHash}..HEAD`);\n+    }\n+\n+    const output = await this.gitCommand(args);\n+    if (!output) return [];\n+\n+    const commits: CommitInfo[] = [];\n+    \n+    for (const line of output.split('\\n')) {\n+      const [hash, date, title] = line.split('|');\n+      if (!hash) continue;\n+\n+      // Obtener el mensaje completo del commit\n+      try {\n+        const fullMessage = await this.gitCommand(['log', '-1', '--pretty=format:%B', hash]);\n+        const sections = this.parseCommitMessage(fullMessage);\n+        \n+        commits.push({\n+          hash,\n+          date: new Date(date).toISOString().split('T')[0],\n+          title,\n+          description: fullMessage,\n+          technical_section: sections.technical,\n+          changelog_section: sections.changelog\n+        });\n+      } catch (error) {\n+        console.warn(`⚠️ No se pudo obtener mensaje completo para commit ${hash}: ${error}`);\n+        commits.push({\n+          hash,\n+          date: new Date(date).toISOString().split('T')[0],\n+          title,\n+          description: title\n+        });\n+      }\n+    }\n+\n+    return commits;\n+  }\n+\n+  /**\n+   * Extrae secciones <technical> y <changelog> de un mensaje de commit\n+   */\n+  private parseCommitMessage(message: string): { technical?: string; changelog?: string } {\n+    const technicalMatch = message.match(/<technical>([\\s\\S]*?)<\\/technical>/);\n+    const changelogMatch = message.match(/<changelog>([\\s\\S]*?)<\\/changelog>/);\n+\n+    return {\n+      technical: technicalMatch?.[1]?.trim(),\n+      changelog: changelogMatch?.[1]?.trim()\n+    };\n+  }\n+\n+  /**\n+   * Convierte sección de changelog en entradas estructuradas\n+   */\n+  private parseChangelogSection(changelog: string): ChangelogEntry[] {\n+    if (!changelog) return [];\n+\n+    const entries: ChangelogEntry[] = [];\n+    const lines = changelog.split('\\n').map(line => line.trim()).filter(line => line);\n+\n+    let currentSection = '';\n+    let currentEntries: string[] = [];\n+\n+    for (const line of lines) {\n+      if (line.startsWith('##')) {\n+        // Procesar sección anterior\n+        if (currentSection && currentEntries.length > 0) {\n+          entries.push(...this.processSectionEntries(currentSection, currentEntries));\n+        }\n+\n+        // Nueva sección\n+        currentSection = line.replace(/^##\\s*/, '').toLowerCase();\n+        currentEntries = [];\n+      } else if (line.startsWith('-')) {\n+        currentEntries.push(line.replace(/^-\\s*/, ''));\n+      }\n+    }\n+\n+    // Procesar última sección\n+    if (currentSection && currentEntries.length > 0) {\n+      entries.push(...this.processSectionEntries(currentSection, currentEntries));\n+    }\n+\n+    return entries;\n+  }\n+\n+  /**\n+   * Procesa entradas de una sección específica del changelog\n+   */\n+  private processSectionEntries(section: string, entries: string[]): ChangelogEntry[] {\n+    let type: ChangelogEntry['type'] = 'improvement';\n+\n+    if (section.includes('fix') || section.includes('🐛')) {\n+      type = 'fix';\n+    } else if (section.includes('feature') || section.includes('✨')) {\n+      type = 'feature';\n+    } else if (section.includes('breaking')) {\n+      type = 'breaking';\n+    }\n+\n+    return entries.map(entry => ({\n+      type,\n+      title: entry.split('.')[0] || entry,\n+      description: entry\n+    }));\n+  }\n+\n+  /**\n+   * Determina el tipo de versión basado en los cambios\n+   */\n+  private determineVersionType(commits: CommitInfo[]): Version['type'] {\n+    const hasBreaking = commits.some(c => \n+      c.changelog_section?.includes('breaking') || \n+      c.title.toLowerCase().includes('breaking')\n+    );\n+    \n+    if (hasBreaking) return 'major';\n+\n+    const hasFeature = commits.some(c => \n+      c.title.startsWith('feat(') || \n+      c.changelog_section?.includes('✨') ||\n+      c.changelog_section?.toLowerCase().includes('feature')\n+    );\n+    \n+    if (hasFeature) return 'minor';\n+\n+    return 'patch';\n+  }\n+\n+  /**\n+   * Incrementa versión según el tipo, considerando prefijos\n+   */\n+  private incrementVersion(\n+    currentVersion: string, \n+    type: Version['type'], \n+    targetPrefix?: string,\n+    overrideType?: Version['type']\n+  ): string {\n+    // Extraer prefix y versión base\n+    const { prefix, baseVersion } = this.parseVersionString(currentVersion);\n+    const [major, minor, patch] = baseVersion.split('.').map(Number);\n+\n+    // Si se especifica un targetPrefix, usarlo; si no, mantener el actual\n+    const newPrefix = targetPrefix !== undefined ? targetPrefix : prefix;\n+\n+    // Si se especifica un override del tipo, usarlo\n+    const actualType = overrideType || type;\n+\n+    let newBaseVersion: string;\n+    switch (actualType) {\n+      case 'major':\n+        newBaseVersion = `${major + 1}.0.0`;\n+        break;\n+      case 'minor':\n+        newBaseVersion = `${major}.${minor + 1}.0`;\n+        break;\n+      case 'patch':\n+        newBaseVersion = `${major}.${minor}.${patch + 1}`;\n+        break;\n+      default:\n+        newBaseVersion = baseVersion;\n+    }\n+\n+    return this.buildVersionString(newPrefix, newBaseVersion);\n+  }\n+\n+  /**\n+   * Parsea una versión con posible prefijo\n+   */\n+  private parseVersionString(version: string): { prefix?: string; baseVersion: string } {\n+    const prefixMatch = version.match(/^(pre-alpha-|alpha-|beta-|rc-)?(.+)$/);\n+    if (prefixMatch) {\n+      return {\n+        prefix: prefixMatch[1]?.replace(/-$/, ''), // Remover el guión final\n+        baseVersion: prefixMatch[2]\n+      };\n+    }\n+    return { baseVersion: version };\n+  }\n+\n+  /**\n+   * Construye una versión con prefijo\n+   */\n+  private buildVersionString(prefix?: string, baseVersion?: string): string {\n+    if (!baseVersion) return '1.0.0';\n+    if (!prefix) return baseVersion; // Sin prefijo = estable\n+    return `${prefix}-${baseVersion}`;\n+  }\n+\n+  /**\n+   * Valida que la transición de prefijo sea lógica\n+   */\n+  private validatePrefixTransition(currentVersion: string, targetPrefix?: string): void {\n+    const { prefix: currentPrefix } = this.parseVersionString(currentVersion);\n+    \n+    // Definir orden de prefijos (undefined = stable)\n+    const prefixOrder = ['pre-alpha', 'alpha', 'beta', 'rc', undefined];\n+    const currentIndex = prefixOrder.indexOf(currentPrefix);\n+    const targetIndex = prefixOrder.indexOf(targetPrefix);\n+\n+    // Permitir cualquier transición, pero advertir sobre regresiones\n+    if (currentIndex !== -1 && targetIndex !== -1 && targetIndex < currentIndex) {\n+      console.warn(`⚠️ Advertencia: Transición de prefijo regresiva ${currentPrefix || 'stable'} → ${targetPrefix || 'stable'}`);\n+      console.warn('   Esto podría confundir a los usuarios sobre el estado de estabilidad.');\n+    }\n+\n+    // Validar prefijos válidos\n+    const validPrefixes = ['pre-alpha', 'alpha', 'beta', 'rc'];\n+    if (targetPrefix && !validPrefixes.includes(targetPrefix)) {\n+      throw new Error(`❌ Prefijo inválido: ${targetPrefix}. Válidos: ${validPrefixes.join(', ')}, o sin prefijo para stable`);\n+    }\n+  }\n+\n+  /**\n+   * Carga datos actuales del changelog\n+   */\n+  private loadChangelogData(): ChangelogData {\n+    if (existsSync(this.changelogPath)) {\n+      try {\n+        const content = readFileSync(this.changelogPath, 'utf-8');\n+        return JSON.parse(content);\n+      } catch (error) {\n+        console.warn('⚠️ Error leyendo changelog.json, creando nuevo');\n+      }\n+    }\n+\n+    return {\n+      current_version: '0.1.0',\n+      versions: []\n+    };\n+  }\n+\n+  /**\n+   * Obtiene el último commit versionado\n+   */\n+  private getLastVersionedCommit(data: ChangelogData): string | undefined {\n+    const sortedVersions = [...data.versions].sort((a, b) => \n+      new Date(b.date).getTime() - new Date(a.date).getTime()\n+    );\n+    \n+    return sortedVersions[0]?.commit_hash;\n+  }\n+\n+  /**\n+   * Analiza commits y genera nueva versión\n+   */\n+  async analyzeAndVersion(options: {\n+    type?: Version['type'];\n+    prefix?: string;\n+  } = {}): Promise<void> {\n+    console.log('🚀 Iniciando análisis de versionado...\\n');\n+\n+    try {\n+      // Cargar datos existentes\n+      const changelogData = this.loadChangelogData();\n+      console.log(`📋 Versión actual: ${changelogData.current_version}`);\n+\n+      // Obtener último commit versionado\n+      const lastVersionedCommit = this.getLastVersionedCommit(changelogData);\n+      console.log(`🔍 Último commit versionado: ${lastVersionedCommit || 'ninguno'}`);\n+\n+      // Obtener commits nuevos\n+      const newCommits = await this.getCommitsSince(lastVersionedCommit);\n+      console.log(`📝 Encontrados ${newCommits.length} commits nuevos`);\n+\n+      if (newCommits.length === 0) {\n+        console.log('✅ No hay commits nuevos para versionar');\n+        return;\n+      }\n+\n+      // Mostrar commits que se van a versionar\n+      console.log('\\n📋 Commits que se incluirán en la nueva versión:');\n+      newCommits.forEach(commit => {\n+        console.log(`  • ${commit.hash.slice(0, 7)} - ${commit.title}`);\n+      });\n+\n+      // Determinar tipo de versión\n+      const detectedVersionType = this.determineVersionType(newCommits);\n+      const finalVersionType = options.type || detectedVersionType;\n+      \n+      // Si se especifica un prefix, validarlo\n+      if (options.prefix !== undefined) {\n+        this.validatePrefixTransition(changelogData.current_version, options.prefix);\n+      }\n+\n+      const newVersion = this.incrementVersion(\n+        changelogData.current_version, \n+        detectedVersionType, \n+        options.prefix,\n+        finalVersionType\n+      );\n+      \n+      console.log(`\\n🏷️ Nueva versión: ${changelogData.current_version} → ${newVersion}`);\n+      console.log(`📊 Tipo detectado: ${detectedVersionType}${options.type ? ` → Forzado: ${options.type}` : ''}`);\n+      if (options.prefix !== undefined) {\n+        const { prefix: currentPrefix } = this.parseVersionString(changelogData.current_version);\n+        console.log(`🏷️ Prefix: ${currentPrefix || 'stable'} → ${options.prefix || 'stable'}`);\n+      }\n+\n+      // Procesar cambios\n+      const allChanges: ChangelogEntry[] = [];\n+      let technicalNotes = '';\n+\n+      for (const commit of newCommits) {\n+        if (commit.changelog_section) {\n+          const changes = this.parseChangelogSection(commit.changelog_section);\n+          allChanges.push(...changes);\n+        } else {\n+          // Generar entrada básica desde el título del commit\n+          let type: ChangelogEntry['type'] = 'improvement';\n+          if (commit.title.startsWith('feat(')) type = 'feature';\n+          else if (commit.title.startsWith('fix(')) type = 'fix';\n+\n+          allChanges.push({\n+            type,\n+            title: commit.title.replace(/^(feat|fix|refactor)\\([^)]+\\)\\s*-\\s*/, ''),\n+            description: commit.title\n+          });\n+        }\n+\n+        if (commit.technical_section) {\n+          technicalNotes += `\\n${commit.technical_section}`;\n+        }\n+      }\n+\n+      // Crear nueva versión\n+      const { prefix } = this.parseVersionString(newVersion);\n+      const newVersionEntry: Version = {\n+        version: newVersion,\n+        date: new Date().toISOString().split('T')[0],\n+        type: finalVersionType,\n+        title: this.generateVersionTitle(allChanges, finalVersionType, prefix),\n+        changes: allChanges,\n+        technical_notes: technicalNotes.trim(),\n+        breaking_changes: allChanges\n+          .filter(c => c.type === 'breaking')\n+          .map(c => c.description),\n+        commit_hash: newCommits[newCommits.length - 1].hash,\n+        prefix\n+      };\n+\n+      // Actualizar datos\n+      changelogData.current_version = newVersion;\n+      changelogData.versions.unshift(newVersionEntry); // Agregar al principio\n+\n+      // Guardar changelog actualizado\n+      writeFileSync(this.changelogPath, JSON.stringify(changelogData, null, 2));\n+      console.log(`💾 Changelog actualizado: ${this.changelogPath}`);\n+\n+      // Actualizar todos los archivos de configuración\n+      await this.updateAllVersionFiles(newVersion);\n+\n+      console.log(`\\n✅ Versionado completado exitosamente!`);\n+      console.log(`📦 Nueva versión: ${newVersion}`);\n+      console.log(`📋 Cambios incluidos: ${allChanges.length}`);\n+      console.log(`📝 Commits procesados: ${newCommits.length}`);\n+      \n+      // Sugerir creación de release si hay archivos de distribución disponibles\n+      const distDir = join(this.projectRoot, 'dist');\n+      if (existsSync(distDir)) {\n+        console.log(`\\n💡 Archivos de distribución detectados en ${distDir}`);\n+        console.log(`🚀 Para crear release en GitHub ejecuta:`);\n+        console.log(`   npm run release:github`);\n+      }\n+\n+    } catch (error) {\n+      console.error('❌ Error durante el versionado:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * Genera título descriptivo para la versión\n+   */\n+  private generateVersionTitle(changes: ChangelogEntry[], type: Version['type'], prefix?: string): string {\n+    const features = changes.filter(c => c.type === 'feature');\n+    const fixes = changes.filter(c => c.type === 'fix');\n+    const improvements = changes.filter(c => c.type === 'improvement');\n+\n+    // Prefijo para el título\n+    const prefixLabel = prefix ? \n+      `Versión ${prefix.charAt(0).toUpperCase() + prefix.slice(1)} - ` : '';\n+\n+    if (type === 'major') {\n+      return `${prefixLabel}Actualización mayor con cambios significativos`;\n+    }\n+\n+    if (features.length > 0) {\n+      const mainFeature = features[0].title;\n+      if (features.length === 1) {\n+        return `${prefixLabel}Nueva funcionalidad: ${mainFeature}`;\n+      }\n+      return `${prefixLabel}Nuevas funcionalidades incluyendo ${mainFeature} y ${features.length - 1} más`;\n+    }\n+\n+    if (fixes.length > 0) {\n+      if (fixes.length === 1) {\n+        return `${prefixLabel}Corrección: ${fixes[0].title}`;\n+      }\n+      return `${prefixLabel}Correcciones y mejoras (${fixes.length} fixes, ${improvements.length} mejoras)`;\n+    }\n+\n+    return `${prefixLabel}Mejoras y optimizaciones`;\n+  }\n+\n+  /**\n+   * Actualiza versión en todos los archivos de configuración\n+   */\n+  private async updateAllVersionFiles(version: string): Promise<void> {\n+    console.log(`🔄 Sincronizando versión ${version} en todos los archivos...`);\n+    \n+    // Actualizar package.json\n+    await this.updatePackageVersion(version);\n+    \n+    // No hay archivos adicionales que actualizar para Better Logger\n+    \n+    // Better Logger no requiere sincronización OTA\n+    \n+    console.log(`✅ Todas las versiones sincronizadas en ${version}`);\n+  }\n+\n+  /**\n+   * Actualiza versión en package.json\n+   */\n+  private async updatePackageVersion(version: string): Promise<void> {\n+    const packageJson = JSON.parse(readFileSync(this.packageJsonPath, 'utf-8'));\n+    packageJson.version = version;\n+    writeFileSync(this.packageJsonPath, JSON.stringify(packageJson, null, 2) + '\\n');\n+    console.log(`📦 Actualizado package.json → ${version}`);\n+  }\n+\n+  /**\n+   * Actualiza versión en tauri.conf.json\n+   * Tauri requiere versionado semántico estricto (sin prefijos)\n+   */\n+  private async updateTauriVersion(version: string): Promise<void> {\n+    const tauriConfig = JSON.parse(readFileSync(this.tauriConfigPath, 'utf-8'));\n+    \n+    // Extraer solo la versión base para Tauri (sin prefijos)\n+    const { baseVersion } = this.parseVersionString(version);\n+    tauriConfig.version = baseVersion;\n+    \n+    writeFileSync(this.tauriConfigPath, JSON.stringify(tauriConfig, null, 2) + '\\n');\n+    console.log(`🦀 Actualizado tauri.conf.json → ${baseVersion} (sin prefijo para semver)`);\n+  }\n+\n+  /**\n+   * Actualiza versión en Cargo.toml\n+   * Cargo también requiere versionado semántico estricto (sin prefijos)\n+   */\n+  private async updateCargoVersion(version: string): Promise<void> {\n+    const cargoContent = readFileSync(this.cargoTomlPath, 'utf-8');\n+    \n+    // Extraer solo la versión base para Cargo (sin prefijos)\n+    const { baseVersion } = this.parseVersionString(version);\n+    const updatedContent = cargoContent.replace(\n+      /^version\\s*=\\s*\"[^\"]*\"/m,\n+      `version = \"${baseVersion}\"`\n+    );\n+    \n+    writeFileSync(this.cargoTomlPath, updatedContent);\n+    console.log(`🦀 Actualizado Cargo.toml → ${baseVersion} (sin prefijo para semver)`);\n+  }\n+\n+  /**\n+   * Sincroniza la nueva versión con el sistema OTA\n+   * Actualiza versions.json y mapea prefijos a canales OTA\n+   */\n+  private async syncWithOTASystem(version: string): Promise<void> {\n+    const versionsPath = join(this.projectRoot, 'versions.json');\n+    \n+    try {\n+      // Extraer información de la versión\n+      const { prefix, baseVersion } = this.parseVersionString(version);\n+      \n+      // Mapear prefix a canal OTA\n+      let targetChannel = 'stable';\n+      if (prefix === 'alpha' || prefix === 'beta') {\n+        targetChannel = 'beta';\n+      } else if (prefix === 'pre-alpha' || prefix === 'rc') {\n+        targetChannel = 'dev';\n+      }\n+      \n+      if (!existsSync(versionsPath)) {\n+        console.log('⚠️ versions.json no existe, creando estructura inicial...');\n+        await this.createInitialVersionsFile(baseVersion, targetChannel);\n+        return;\n+      }\n+\n+      // Leer versions.json actual\n+      const versionsData = JSON.parse(readFileSync(versionsPath, 'utf-8'));\n+      const currentDate = new Date().toISOString();\n+      const buildNumber = currentDate.replace(/[-:.TZ]/g, '').slice(0, 12);\n+\n+      // Actualizar versiones principales\n+      versionsData.frontend.version = baseVersion;\n+      versionsData.frontend.build = buildNumber;\n+      versionsData.frontend.lastUpdated = currentDate;\n+      \n+      versionsData.backend.version = baseVersion;\n+      versionsData.backend.build = buildNumber; \n+      versionsData.backend.lastUpdated = currentDate;\n+\n+      // Actualizar canal OTA correspondiente\n+      versionsData.updateChannels[targetChannel].frontend = version;\n+      versionsData.updateChannels[targetChannel].backend = version;\n+\n+      // Agregar entrada de changelog OTA\n+      const changelogEntry = {\n+        version: baseVersion,\n+        date: new Date().toISOString().split('T')[0],\n+        changes: [`Actualización automática desde version-manager (${version})`]\n+      };\n+\n+      // Agregar al inicio del changelog (más reciente primero)\n+      if (!versionsData.frontend.changelog.find((entry: any) => entry.version === baseVersion)) {\n+        versionsData.frontend.changelog.unshift(changelogEntry);\n+        versionsData.backend.changelog.unshift(changelogEntry);\n+      }\n+\n+      // Actualizar matriz de compatibilidad\n+      const compatibilityEntry = versionsData.compatibility.matrix.find((entry: any) => \n+        entry.backend === baseVersion\n+      );\n+      \n+      if (!compatibilityEntry) {\n+        versionsData.compatibility.matrix.unshift({\n+          backend: baseVersion,\n+          frontend: [baseVersion]\n+        });\n+      }\n+\n+      // Guardar versions.json actualizado\n+      writeFileSync(versionsPath, JSON.stringify(versionsData, null, 2));\n+      console.log(`🔄 Sistema OTA sincronizado → ${baseVersion} (canal: ${targetChannel})`);\n+      \n+    } catch (error) {\n+      console.warn(`⚠️ Error sincronizando sistema OTA: ${error}`);\n+      console.warn('El versionado principal continuará sin sincronización OTA');\n+    }\n+  }\n+\n+  /**\n+   * Crea archivo versions.json inicial cuando no existe\n+   */\n+  private async createInitialVersionsFile(version: string, channel: string): Promise<void> {\n+    const currentDate = new Date().toISOString();\n+    const buildNumber = currentDate.replace(/[-:.TZ]/g, '').slice(0, 12);\n+    \n+    const initialVersions = {\n+      frontend: {\n+        version,\n+        build: buildNumber,\n+        lastUpdated: currentDate,\n+        changelog: [{\n+          version,\n+          date: new Date().toISOString().split('T')[0],\n+          changes: ['Inicialización automática del sistema OTA']\n+        }]\n+      },\n+      backend: {\n+        version,\n+        build: buildNumber,\n+        lastUpdated: currentDate,\n+        minimumFrontend: version,\n+        changelog: [{\n+          version,\n+          date: new Date().toISOString().split('T')[0], \n+          changes: ['Inicialización automática del sistema OTA']\n+        }]\n+      },\n+      compatibility: {\n+        matrix: [{\n+          backend: version,\n+          frontend: [version]\n+        }]\n+      },\n+      updateChannels: {\n+        stable: { frontend: version, backend: version },\n+        beta: { frontend: version, backend: version },\n+        dev: { frontend: version, backend: version }\n+      }\n+    };\n+\n+    const versionsPath = join(this.projectRoot, 'versions.json');\n+    writeFileSync(versionsPath, JSON.stringify(initialVersions, null, 2));\n+    console.log(`🆕 Archivo versions.json creado con versión inicial: ${version}`);\n+  }\n+\n+  /**\n+   * Sincroniza todos los archivos de configuración con la versión actual del changelog\n+   */\n+  async syncVersionFiles(): Promise<void> {\n+    console.log('🔄 Sincronizando archivos de configuración con versión actual...\\n');\n+\n+    try {\n+      // Cargar datos del changelog\n+      const changelogData = this.loadChangelogData();\n+      const currentVersion = changelogData.current_version;\n+      \n+      console.log(`📋 Versión actual en changelog: ${currentVersion}`);\n+\n+      // Actualizar todos los archivos de configuración\n+      await this.updateAllVersionFiles(currentVersion);\n+\n+      console.log(`\\n✅ Sincronización completada exitosamente!`);\n+      console.log(`📦 Todos los archivos actualizados a: ${currentVersion}`);\n+\n+    } catch (error) {\n+      console.error('❌ Error durante la sincronización:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * Procesa todos los commits existentes (para inicialización)\n+   */\n+  async initializeFromHistory(): Promise<void> {\n+    console.log('🔄 Inicializando changelog desde historial completo...\\n');\n+\n+    try {\n+      // Obtener TODOS los commits\n+      const allCommits = await this.getCommitsSince();\n+      console.log(`📝 Encontrados ${allCommits.length} commits totales en el historial`);\n+\n+      if (allCommits.length === 0) {\n+        console.log('✅ No hay commits para procesar');\n+        return;\n+      }\n+\n+      // Agrupar commits por tipo y fecha para crear versiones lógicas\n+      const versionGroups = this.groupCommitsIntoVersions(allCommits);\n+      console.log(`📊 Agrupados en ${versionGroups.length} versiones lógicas`);\n+\n+      const changelogData: ChangelogData = {\n+        current_version: '0.1.0',\n+        versions: []\n+      };\n+\n+      // Procesar cada grupo como una versión\n+      for (let i = 0; i < versionGroups.length; i++) {\n+        const group = versionGroups[i];\n+        const versionNumber = this.generateVersionNumber(i, versionGroups.length);\n+        \n+        const allChanges: ChangelogEntry[] = [];\n+        let technicalNotes = '';\n+\n+        for (const commit of group.commits) {\n+          if (commit.changelog_section) {\n+            const changes = this.parseChangelogSection(commit.changelog_section);\n+            allChanges.push(...changes);\n+          } else {\n+            let type: ChangelogEntry['type'] = 'improvement';\n+            if (commit.title.startsWith('feat(')) type = 'feature';\n+            else if (commit.title.startsWith('fix(')) type = 'fix';\n+\n+            allChanges.push({\n+              type,\n+              title: commit.title.replace(/^(feat|fix|refactor)\\([^)]+\\)\\s*-\\s*/, ''),\n+              description: commit.title\n+            });\n+          }\n+\n+          if (commit.technical_section) {\n+            technicalNotes += `\\n${commit.technical_section}`;\n+          }\n+        }\n+\n+        const version: Version = {\n+          version: versionNumber,\n+          date: group.date,\n+          type: group.type,\n+          title: group.title,\n+          changes: allChanges,\n+          technical_notes: technicalNotes.trim(),\n+          breaking_changes: allChanges\n+            .filter(c => c.type === 'breaking')\n+            .map(c => c.description),\n+          commit_hash: group.commits[group.commits.length - 1].hash\n+        };\n+\n+        changelogData.versions.push(version);\n+      }\n+\n+      // La versión más reciente es la actual\n+      if (changelogData.versions.length > 0) {\n+        changelogData.current_version = changelogData.versions[0].version;\n+      }\n+\n+      // Guardar changelog\n+      writeFileSync(this.changelogPath, JSON.stringify(changelogData, null, 2));\n+      console.log(`💾 Changelog inicializado: ${this.changelogPath}`);\n+\n+      // Actualizar archivos de configuración\n+      await this.updateAllVersionFiles(changelogData.current_version);\n+\n+      console.log(`\\n✅ Inicialización completada!`);\n+      console.log(`📦 Versión actual: ${changelogData.current_version}`);\n+      console.log(`📋 Versiones creadas: ${changelogData.versions.length}`);\n+\n+    } catch (error) {\n+      console.error('❌ Error durante la inicialización:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * Agrupa commits en versiones lógicas\n+   */\n+  private groupCommitsIntoVersions(commits: CommitInfo[]): Array<{\n+    commits: CommitInfo[];\n+    date: string;\n+    type: Version['type'];\n+    title: string;\n+  }> {\n+    const groups: Array<{\n+      commits: CommitInfo[];\n+      date: string;\n+      type: Version['type'];\n+      title: string;\n+    }> = [];\n+\n+    // Agrupar por fechas similares y tipos de commits\n+    let currentGroup: CommitInfo[] = [];\n+    let currentDate = '';\n+\n+    for (let i = 0; i < commits.length; i++) {\n+      const commit = commits[i];\n+      \n+      // Si es primer commit o fecha muy diferente, crear nuevo grupo\n+      if (!currentDate || this.daysDifference(currentDate, commit.date) > 7 || currentGroup.length >= 10) {\n+        if (currentGroup.length > 0) {\n+          groups.push({\n+            commits: [...currentGroup],\n+            date: currentDate,\n+            type: this.determineVersionType(currentGroup),\n+            title: this.generateGroupTitle(currentGroup)\n+          });\n+        }\n+        currentGroup = [commit];\n+        currentDate = commit.date;\n+      } else {\n+        currentGroup.push(commit);\n+      }\n+    }\n+\n+    // Agregar último grupo\n+    if (currentGroup.length > 0) {\n+      groups.push({\n+        commits: currentGroup,\n+        date: currentDate,\n+        type: this.determineVersionType(currentGroup),\n+        title: this.generateGroupTitle(currentGroup)\n+      });\n+    }\n+\n+    return groups.reverse(); // Más recientes primero\n+  }\n+\n+  /**\n+   * Calcula diferencia en días entre fechas\n+   */\n+  private daysDifference(date1: string, date2: string): number {\n+    const d1 = new Date(date1).getTime();\n+    const d2 = new Date(date2).getTime();\n+    return Math.abs((d2 - d1) / (1000 * 60 * 60 * 24));\n+  }\n+\n+  /**\n+   * Genera título para un grupo de commits\n+   */\n+  private generateGroupTitle(commits: CommitInfo[]): string {\n+    const features = commits.filter(c => c.title.startsWith('feat('));\n+    const fixes = commits.filter(c => c.title.startsWith('fix('));\n+    \n+    if (features.length > 0) {\n+      return `Nuevas funcionalidades y mejoras`;\n+    }\n+    if (fixes.length > 0) {\n+      return `Correcciones y optimizaciones`;\n+    }\n+    return `Mejoras del sistema`;\n+  }\n+\n+  /**\n+   * Genera número de versión para inicialización\n+   */\n+  private generateVersionNumber(index: number, total: number): string {\n+    if (total === 1) return '1.0.0';\n+    \n+    if (index === 0) return '1.0.0'; // Versión más reciente\n+    if (index < 3) return `0.${9 - index}.0`; // Versiones recientes\n+    \n+    // Versiones más antiguas\n+    const patchVersion = Math.max(1, total - index);\n+    return `0.1.${patchVersion}`;\n+  }\n+}\n+\n+// Ejecutar script\n+if (import.meta.main) {\n+  const manager = new VersionManager();\n+  \n+  const args = process.argv.slice(2);\n+  const isInit = args.includes('--init') || args.includes('-i');\n+  const isSync = args.includes('--sync') || args.includes('-s');\n+  const autoApprove = args.includes('--auto-approve');\n+  const noSync = args.includes('--no-sync');\n+  const quiet = args.includes('--quiet');\n+  \n+  // Parsear parámetros adicionales\n+  const typeIndex = args.indexOf('--type');\n+  const type = typeIndex > -1 && args[typeIndex + 1] ? args[typeIndex + 1] as Version['type'] : undefined;\n+  \n+  const prefixIndex = args.indexOf('--prefix');\n+  const prefix = prefixIndex > -1 ? (args[prefixIndex + 1] || '') : undefined;\n+  \n+  // Validar tipo si se especifica\n+  if (type && !['major', 'minor', 'patch'].includes(type)) {\n+    console.error(`❌ Tipo de versión inválido: ${type}. Válidos: major, minor, patch`);\n+    process.exit(1);\n+  }\n+\n+  // Mostrar ayuda\n+  if (args.includes('--help') || args.includes('-h')) {\n+    console.log(`\n+🚀 Version Manager para Better Logger\n+\n+Uso:\n+  node project-utils/version-manager.ts [opciones]\n+\n+Opciones:\n+  --init, -i              Inicializar desde historial completo\n+  --sync, -s              Sincronizar archivos de configuración\n+  --auto-approve          Ejecución automática sin confirmaciones\n+  --no-sync               No sincronizar archivos de configuración\n+  --quiet                 Ejecución silenciosa (solo errores y resultados)\n+  --type <tipo>           Forzar tipo de versión (major|minor|patch)\n+  --prefix <prefijo>      Cambiar prefijo (pre-alpha|alpha|beta|rc|'' para stable)\n+  --help, -h              Mostrar esta ayuda\n+\n+Ejemplos:\n+  node project-utils/version-manager.ts                         # Análisis automático\n+  node project-utils/version-manager.ts --auto-approve          # Ejecución silenciosa\n+  node project-utils/version-manager.ts --type minor --auto-approve\n+  node project-utils/version-manager.ts --prefix beta --auto-approve\n+  node project-utils/version-manager.ts --sync --auto-approve\n+  node project-utils/version-manager.ts --quiet --auto-approve   # Para workflows\n+`);\n+    process.exit(0);\n+  }\n+\n+  try {\n+    if (isInit) {\n+      await manager.initializeFromHistory();\n+    } else if (isSync) {\n+      await manager.syncVersionFiles();\n+    } else {\n+      await manager.analyzeAndVersion({ \n+        type,\n+        prefix: prefix === '' ? undefined : prefix\n+      });\n+    }\n+  } catch (error) {\n+    console.error('❌ Error:', error);\n+    process.exit(1);\n+  }\n+}\n\\ No newline at end of file",
      "lines_added": 967,
      "lines_removed": 0,
      "is_binary": false
    },
    {
      "path": "vite.config.ts",
      "status": "modified",
      "diff": "diff --git a/vite.config.ts b/vite.config.ts\nindex cd6d8ae..a64a3c2 100644\n--- a/vite.config.ts\n+++ b/vite.config.ts\n@@ -1,62 +1,21 @@\n-import { defineConfig } from 'vite'\n+import { defineConfig, UserConfig } from 'vite'\n import { resolve } from 'path'\n import dts from 'vite-plugin-dts'\n \n-export default defineConfig({\n+// Configuración base compartida\n+const baseConfig = {\n   plugins: [\n     dts({\n       include: ['src/**/*'],\n       exclude: ['src/**/*.test.ts', 'src/**/*.spec.ts', 'src/main.ts', 'src/example.ts'],\n-      outDir: 'dist/types',\n       rollupTypes: true,\n       insertTypesEntry: true,\n     })\n   ],\n+  define: {\n+    'process.env.NODE_ENV': JSON.stringify('production')\n+  },\n   build: {\n-    lib: {\n-      entry: {\n-        // Main entry - Full logger with all features\n-        index: resolve(__dirname, 'src/index.ts'),\n-        \n-        // Core module - Minimal logger without advanced features\n-        core: resolve(__dirname, 'src/core.ts'),\n-        \n-        // Styling module - Advanced visual features\n-        styling: resolve(__dirname, 'src/styling-module.ts'),\n-        \n-        // Exports module - Export and remote handlers  \n-        exports: resolve(__dirname, 'src/exports-module.ts')\n-      },\n-      name: 'BetterLogger',\n-      formats: ['es', 'cjs'],\n-      fileName: (format, entryName) => {\n-        const ext = format === 'cjs' ? 'cjs' : 'js';\n-        return `${entryName}.${ext}`;\n-      }\n-    },\n-    rollupOptions: {\n-      external: [],\n-      output: {\n-        globals: {},\n-        exports: 'named',\n-        preserveModules: false,\n-        chunkFileNames: 'chunks/[name]-[hash].js',\n-        manualChunks: (id) => {\n-          // Separate styling features into their own chunk\n-          if (id.includes('styling/') || id.includes('banners.ts') || id.includes('themes.ts')) {\n-            return 'styling';\n-          }\n-          // Separate export handlers\n-          if (id.includes('handlers/Export') || id.includes('handlers/Remote')) {\n-            return 'exports';\n-          }\n-          // Core functionality\n-          if (id.includes('src/types/') || id.includes('src/utils/')) {\n-            return 'core';\n-          }\n-        }\n-      }\n-    },\n     sourcemap: true,\n     minify: 'terser',\n     terserOptions: {\n@@ -77,8 +36,151 @@ export default defineConfig({\n       }\n     },\n     target: 'es2022'\n+  }\n+};\n+\n+// Configuraciones específicas por build\n+const buildConfigs = {\n+  // Build completa - Incluye todas las funcionalidades\n+  full: {\n+    ...baseConfig,\n+    plugins: [\n+      dts({\n+        ...baseConfig.plugins[0].options,\n+        outDir: 'dist/types',\n+      })\n+    ],\n+    build: {\n+      ...baseConfig.build,\n+      outDir: 'dist',\n+      lib: {\n+        entry: {\n+          index: resolve(__dirname, 'src/index.ts'),\n+          core: resolve(__dirname, 'src/core.ts'),\n+          styling: resolve(__dirname, 'src/styling-module.ts'),\n+          exports: resolve(__dirname, 'src/exports-module.ts')\n+        },\n+        name: 'BetterLogger',\n+        formats: ['es', 'cjs'],\n+        fileName: (format, entryName) => {\n+          const ext = format === 'cjs' ? 'cjs' : 'js';\n+          return `${entryName}.${ext}`;\n+        }\n+      },\n+      rollupOptions: {\n+        external: [],\n+        output: {\n+          globals: {},\n+          exports: 'named',\n+          preserveModules: false,\n+          chunkFileNames: 'chunks/[name]-[hash].js'\n+        }\n+      }\n+    }\n   },\n-  define: {\n-    'process.env.NODE_ENV': JSON.stringify('production')\n+\n+  // Build modular - Solo core (logger básico)\n+  core: {\n+    ...baseConfig,\n+    plugins: [\n+      dts({\n+        ...baseConfig.plugins[0].options,\n+        outDir: 'dist/modular/core/types',\n+        include: ['src/core.ts', 'src/constants.ts', 'src/types/**/*'],\n+      })\n+    ],\n+    build: {\n+      ...baseConfig.build,\n+      outDir: 'dist/modular/core',\n+      lib: {\n+        entry: resolve(__dirname, 'src/core.ts'),\n+        name: 'BetterLoggerCore',\n+        formats: ['es', 'cjs'],\n+        fileName: (format) => {\n+          const ext = format === 'cjs' ? 'cjs' : 'js';\n+          return `index.${ext}`;\n+        }\n+      },\n+      rollupOptions: {\n+        external: [],\n+        output: {\n+          globals: {},\n+          exports: 'named'\n+        }\n+      }\n+    }\n+  },\n+\n+  // Build modular - Solo styling (características visuales)\n+  styling: {\n+    ...baseConfig,\n+    plugins: [\n+      dts({\n+        ...baseConfig.plugins[0].options,\n+        outDir: 'dist/modular/styling/types',\n+        include: ['src/styling-module.ts', 'src/constants.ts', 'src/types/**/*'],\n+      })\n+    ],\n+    build: {\n+      ...baseConfig.build,\n+      outDir: 'dist/modular/styling',\n+      lib: {\n+        entry: resolve(__dirname, 'src/styling-module.ts'),\n+        name: 'BetterLoggerStyling',\n+        formats: ['es', 'cjs'],\n+        fileName: (format) => {\n+          const ext = format === 'cjs' ? 'cjs' : 'js';\n+          return `index.${ext}`;\n+        }\n+      },\n+      rollupOptions: {\n+        external: [],\n+        output: {\n+          globals: {},\n+          exports: 'named'\n+        }\n+      }\n+    }\n+  },\n+\n+  // Build modular - Solo exports (handlers de exportación)\n+  exports: {\n+    ...baseConfig,\n+    plugins: [\n+      dts({\n+        ...baseConfig.plugins[0].options,\n+        outDir: 'dist/modular/exports/types',\n+        include: ['src/exports-module.ts', 'src/constants.ts', 'src/types/**/*'],\n+      })\n+    ],\n+    build: {\n+      ...baseConfig.build,\n+      outDir: 'dist/modular/exports',\n+      lib: {\n+        entry: resolve(__dirname, 'src/exports-module.ts'),\n+        name: 'BetterLoggerExports',\n+        formats: ['es', 'cjs'],\n+        fileName: (format) => {\n+          const ext = format === 'cjs' ? 'cjs' : 'js';\n+          return `index.${ext}`;\n+        }\n+      },\n+      rollupOptions: {\n+        external: [],\n+        output: {\n+          globals: {},\n+          exports: 'named'\n+        }\n+      }\n+    }\n   }\n-})\n\\ No newline at end of file\n+};\n+\n+// Determinar configuración según variable de entorno\n+const buildMode = process.env.BUILD_MODE || 'full';\n+\n+if (!buildConfigs[buildMode]) {\n+  throw new Error(`Build mode \"${buildMode}\" not found. Available modes: ${Object.keys(buildConfigs).join(', ')}`);\n+}\n+\n+export default defineConfig(buildConfigs[buildMode] as UserConfig);\n\\ No newline at end of file",
      "lines_added": 152,
      "lines_removed": 50,
      "is_binary": false
    }
  ],
  "stats": {
    "total_files": 24,
    "total_additions": 162,
    "total_deletions": 3,
    "files_by_extension": {
      "yml": 9,
      "json": 2,
      "md": 3,
      "txt": 1,
      "ts": 8,
      "js": 1
    },
    "directories_affected": [
      ".github",
      "...",
      "package.json",
      "project-utils",
      "vite.config.ts"
    ]
  },
  "project_context": {
    "name": "OpenTUI",
    "description": "Modern Terminal User Interface Framework",
    "tech_stack": [
      "TypeScript",
      "Node.js",
      "Terminal UI",
      "CLI"
    ],
    "target_platform": "Cross-platform (macOS, Linux, Windows)"
  },
  "commit_patterns": "No commit patterns found"
}